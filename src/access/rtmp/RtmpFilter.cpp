#include "RtmpFilter.h"
#include "x_string.h"
#include "x_socket.h"
#include "x_mux_factory.h"
#include "x_resource_manager.h"

JO_IMPLEMENT_INTERFACE(Filter, "rtmp", CRtmpFilter::Maker)

CRtmpFilter::CRtmpFilter()
{
	m_muxFilter = NULL;
	memset(m_strResid, 0, sizeof(m_strResid));
	memset(m_read_buff, 0, sizeof(m_read_buff));
	m_read_len = 0;
	m_state = rtmp_init;
}

CRtmpFilter::~CRtmpFilter()
{
	if (m_muxFilter)
		JoMuxFactory->DelMux(this);
}

j_result_t CRtmpFilter::Parser(J_AsioDataBase &asioData)
{
	j_result_t nResult = J_OK;
	if (m_state == rtmp_init)
	{
		delete asioData.ioRead.buf;
		m_state = rtmp_hand_shake;

		nResult = J_UNKNOW;
	}
	else if (m_state == rtmp_hand_shake3)
	{
		m_state = rtmp_head_type;
		nResult = J_PROTOCOL_CONSULT;
	}
	else if (m_state == rtmp_head_type)
	{
		m_read_len = 0;
		memset(m_read_buff, 0, sizeof(m_read_buff));
		memcpy(m_read_buff + m_read_len, asioData.ioRead.buf, asioData.ioRead.finishedLen);
		m_read_len += asioData.ioRead.finishedLen;
		m_state = rtmp_head_body;
		nResult = J_PROTOCOL_CONSULT;
	}
	else if (m_state == rtmp_head_body)
	{
		memcpy(m_read_buff + m_read_len, asioData.ioRead.buf, asioData.ioRead.finishedLen);
		m_read_len += asioData.ioRead.finishedLen;
		m_state = rtmp_body;
		nResult = J_PROTOCOL_CONSULT;
	}
	else if (m_state == rtmp_body)
	{
		memcpy(m_read_buff + m_read_len, asioData.ioRead.buf, asioData.ioRead.finishedLen);
		m_read_len += asioData.ioRead.finishedLen;
		int nState = ParserMSF(m_read_buff);
		if (nState != 0)
			m_state = nState;
		if (m_state == rtmp_server_bw || m_state == rtmp_create_stream_invoke)
		{
			nResult = J_UNKNOW;
		}
		else if (m_state == rtmp_chunk_size)
		{
			m_nCommandType = jo_start_real;
			m_nStreamType = 0;
			memset(m_strResid, 0, sizeof(m_strResid));
			memcpy(m_strResid, "100", strlen("100"));
			m_muxFilter = JoMuxFactory->GetMux(this, "flv");
			nResult = J_OK;
		}
		else
		{
			m_state = rtmp_head_type;
			nResult = J_PROTOCOL_CONSULT;
		}
	}
	return nResult;
}

const j_char_t *CRtmpFilter::GetResourceType()
{
	return "jofs";
}

j_result_t CRtmpFilter::Convert(const char *pInputData, J_StreamHeader &streamHeader, char *pOutputData, int &nOutLen)
{
	return m_muxFilter->Convert((const char *)pInputData, streamHeader, pOutputData, nOutLen);
}

j_result_t CRtmpFilter::Complete(J_AsioDataBase &asioData)
{
	if (m_state == rtmp_hand_shake)
	{
		m_read_buff[0] = 0x03;
		memcpy(m_read_buff + 1, asioData.ioRead.buf + 1, 1536);
		memcpy(m_read_buff + 1537, asioData.ioRead.buf + 1, 1536);
		asioData.ioWrite.buf = m_read_buff;
		asioData.ioWrite.bufLen = 3074;
		asioData.ioWrite.whole = true;
		asioData.ioCall = J_AsioDataBase::j_write_e;
		asioData.ioWrite.shared = false;
		m_state = rtmp_hand_shake2;
	}
	else if (m_state == rtmp_hand_shake2)
	{
		asioData.ioRead.bufLen = 1536;
		m_state = rtmp_hand_shake3;
	}
	else if (m_state == rtmp_head_type)
	{
		memset(m_read_buff, 0, sizeof(m_read_buff));
		m_read_len = 0;
		asioData.ioRead.bufLen = 1;
		asioData.ioRead.whole = true;
	}
	else if (m_state == rtmp_head_body)
	{
		if ((m_read_buff[0] & 0xFF) == 0x00)
		{
			asioData.ioRead.whole = true;
			asioData.ioRead.bufLen = 1;
			m_state = rtmp_head_type;
		}
		else
		{
			asioData.ioRead.bufLen = GetHeadLength(m_read_buff) - 1;
			asioData.ioRead.whole = true;
		}
	}
	else if (m_state == rtmp_body)
	{
		asioData.ioRead.bufLen = ((m_read_buff[4] & 0xFF) << 16) + ((m_read_buff[5] & 0xFF) << 8) + (m_read_buff[6] & 0xFF);
		asioData.ioRead.whole = true;
	}
	else if (m_state == rtmp_server_bw)
	{
		int nLen = MakeClientBw(m_read_buff);
		nLen += MakeServerBw(m_read_buff + nLen);
		nLen += MakePing(0, 6, 0, 0, m_read_buff + nLen);
		nLen += MakeConnectInvoke(m_read_buff + nLen);
		nLen += MakeOnBWDoneInvoke(m_read_buff + nLen);
		asioData.ioWrite.bufLen = nLen;
		asioData.ioWrite.buf = m_read_buff;
		asioData.ioWrite.whole = true;
		asioData.ioCall = J_AsioDataBase::j_write_e;
		m_state = rtmp_head_type;
	}
	else if (m_state == rtmp_create_stream_invoke)
	{
		asioData.ioWrite.buf = m_read_buff;
		asioData.ioWrite.bufLen = MakeCreateStreamInvoke(m_read_buff);
		asioData.ioWrite.whole = true;
		asioData.ioCall = J_AsioDataBase::j_write_e;
		m_state = rtmp_head_type;
	}
	else if (m_state == rtmp_chunk_size)
	{
		int nLen = MakeChunkSize(m_read_buff);
		nLen += MakePing(4, 6, 0, 0, m_read_buff + nLen);
		nLen += MakePing(0, 6, 0, 0, m_read_buff + nLen);
		nLen += MakePlayResetInvoke(m_read_buff + nLen);
		nLen += MakePlayStartInvoke(m_read_buff + nLen);
		nLen += MakeAccessNotify(m_read_buff + nLen);
		nLen += MakeStartNotify(m_read_buff + nLen);
		//nLen += MakePing(0, 6, 0, 0, m_read_buff + nLen);
		//nLen += MakeMetadataNotify(m_read_buff + nLen);
		asioData.ioWrite.bufLen = nLen;
		asioData.ioWrite.buf = m_read_buff;
		asioData.ioWrite.whole = true;
		asioData.ioCall = J_AsioDataBase::j_write_e;
		m_state = rtmp_head_type;
	}

	return J_OK;
}

int CRtmpFilter::GetDouble(const char *pData)
{
	assert((pData[0] & 0xFF) == rmf_double);
	double llVal = 0;
	char *p = (char *)&llVal;
	for (int i=1,n=7; i<=8; ++i,--n)
	{
		p[n] = pData[i];
	}
	printf("double_val = %lg\n", llVal);
	return 9;
}

int CRtmpFilter::GetBoolean(const char *pData)
{
	assert((pData[0] & 0xFF) == rmf_boolean);
	printf("boolean_val = %s\n", (pData[1] & 0xFF) == true ? "true" : "false");
	return 2;
}

int CRtmpFilter::GetString(const char *pData, char *pVal)
{
	assert((pData[0] & 0xFF) == rmf_string);
	int nLen = ((pData[1] & 0xFF) << 8) + (pData[2] & 0xFF);
	printf("string_len = %d\n", nLen);
	char *p = new char[nLen + 1];
	memset (p, 0, nLen + 1);
	for (int i=3,n=0; n<nLen; ++i,++n)
	{
		p[n] = pData[i];
	}
	if (pVal != NULL)
		strcpy(pVal, p);
	printf("string_val = %s\n", p);
	delete p;

	return nLen + 3;
}

int CRtmpFilter::GetEmpty(const char *pData)
{
	assert((pData[0] & 0xFF) == rmf_undefined);
	printf("empty\n");
	return 1;
}

int CRtmpFilter::GetObjKey(const char *pData)
{
	int nLen = ((pData[0] & 0xFF) << 8) + (pData[1] & 0xFF);
	char *p_src = (char *)pData;
	int nOffset = 0;
	if (nLen == 0 || nLen > 0xFF)
	{
		nLen = ((pData[1] & 0xFF) << 8) + (pData[2] & 0xFF);
		p_src += 1;
		nOffset = 1;
	}
	printf("key_len = %d\n", nLen);
	char *p = new char[nLen + 1];
	memset (p, 0, nLen + 1);
	for (int i=2,n=0; n<nLen; ++i,++n)
	{
		p[n] = p_src[i];
	}
	printf("key_val = %s\n", p);
	delete p;

	return nLen + 2 + nOffset;
}

int CRtmpFilter::GetObjVal(const char *pData)
{
	int nDataSize = 0;
	char *p = (char *)pData;
	int nOffset = 0;
	if ((p[0] & 0xFF) > 0xF)
	{
		p += 1;
		nOffset = 1;
	}
	switch(p[0] & 0xFF)
	{
	case rmf_boolean:
		nDataSize = GetBoolean(p);
		break;
	case rmf_string:
		nDataSize =  GetString(p);
		break;
	case rmf_double:
		nDataSize =  GetDouble(p);		
		break;
	case rmf_undefined:
		nDataSize = GetEmpty(p);
		break;
	}
	
	return nDataSize + nOffset;
}

int CRtmpFilter::GetObject(const char *pData)
{
	assert((pData[0] & 0xFF) == rmf_object);
	const char rmf_obj_end[] = {0x00, 0x00, 0x09};
	char *p = (char *)(pData + 1);
	int nLen = 0;
	int nTotleLen = 0;
	while (memcmp(p, rmf_obj_end, sizeof(rmf_obj_end)) != 0)
	{
		nLen = GetObjKey(p);
		p += nLen;
		nTotleLen += nLen;
		nLen = GetObjVal(p);
		p += nLen;
		nTotleLen += nLen;
	}
	return nTotleLen + 4;
}

int CRtmpFilter::GetHeadLength(const char *pData)
{
	int nLen = 0;
	switch((pData[0] & 0xFF) >> 6)
	{
	case 0:
		nLen = 12;	break;
	case 1:
		nLen = 8;		break;
	case 2:
		nLen = 4;		break;
	case 3:
		nLen = 1;		break;
	}
	return nLen;
}

int CRtmpFilter::ParserMSF(const char *pData)
{
	int nHeadLen = GetHeadLength(pData);
	char *p = (char *)pData;
	///解析AMF Head
	printf("Head_Type = %d\n", pData[0] & 0x3F);
	printf("TIME_STAMP = %d\n", ((pData[1] & 0xFF) << 16) + ((pData[2] & 0xFF) << 8) + (pData[3] & 0xFF));
	int nAmfSize = ((pData[4] & 0xFF) << 16) + ((pData[5] & 0xFF) << 8) + (pData[6] & 0xFF);
	printf("AMFSize = %d\n", nAmfSize);
	int nAmfType = pData[7] & 0xFF;
	printf("AMFType = %02X\n", nAmfType);
	int nStreamId = ((pData[8] & 0xFF) << 24) + ((pData[9] & 0xFF) << 16) + ((pData[10] & 0xFF) << 8) + (pData[11] & 0xFF);
	printf("StreamID = %d\n", nStreamId);
	///解析数据
	p += nHeadLen;
	int nDataSize = 0;
	int nState = 0;
	char amfCommand[256] = {0};
	while (nAmfSize > 0)
	{
		switch(p[0] & 0xFF)
		{
		case rmf_string:
			nDataSize =  GetString(p, amfCommand);
			break;
		case rmf_double:
			nDataSize =  GetDouble(p);		
			break;
		case rmf_object:
			nDataSize = GetObject(p);
			break;
		default:
			nDataSize = 1;
			break;
		}
		if (memcmp(amfCommand, "connect", strlen("connect")) == 0)
			nState = rtmp_server_bw;
		else if (memcmp(amfCommand, "createStream", strlen("createStream")) == 0)
			nState = rtmp_create_stream_invoke;
		else if (memcmp(amfCommand, "play", strlen("play")) == 0)
			nState = rtmp_chunk_size;
		p +=	 nDataSize;
		nAmfSize -= nDataSize;
	}

	return nState;
}

int CRtmpFilter::MakeServerBw(char *pData)
{
	const char server_bw[] = { 
		0x02,0x00,0x00,0x00,0x00,0x00,0x04,0x05,0x00,0x00,0x00,0x00,0x00,0x26,0x25,0xa0
	};
	memcpy(pData, server_bw, sizeof(server_bw));
	return sizeof(server_bw);
}

int CRtmpFilter::MakeClientBw(char *pData)
{
	const char client_bw[] = { 
		0x02,0x00,0x00,0x00,0x00,0x00,0x05,0x06,0x00,0x00,0x00,0x00,0x00,0x26,0x25,0xa0,0x02
	};
	memcpy(pData, client_bw, sizeof(client_bw));
	return sizeof(client_bw);
}

int CRtmpFilter::MakePing(int nType, int nLen, int nStreamId, int nParam2, char *pData)
{
	char *p = pData;
	p[0] = 0x02; p[1] = 0x00; p[2] = 0x00; p[3] = 0x00;
	p += 4;
	p[0] = (nLen >> 16) & 0xFF; 
	p[1] = (nLen >> 8) & 0xFF; 
	p[2] = nLen & 0xFF;
	p += 3;
	p[0] = 0x04;
	p[1] = (nStreamId >> 24) & 0xFF;; 
	p[2] = (nStreamId >> 16) & 0xFF; 
	p[3] = (nStreamId >> 8) & 0xFF; 
	p[4] = nStreamId & 0xFF;
	p += 5;
	p[0] = (nType >> 8) & 0xFF; 
	p[1] = nType & 0xFF;
	p += 2;
	p[0] = (nParam2 >> 24) & 0xFF;; 
	p[1] = (nParam2 >> 16) & 0xFF; 
	p[2] = (nParam2 >> 8) & 0xFF; 
	p[3] = nParam2 & 0xFF;
	p += 4;

	return p - pData;
}

int CRtmpFilter::MakeConnectInvoke(char *pData)
{
	const char connect_invoke[] = { 
		 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x07, 0x5f,
		 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x00, 0x3f, 0xf0,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
		 0x00, 0x06, 0x66, 0x6d, 0x73, 0x56, 0x65, 0x72,0x02, 0x00, 0x0d, 0x46, 0x4d, 0x53, 0x2f,  0x33,
		 0x2c, 0x35, 0x2c, 0x32,  0x2c, 0x36, 0x35, 0x34,0x00, 0x0c, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69,
		 0x6c, 0x69, 0x74, 0x69,  0x65, 0x73, 0x00, 0x40,0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		 0x04, 0x6d, 0x6f, 0x64,  0x65, 0x00, 0x3f,  0xf0, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		 0x09, 0x03, 0x00, 0x05, 0x6c, 0x65, 0x76,  0x65,0x6c, 0x02, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74,
		 0x75, 0x73, 0x00, 0x04, 0x63, 0x6f, 0x64,  0x65, 0x02, 0x00,0x1d, 0x4e, 0x65, 0x74, 0x43, 0x6f,
		 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,  0x6e, 0x2e, 0x43, 0x6f, 0x6e, 0xc3, 0x6e, 0x65, 0x63,
		 0x74, 0x2e, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x00, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
		 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,  0x02, 0x00, 0x15, 0x43, 0x6f,  0x6e, 0x6e, 0x65, 0x63, 0x74,
		 0x69, 0x6f, 0x6e, 0x20,  0x73,0x75,  0x63, 0x63, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2e, 0x00, 0x0e,
		 0x6f, 0x62, 0x6a, 0x65,  0x63,0x74,  0x45, 0x6e, 0x63, 0x6f,  0x64, 0x69, 0x6e, 0x67, 0x00, 0x00,
		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x64, 0x61,  0x74, 0x61, 0x08, 0x00, 0x00,
		 0x00, 0x00, 0x00, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,  0x6e,  0x02, 0x00, 0x09, 0x33, 0x2c,
		 0x35, 0x2c, 0x32, 0x2c, 0x36, 0x35, 0x34, 0x00, 0x00, 0x09,  0x00,  0x00, 0x09
	};
	memcpy(pData, connect_invoke, sizeof(connect_invoke));
	return sizeof(connect_invoke);
}

int CRtmpFilter::MakeOnBWDoneInvoke(char *pData)
{
	const char bwdone_invoke[] = { 
		0x03, 0x00, 0x00,0x00, 0x00, 0x00, 0x15, 0x14, 0x00, 0x00, 0x00, 0x00, 0x02,  0x00,  0x08, 0x6f, 
		0x6e, 0x42, 0x57,0x44, 0x6f, 0x6e, 0x65, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00,  0x00, 0x00, 
		0x05
	};
	memcpy(pData, bwdone_invoke, sizeof(bwdone_invoke));
	return sizeof(bwdone_invoke);
}

int CRtmpFilter::MakeCreateStreamInvoke(char *pData)
{
	const char create_stream_invoke[] = { 
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x14, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x07, 0x5f,
		0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
		0x00, 0x3f, 0xf0,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	memcpy(pData, create_stream_invoke, sizeof(create_stream_invoke));
	return sizeof(create_stream_invoke);
}

int CRtmpFilter::MakeChunkSize(char *pData)
{
	const char chunk_size[] = { 
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00
	};
	memcpy(pData, chunk_size, sizeof(chunk_size));
	return sizeof(chunk_size);
}

int CRtmpFilter::MakePlayResetInvoke(char *pData)
{
	const char play_reset[] = { 
		0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb4, 0x14, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x6f,
		0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x03, 0x00, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x02, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74,
		0x75, 0x73, 0x00, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x02, 0x00, 0x14, 0x4e, 0x65, 0x74, 0x53, 0x74,
		0x72, 0x65, 0x61, 0x6d, 0x2e, 0x50, 0x6c, 0x61, 0x79, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x74, 0x00,
		0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x02, 0x00, 0x2a, 0x50,
		0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x73, 0x65, 0x74,
		0x74, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x31, 0x5f, 0x35, 0x30, 0x30,
		0x6b, 0x62, 0x70, 0x73, 0x2e, 0x66, 0x34, 0x76, 0x2e, 0x00, 0x07, 0x64, 0x65, 0x74, 0x61, 0x69,
		0x6c, 0x73, 0x02, 0x00, 0x13, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x31, 0x5f, 0x35, 0x30, 0x30,
		0x6b, 0x62, 0x70, 0x73, 0x2e, 0x66, 0x34, 0x76, 0x00, 0x08, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
		0x69, 0x64, 0x02, 0x00, 0x08, 0x42, 0x43, 0x41, 0x49, 0x73, 0x6e, 0x6a, 0x41, 0x00, 0x00, 0x09
	};
	memcpy(pData, play_reset, sizeof(play_reset));
	return sizeof(play_reset);
}

int CRtmpFilter::MakePlayStartInvoke(char *pData)
{
	const char play_start[] = { 
		0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x14, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x6f,
		0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x03, 0x00, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x02, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74,
		0x75, 0x73, 0x00, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x02, 0x00, 0x14, 0x4e, 0x65, 0x74, 0x53, 0x74,
		0x72, 0x65, 0x61, 0x6d, 0x2e, 0x50, 0x6c, 0x61, 0x79, 0x2e, 0x53, 0x74, 0x61, 0x72, 0x74, 0x00,
		0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x02, 0x00, 0x24, 0x53,
		0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x73,
		0x61, 0x6d, 0x70, 0x6c, 0x65, 0x31, 0x5f, 0x35, 0x30, 0x30, 0x6b, 0x62, 0x70, 0x73, 0x2e, 0x66,
		0x34, 0x76, 0x2e, 0x00, 0x07, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x02, 0x00, 0x13, 0x73,
		0x61, 0x6d, 0x70, 0x6c, 0x65, 0x31, 0x5f, 0x35, 0x30, 0x30, 0x6b, 0x62, 0x70, 0x73, 0x2e, 0x66,
		0x34, 0x76, 0x00, 0x08, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x69, 0x64, 0x02, 0x00, 0x08, 0x42,
		0x43, 0x41, 0x49, 0x73, 0x6e, 0x6a, 0x41, 0x00, 0x00, 0x09
	};
	memcpy(pData, play_start, sizeof(play_start));
	return sizeof(play_start);
}

int CRtmpFilter::MakeAccessNotify(char *pData)
{
	const char access_notify[] = { 
		0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x12, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x11, 0x7c,
		0x52, 0x74, 0x6d, 0x70, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
		0x01, 0x00, 0x01, 0x00
	};
	memcpy(pData, access_notify, sizeof(access_notify));
	return sizeof(access_notify);
}

int CRtmpFilter::MakeStartNotify(char *pData)
{
	const char start_notify[] = { 
		0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x12, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x6f,
		0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x03, 0x00, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x02, 0x00,
		0x14, 0x4e, 0x65, 0x74, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x2e,
		0x53, 0x74, 0x61, 0x72, 0x74, 0x00, 0x00, 0x09
	};
	memcpy(pData, start_notify, sizeof(start_notify));
	return sizeof(start_notify);
}

int CRtmpFilter::MakeMetadataNotify(char *pData)
{
	const char metadata_notify[] = { 
		0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x12, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0a, 0x6f,
		0x6e, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61, 0x08, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x08,
		0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,  0x00, 0x40, 0x80, 0xe3, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x00, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x00, 0x40, 0x65, 0xc0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x00, 0x40, 0x62, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0d, 0x76, 0x69, 0x64, 0x65, 0x6f,  0x64, 0x61, 0x74, 0x61, 0x72, 0x61, 0x74,
		0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x66, 0x72, 0x61, 0x6d,
		0x65, 0x72, 0x61, 0x74, 0x65, 0x00, 0x40, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
		0x76, 0x69, 0x64, 0x65, 0x6f, 0x63,  0x6f, 0x64, 0x65, 0x63,  0x69, 0x64, 0x00, 0x40, 0x1c, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x6d, 0x61, 0x6a, 0x6f, 0x72,  0x5f, 0x62, 0x72, 0x61,
		0x6e, 0x64, 0x02, 0x00, 0x04, 0x6d, 0x70, 0x34, 0x32, 0x00, 0x0d, 0x6d, 0x69, 0x6e, 0x6f, 0x72,
		0x5f, 0x76, 0x65, 0x72, 0x73, 0x69,  0x6f, 0x6e, 0x02,  0x00, 0x01, 0x30, 0x00, 0x11, 0x63, 0x6f,
		0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x5f,  0x62, 0x72, 0x61, 0x6e, 0x64, 0x73, 0x02,
		0x00, 0x0c, 0x6d, 0x70, 0x34, 0x32, 0x6d, 0x70, 0x34, 0x31, 0x69, 0x73, 0x6f, 0x6d, 0x00, 0x07,
		0x65, 0x6e, 0x63, 0x6f, 0x64,  0x65, 0x72, 0x02, 0x00, 0x0d, 0x4c, 0x61, 0x76, 0x66, 0x35, 0x35,
		0x2e, 0x32, 0x32, 0x2e, 0x31, 0x30, 0x30, 0x00, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x69, 0x7a,
		0x65, 0x00, 0x41, 0x64, 0x7b, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09
	};
	memcpy(pData, metadata_notify, sizeof(metadata_notify));
	return sizeof(metadata_notify);
}