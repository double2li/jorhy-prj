/* soapStub.h
   Generated by gSOAP 2.8.0 from Onvif.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_WSA_200408
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_tan	"http://www.onvif.org/ver20/analytics/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_ns1	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_ns2	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_ns3	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_tds	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_tev	"http://www.onvif.org/ver10/events/wsdl"
#define SOAP_NAMESPACE_OF_ns7	""
#define SOAP_NAMESPACE_OF_ns4	"http://docs.oasis-open.org/wsrf/rw-2"
#define SOAP_NAMESPACE_OF_ns5	"http://docs.oasis-open.org/wsrf/r-2"
#define SOAP_NAMESPACE_OF_timg	"http://www.onvif.org/ver20/imaging/wsdl"
#define SOAP_NAMESPACE_OF_trt	"http://www.onvif.org/ver10/media/wsdl"
#define SOAP_NAMESPACE_OF_tptz	"http://www.onvif.org/ver20/ptz/wsdl"
#define SOAP_NAMESPACE_OF_dn	"http://www.onvif.org/ver10/network/wsdl"
#define SOAP_NAMESPACE_OF_ns6	"http://schemas.xmlsoap.org/ws/2005/04/discovery"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_wsa__RelationshipTypeValues
#define SOAP_TYPE_wsa__RelationshipTypeValues (13)
/* wsa:RelationshipTypeValues */
enum wsa__RelationshipTypeValues {wsa__Reply = 0};
typedef enum wsa__RelationshipTypeValues wsa__RelationshipTypeValues;
#endif

#ifndef SOAP_TYPE_wsa__FaultSubcodeValues
#define SOAP_TYPE_wsa__FaultSubcodeValues (14)
/* wsa:FaultSubcodeValues */
enum wsa__FaultSubcodeValues {wsa__InvalidMessageInformationHeader = 0, wsa__MessageInformationHeaderRequired = 1, wsa__DestinationUnreachable = 2, wsa__ActionNotSupported = 3, wsa__EndpointUnavailable = 4};
typedef enum wsa__FaultSubcodeValues wsa__FaultSubcodeValues;
#endif

#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (45)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0};
typedef enum wsa5__RelationshipType wsa5__RelationshipType;
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (46)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {wsa5__InvalidAddressingHeader = 0, wsa5__InvalidAddress = 1, wsa5__InvalidEPR = 2, wsa5__InvalidCardinality = 3, wsa5__MissingAddressInEPR = 4, wsa5__DuplicateMessageID = 5, wsa5__ActionMismatch = 6, wsa5__MessageAddressingHeaderRequired = 7, wsa5__DestinationUnreachable = 8, wsa5__ActionNotSupported = 9, wsa5__EndpointUnavailable = 10};
typedef enum wsa5__FaultCodesType wsa5__FaultCodesType;
#endif

#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (64)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter {wsa5__false = 0, wsa5__true = 1};
typedef enum _wsa5__IsReferenceParameter _wsa5__IsReferenceParameter;
#endif

#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (69)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {wsu__MessageExpired = 0};
typedef enum wsu__tTimestampFault wsu__tTimestampFault;
#endif

#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (71)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {wsse__UnsupportedSecurityToken = 0, wsse__UnsupportedAlgorithm = 1, wsse__InvalidSecurity = 2, wsse__InvalidSecurityToken = 3, wsse__FailedAuthentication = 4, wsse__FailedCheck = 5, wsse__SecurityTokenUnavailable = 6};
typedef enum wsse__FaultcodeEnum wsse__FaultcodeEnum;
#endif

#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (786)
/* tt:VideoEncoding */
enum tt__VideoEncoding {tt__VideoEncoding__JPEG = 0, tt__VideoEncoding__MPEG4 = 1, tt__VideoEncoding__H264 = 2};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (788)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile {tt__Mpeg4Profile__SP = 0, tt__Mpeg4Profile__ASP = 1};
#endif

#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (790)
/* tt:H264Profile */
enum tt__H264Profile {tt__H264Profile__Baseline = 0, tt__H264Profile__Main = 1, tt__H264Profile__Extended = 2, tt__H264Profile__High = 3};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (792)
/* tt:AudioEncoding */
enum tt__AudioEncoding {tt__AudioEncoding__G711 = 0, tt__AudioEncoding__G726 = 1, tt__AudioEncoding__AAC = 2};
#endif

#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (794)
/* tt:StreamType */
enum tt__StreamType {tt__StreamType__RTP_Unicast = 0, tt__StreamType__RTP_Multicast = 1};
#endif

#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (796)
/* tt:TransportProtocol */
enum tt__TransportProtocol {tt__TransportProtocol__UDP = 0, tt__TransportProtocol__TCP = 1, tt__TransportProtocol__RTSP = 2, tt__TransportProtocol__HTTP = 3};
#endif

#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (798)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition {tt__ScopeDefinition__Fixed = 0, tt__ScopeDefinition__Configurable = 1};
#endif

#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (800)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode {tt__DiscoveryMode__Discoverable = 0, tt__DiscoveryMode__NonDiscoverable = 1};
#endif

#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (802)
/* tt:Duplex */
enum tt__Duplex {tt__Duplex__Full = 0, tt__Duplex__Half = 1};
#endif

#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (806)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration {tt__IPv6DHCPConfiguration__Auto = 0, tt__IPv6DHCPConfiguration__Stateful = 1, tt__IPv6DHCPConfiguration__Stateless = 2, tt__IPv6DHCPConfiguration__Off = 3};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (808)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType {tt__NetworkProtocolType__HTTP = 0, tt__NetworkProtocolType__HTTPS = 1, tt__NetworkProtocolType__RTSP = 2};
#endif

#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (810)
/* tt:NetworkHostType */
enum tt__NetworkHostType {tt__NetworkHostType__IPv4 = 0, tt__NetworkHostType__IPv6 = 1, tt__NetworkHostType__DNS = 2};
#endif

#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (818)
/* tt:IPType */
enum tt__IPType {tt__IPType__IPv4 = 0, tt__IPType__IPv6 = 1};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (824)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType {tt__IPAddressFilterType__Allow = 0, tt__IPAddressFilterType__Deny = 1};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (826)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType {tt__DynamicDNSType__NoUpdate = 0, tt__DynamicDNSType__ClientUpdates = 1, tt__DynamicDNSType__ServerUpdates = 2};
#endif

#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (828)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory {tt__CapabilityCategory__All = 0, tt__CapabilityCategory__Analytics = 1, tt__CapabilityCategory__Device = 2, tt__CapabilityCategory__Events = 3, tt__CapabilityCategory__Imaging = 4, tt__CapabilityCategory__Media = 5, tt__CapabilityCategory__PTZ = 6};
#endif

#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (830)
/* tt:SystemLogType */
enum tt__SystemLogType {tt__SystemLogType__System = 0, tt__SystemLogType__Access = 1};
#endif

#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (832)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType {tt__FactoryDefaultType__Hard = 0, tt__FactoryDefaultType__Soft = 1};
#endif

#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (834)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType {tt__SetDateTimeType__Manual = 0, tt__SetDateTimeType__NTP = 1};
#endif

#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (836)
/* tt:UserLevel */
enum tt__UserLevel {tt__UserLevel__Administrator = 0, tt__UserLevel__Operator = 1, tt__UserLevel__User = 2, tt__UserLevel__Anonymous = 3, tt__UserLevel__Extended = 4};
#endif

#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (838)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState {tt__RelayLogicalState__active = 0, tt__RelayLogicalState__inactive = 1};
#endif

#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (840)
/* tt:RelayIdleState */
enum tt__RelayIdleState {tt__RelayIdleState__closed = 0, tt__RelayIdleState__open = 1};
#endif

#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (842)
/* tt:RelayMode */
enum tt__RelayMode {tt__RelayMode__Monostable = 0, tt__RelayMode__Bistable = 1};
#endif

#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (846)
/* tt:MoveStatus */
enum tt__MoveStatus {tt__MoveStatus__IDLE = 0, tt__MoveStatus__MOVING = 1, tt__MoveStatus__UNKNOWN = 2};
#endif

#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (848)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode {tt__AutoFocusMode__AUTO = 0, tt__AutoFocusMode__MANUAL = 1};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (850)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode {tt__WideDynamicMode__OFF = 0, tt__WideDynamicMode__ON = 1};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (852)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode {tt__BacklightCompensationMode__OFF = 0, tt__BacklightCompensationMode__ON = 1};
#endif

#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (854)
/* tt:ExposurePriority */
enum tt__ExposurePriority {tt__ExposurePriority__LowNoise = 0, tt__ExposurePriority__FrameRate = 1};
#endif

#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (856)
/* tt:ExposureMode */
enum tt__ExposureMode {tt__ExposureMode__AUTO = 0, tt__ExposureMode__MANUAL = 1};
#endif

#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (858)
/* tt:Enabled */
enum tt__Enabled {tt__Enabled__ENABLED = 0, tt__Enabled__DISABLED = 1};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (860)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode {tt__WhiteBalanceMode__AUTO = 0, tt__WhiteBalanceMode__MANUAL = 1};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (862)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode {tt__IrCutFilterMode__ON = 0, tt__IrCutFilterMode__OFF = 1, tt__IrCutFilterMode__AUTO = 2};
#endif

#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (866)
/* tt:PropertyOperation */
enum tt__PropertyOperation {tt__PropertyOperation__Initialized = 0, tt__PropertyOperation__Deleted = 1, tt__PropertyOperation__Changed = 2};
#endif

#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (868)
/* tt:Direction */
enum tt__Direction {tt__Direction__Left = 0, tt__Direction__Right = 1, tt__Direction__Any = 2};
#endif

#ifndef SOAP_TYPE_tt__ClassType
#define SOAP_TYPE_tt__ClassType (870)
/* tt:ClassType */
enum tt__ClassType {tt__ClassType__Animal = 0, tt__ClassType__Face = 1, tt__ClassType__Human = 2, tt__ClassType__Vehical = 3, tt__ClassType__Other = 4};
#endif

#ifndef SOAP_TYPE_ns6__RelationshipType
#define SOAP_TYPE_ns6__RelationshipType (878)
/* ns6:RelationshipType */
enum ns6__RelationshipType {ns6__RelationshipType__ns6__Suppression = 0};
#endif

#ifndef SOAP_TYPE_ns6__FaultCodeType
#define SOAP_TYPE_ns6__FaultCodeType (880)
/* ns6:FaultCodeType */
enum ns6__FaultCodeType {ns6__FaultCodeType__ns6__MatchingRuleNotSupported = 0};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (147)
typedef LONG64 xsd__duration;
#endif
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (132)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (8)
/* wsa:EndpointReferenceType */
struct wsa__EndpointReferenceType
{
public:
	char *Address;	/* required element of type xsd:string */
	struct wsa__ReferencePropertiesType *ReferenceProperties;	/* optional element of type wsa:ReferencePropertiesType */
	struct wsa__ReferenceParametersType *ReferenceParameters;	/* optional element of type wsa:ReferenceParametersType */
	char **PortType;	/* optional element of type xsd:QName */
	struct wsa__ServiceNameType *ServiceName;	/* optional element of type wsa:ServiceNameType */
	int __size;	/* sequence of elements <-any> */
	char **__any;
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa__EndpointReferenceType wsa__EndpointReferenceType;
#endif

#ifndef SOAP_TYPE_wsa__ReferencePropertiesType
#define SOAP_TYPE_wsa__ReferencePropertiesType (9)
/* wsa:ReferencePropertiesType */
struct wsa__ReferencePropertiesType
{
public:
	int __size;	/* sequence of elements <-any> */
	char **__any;
};
typedef struct wsa__ReferencePropertiesType wsa__ReferencePropertiesType;
#endif

#ifndef SOAP_TYPE_wsa__ReferenceParametersType
#define SOAP_TYPE_wsa__ReferenceParametersType (10)
/* wsa:ReferenceParametersType */
struct wsa__ReferenceParametersType
{
public:
	int __size;	/* sequence of elements <-any> */
	char **__any;
};
typedef struct wsa__ReferenceParametersType wsa__ReferenceParametersType;
#endif

#ifndef SOAP_TYPE_wsa__ServiceNameType
#define SOAP_TYPE_wsa__ServiceNameType (11)
/* Primitive wsa:ServiceNameType schema type: */
struct wsa__ServiceNameType
{
public:
	char *__item;
	char *PortName;	/* optional attribute of type xsd:string */
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa__ServiceNameType wsa__ServiceNameType;
#endif

#ifndef SOAP_TYPE_wsa__Relationship
#define SOAP_TYPE_wsa__Relationship (12)
/* Primitive wsa:Relationship schema type: */
struct wsa__Relationship
{
public:
	char *__item;
	char *RelationshipType;	/* optional attribute of type xsd:QName */
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa__Relationship wsa__Relationship;
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (30)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	char *wsa__MessageID;	/* optional element of type wsa:MessageID */
	struct wsa__Relationship *wsa__RelatesTo;	/* optional element of type wsa:RelatesTo */
	struct wsa__EndpointReferenceType *wsa__From;	/* optional element of type wsa:From */
	struct wsa__EndpointReferenceType *wsa__ReplyTo;	/* mustUnderstand */
	struct wsa__EndpointReferenceType *wsa__FaultTo;	/* mustUnderstand */
	char *wsa__To;	/* mustUnderstand */
	char *wsa__Action;	/* mustUnderstand */
	char *wsa5__MessageID;	/* optional element of type wsa5:MessageID */
	struct wsa5__RelatesToType *wsa5__RelatesTo;	/* optional element of type wsa5:RelatesTo */
	struct wsa5__EndpointReferenceType *wsa5__From;	/* optional element of type wsa5:From */
	struct wsa5__EndpointReferenceType *wsa5__ReplyTo;	/* mustUnderstand */
	struct wsa5__EndpointReferenceType *wsa5__FaultTo;	/* mustUnderstand */
	char *wsa5__To;	/* mustUnderstand */
	char *wsa5__Action;	/* mustUnderstand */
	struct _wsse__Security *wsse__Security;	/* mustUnderstand */
};
#endif

#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (35)
/* Base64 schema type: */
struct _xop__Include
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
};
typedef struct _xop__Include _xop__Include;
#endif

#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (38)
/* wsa5:EndpointReferenceType */
struct wsa5__EndpointReferenceType
{
public:
	char *Address;	/* required element of type xsd:string */
	struct wsa5__ReferenceParametersType *ReferenceParameters;	/* optional element of type wsa5:ReferenceParametersType */
	struct wsa5__MetadataType *Metadata;	/* optional element of type wsa5:MetadataType */
	int __size;	/* sequence of elements <-any> */
	char **__any;
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa5__EndpointReferenceType wsa5__EndpointReferenceType;
#endif

#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (39)
/* wsa5:ReferenceParametersType */
struct wsa5__ReferenceParametersType
{
public:
	int __size;	/* sequence of elements <-any> */
	char **__any;
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa5__ReferenceParametersType wsa5__ReferenceParametersType;
#endif

#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (40)
/* wsa5:MetadataType */
struct wsa5__MetadataType
{
public:
	int __size;	/* sequence of elements <-any> */
	char **__any;
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa5__MetadataType wsa5__MetadataType;
#endif

#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (42)
/* wsa5:ProblemActionType */
struct wsa5__ProblemActionType
{
public:
	char *Action;	/* optional element of type xsd:string */
	char *SoapAction;	/* optional element of type xsd:string */
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa5__ProblemActionType wsa5__ProblemActionType;
#endif

#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (41)
/* Primitive wsa5:RelatesToType schema type: */
struct wsa5__RelatesToType
{
public:
	char *__item;
	char *RelationshipType;	/* optional attribute of type wsa5:RelationshipTypeOpenEnum */
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
};
typedef struct wsa5__RelatesToType wsa5__RelatesToType;
#endif

#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (70)
/* wsu:Timestamp */
struct _wsu__Timestamp
{
public:
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *Created;	/* optional element of type xsd:string */
	char *Expires;	/* optional element of type xsd:string */
};
typedef struct _wsu__Timestamp _wsu__Timestamp;
#endif

#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (72)
/* wsse:UsernameToken */
struct _wsse__UsernameToken
{
public:
	char *Username;	/* optional element of type xsd:string */
	struct _wsse__Password *Password;	/* optional element of type wsse:Password */
	char *Nonce;	/* optional element of type xsd:string */
	char *wsu__Created;	/* optional element of type xsd:string */
	char *wsu__Id;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__UsernameToken _wsse__UsernameToken;
#endif

#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (75)
/* Primitive wsse:BinarySecurityToken schema type: */
struct _wsse__BinarySecurityToken
{
public:
	char *__item;
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
	char *EncodingType;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__BinarySecurityToken _wsse__BinarySecurityToken;
#endif

#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (76)
/* wsse:Reference */
struct _wsse__Reference
{
public:
	char *URI;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__Reference _wsse__Reference;
#endif

#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (77)
/* wsse:Embedded */
struct _wsse__Embedded
{
public:
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__Embedded _wsse__Embedded;
#endif

#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (78)
/* Primitive wsse:KeyIdentifier schema type: */
struct _wsse__KeyIdentifier
{
public:
	char *__item;
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
	char *EncodingType;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__KeyIdentifier _wsse__KeyIdentifier;
#endif

#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (79)
/* wsse:SecurityTokenReference */
struct _wsse__SecurityTokenReference
{
public:
	struct _wsse__Reference *Reference;	/* optional element of type wsse:Reference */
	struct _wsse__KeyIdentifier *KeyIdentifier;	/* optional element of type wsse:KeyIdentifier */
	struct _wsse__Embedded *Embedded;	/* optional element of type wsse:Embedded */
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *Usage;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__SecurityTokenReference _wsse__SecurityTokenReference;
#endif

#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (83)
/* ds:SignatureType */
struct ds__SignatureType
{
public:
	struct ds__SignedInfoType *SignedInfo;	/* optional element of type ds:SignedInfoType */
	char *SignatureValue;	/* optional element of type xsd:string */
	struct ds__KeyInfoType *KeyInfo;	/* optional element of type ds:KeyInfoType */
	char *Id;	/* optional attribute of type xsd:string */
};
typedef struct ds__SignatureType ds__SignatureType;
#endif

#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (92)
/* c14n:InclusiveNamespaces */
struct _c14n__InclusiveNamespaces
{
public:
	char *PrefixList;	/* optional attribute of type xsd:string */
};
typedef struct _c14n__InclusiveNamespaces _c14n__InclusiveNamespaces;
#endif

#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (93)
/* ds:TransformType */
struct ds__TransformType
{
public:
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of type c14n:InclusiveNamespaces */
	char *__any;
	char *Algorithm;	/* optional attribute of type xsd:string */
};
typedef struct ds__TransformType ds__TransformType;
#endif

#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (86)
/* ds:KeyInfoType */
struct ds__KeyInfoType
{
public:
	char *KeyName;	/* optional element of type xsd:string */
	struct ds__KeyValueType *KeyValue;	/* optional element of type ds:KeyValueType */
	struct ds__RetrievalMethodType *RetrievalMethod;	/* optional element of type ds:RetrievalMethodType */
	struct ds__X509DataType *X509Data;	/* optional element of type ds:X509DataType */
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of type wsse:SecurityTokenReference */
	char *Id;	/* optional attribute of type xsd:string */
};
typedef struct ds__KeyInfoType ds__KeyInfoType;
#endif

#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (84)
/* ds:SignedInfoType */
struct ds__SignedInfoType
{
public:
	struct ds__CanonicalizationMethodType *CanonicalizationMethod;	/* required element of type ds:CanonicalizationMethodType */
	struct ds__SignatureMethodType *SignatureMethod;	/* required element of type ds:SignatureMethodType */
	int __sizeReference;	/* sequence of elements <Reference> */
	struct ds__ReferenceType **Reference;	/* required element of type ds:ReferenceType */
	char *Id;	/* optional attribute of type xsd:string */
};
typedef struct ds__SignedInfoType ds__SignedInfoType;
#endif

#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (88)
/* ds:CanonicalizationMethodType */
struct ds__CanonicalizationMethodType
{
public:
	char *Algorithm;	/* required attribute of type xsd:string */
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of type c14n:InclusiveNamespaces */
};
typedef struct ds__CanonicalizationMethodType ds__CanonicalizationMethodType;
#endif

#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (89)
/* ds:SignatureMethodType */
struct ds__SignatureMethodType
{
public:
	int *HMACOutputLength;	/* optional element of type xsd:int */
	char *Algorithm;	/* required attribute of type xsd:string */
};
typedef struct ds__SignatureMethodType ds__SignatureMethodType;
#endif

#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (90)
/* ds:ReferenceType */
struct ds__ReferenceType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of type ds:TransformsType */
	struct ds__DigestMethodType *DigestMethod;	/* required element of type ds:DigestMethodType */
	char *DigestValue;	/* required element of type xsd:string */
	char *Id;	/* optional attribute of type xsd:string */
	char *URI;	/* optional attribute of type xsd:string */
	char *Type;	/* optional attribute of type xsd:string */
};
typedef struct ds__ReferenceType ds__ReferenceType;
#endif

#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (91)
/* ds:TransformsType */
struct ds__TransformsType
{
public:
	int __sizeTransform;	/* sequence of elements <Transform> */
	struct ds__TransformType *Transform;	/* required element of type ds:TransformType */
};
typedef struct ds__TransformsType ds__TransformsType;
#endif

#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (95)
/* ds:DigestMethodType */
struct ds__DigestMethodType
{
public:
	char *Algorithm;	/* required attribute of type xsd:string */
};
typedef struct ds__DigestMethodType ds__DigestMethodType;
#endif

#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (96)
/* ds:KeyValueType */
struct ds__KeyValueType
{
public:
	struct ds__DSAKeyValueType *DSAKeyValue;	/* required element of type ds:DSAKeyValueType */
	struct ds__RSAKeyValueType *RSAKeyValue;	/* required element of type ds:RSAKeyValueType */
};
typedef struct ds__KeyValueType ds__KeyValueType;
#endif

#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (98)
/* ds:RetrievalMethodType */
struct ds__RetrievalMethodType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of type ds:TransformsType */
	char *URI;	/* optional attribute of type xsd:string */
	char *Type;	/* optional attribute of type xsd:string */
};
typedef struct ds__RetrievalMethodType ds__RetrievalMethodType;
#endif

#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (100)
/* ds:X509DataType */
struct ds__X509DataType
{
public:
	struct ds__X509IssuerSerialType *X509IssuerSerial;	/* required element of type ds:X509IssuerSerialType */
	char *X509SKI;	/* required element of type xsd:string */
	char *X509SubjectName;	/* required element of type xsd:string */
	char *X509Certificate;	/* required element of type xsd:string */
	char *X509CRL;	/* required element of type xsd:string */
};
typedef struct ds__X509DataType ds__X509DataType;
#endif

#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (103)
/* ds:X509IssuerSerialType */
struct ds__X509IssuerSerialType
{
public:
	char *X509IssuerName;	/* required element of type xsd:string */
	int X509SerialNumber;	/* required element of type xsd:int */
};
typedef struct ds__X509IssuerSerialType ds__X509IssuerSerialType;
#endif

#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (104)
/* ds:DSAKeyValueType */
struct ds__DSAKeyValueType
{
public:
	char *G;	/* optional element of type xsd:string */
	char *Y;	/* required element of type xsd:string */
	char *J;	/* optional element of type xsd:string */
	char *P;	/* required element of type xsd:string */
	char *Q;	/* required element of type xsd:string */
	char *Seed;	/* required element of type xsd:string */
	char *PgenCounter;	/* required element of type xsd:string */
};
typedef struct ds__DSAKeyValueType ds__DSAKeyValueType;
#endif

#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (105)
/* ds:RSAKeyValueType */
struct ds__RSAKeyValueType
{
public:
	char *Modulus;	/* required element of type xsd:string */
	char *Exponent;	/* required element of type xsd:string */
};
typedef struct ds__RSAKeyValueType ds__RSAKeyValueType;
#endif

#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (117)
/* wsse:Security */
struct _wsse__Security
{
public:
	struct _wsu__Timestamp *wsu__Timestamp;	/* optional element of type wsu:Timestamp */
	struct _wsse__UsernameToken *UsernameToken;	/* optional element of type wsse:UsernameToken */
	struct _wsse__BinarySecurityToken *BinarySecurityToken;	/* optional element of type wsse:BinarySecurityToken */
	struct ds__SignatureType *ds__Signature;	/* optional element of type ds:SignatureType */
	char *SOAP_ENV__actor;	/* optional attribute of type xsd:string */
	char *SOAP_ENV__role;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__Security _wsse__Security;
#endif

#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (73)
/* Primitive wsse:Password schema type: */
struct _wsse__Password
{
public:
	char *__item;
	char *Type;	/* optional attribute of type xsd:string */
};
typedef struct _wsse__Password _wsse__Password;
#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (123)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyType(): __item(NULL), soap(NULL) { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (127)
/* Primitive xsd:ID schema type: */
class SOAP_CMAC xsd__ID_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE_xsd__ID_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__ID_() { xsd__ID_::soap_default(NULL); }
	virtual ~xsd__ID_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__IDREFS_
#define SOAP_TYPE_xsd__IDREFS_ (129)
/* Primitive xsd:IDREFS schema type: */
class SOAP_CMAC xsd__IDREFS_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE_xsd__IDREFS_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__IDREFS_() { xsd__IDREFS_::soap_default(NULL); }
	virtual ~xsd__IDREFS_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__NCName_
#define SOAP_TYPE_xsd__NCName_ (131)
/* Primitive xsd:NCName schema type: */
class SOAP_CMAC xsd__NCName_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE_xsd__NCName_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__NCName_() { xsd__NCName_::soap_default(NULL); }
	virtual ~xsd__NCName_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (133)
/* Primitive xsd:QName schema type: */
class SOAP_CMAC xsd__QName_ : public xsd__anyType
{
public:
	xsd__QName __item;
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE_xsd__QName_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__QName_() { xsd__QName_::soap_default(NULL); }
	virtual ~xsd__QName_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType_
#define SOAP_TYPE_xsd__anySimpleType_ (135)
/* Primitive xsd:anySimpleType schema type: */
class SOAP_CMAC xsd__anySimpleType_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE_xsd__anySimpleType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anySimpleType_() { xsd__anySimpleType_::soap_default(NULL); }
	virtual ~xsd__anySimpleType_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (137)
/* Primitive xsd:anyURI schema type: */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE_xsd__anyURI_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyURI_() { xsd__anyURI_::soap_default(NULL); }
	virtual ~xsd__anyURI_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (138)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary(): __ptr(NULL), id(NULL), type(NULL), options(NULL), soap(NULL) { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (139)
/* Primitive xsd:base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType
{
public:
	xsd__base64Binary __item;
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE_xsd__base64Binary_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary_() { xsd__base64Binary_::soap_default(NULL); }
	virtual ~xsd__base64Binary_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (140)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (142)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE_xsd__dateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (148)
/* Primitive xsd:duration schema type: */
class SOAP_CMAC xsd__duration_ : public xsd__anyType
{
public:
	LONG64 __item;	/* external */
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE_xsd__duration_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__duration_() { xsd__duration_::soap_default(NULL); }
	virtual ~xsd__duration_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (149)
/* Primitive xsd:float schema type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
	float __item;
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE_xsd__float */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__float() { xsd__float::soap_default(NULL); }
	virtual ~xsd__float() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (151)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (153)
/* Primitive xsd:integer schema type: */
class SOAP_CMAC xsd__integer_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 153; } /* = unique id SOAP_TYPE_xsd__integer_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__integer_() { xsd__integer_::soap_default(NULL); }
	virtual ~xsd__integer_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger_
#define SOAP_TYPE_xsd__nonNegativeInteger_ (155)
/* Primitive xsd:nonNegativeInteger schema type: */
class SOAP_CMAC xsd__nonNegativeInteger_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE_xsd__nonNegativeInteger_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__nonNegativeInteger_() { xsd__nonNegativeInteger_::soap_default(NULL); }
	virtual ~xsd__nonNegativeInteger_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (156)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 156; } /* = unique id SOAP_TYPE_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_xsd__token_
#define SOAP_TYPE_xsd__token_ (158)
/* Primitive xsd:token schema type: */
class SOAP_CMAC xsd__token_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE_xsd__token_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__token_() { xsd__token_::soap_default(NULL); }
	virtual ~xsd__token_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (159)
/* Primitive xsd:unsignedInt schema type: */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType
{
public:
	unsigned int __item;
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE_xsd__unsignedInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__unsignedInt() { xsd__unsignedInt::soap_default(NULL); }
	virtual ~xsd__unsignedInt() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (783)
/* Primitive tt:ReferenceToken schema type: */
class SOAP_CMAC tt__ReferenceToken__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 783; } /* = unique id SOAP_TYPE_tt__ReferenceToken__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReferenceToken__() { tt__ReferenceToken__::soap_default(NULL); }
	virtual ~tt__ReferenceToken__() { }
};
#endif

#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (785)
/* Primitive tt:Name schema type: */
class SOAP_CMAC tt__Name__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 785; } /* = unique id SOAP_TYPE_tt__Name__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Name__() { tt__Name__::soap_default(NULL); }
	virtual ~tt__Name__() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (787)
/* Primitive tt:VideoEncoding schema type: */
class SOAP_CMAC tt__VideoEncoding_ : public xsd__anyType
{
public:
	enum tt__VideoEncoding __item;
public:
	virtual int soap_type() const { return 787; } /* = unique id SOAP_TYPE_tt__VideoEncoding_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoding_() { tt__VideoEncoding_::soap_default(NULL); }
	virtual ~tt__VideoEncoding_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (789)
/* Primitive tt:Mpeg4Profile schema type: */
class SOAP_CMAC tt__Mpeg4Profile_ : public xsd__anyType
{
public:
	enum tt__Mpeg4Profile __item;
public:
	virtual int soap_type() const { return 789; } /* = unique id SOAP_TYPE_tt__Mpeg4Profile_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Profile_() { tt__Mpeg4Profile_::soap_default(NULL); }
	virtual ~tt__Mpeg4Profile_() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (791)
/* Primitive tt:H264Profile schema type: */
class SOAP_CMAC tt__H264Profile_ : public xsd__anyType
{
public:
	enum tt__H264Profile __item;
public:
	virtual int soap_type() const { return 791; } /* = unique id SOAP_TYPE_tt__H264Profile_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Profile_() { tt__H264Profile_::soap_default(NULL); }
	virtual ~tt__H264Profile_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (793)
/* Primitive tt:AudioEncoding schema type: */
class SOAP_CMAC tt__AudioEncoding_ : public xsd__anyType
{
public:
	enum tt__AudioEncoding __item;
public:
	virtual int soap_type() const { return 793; } /* = unique id SOAP_TYPE_tt__AudioEncoding_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoding_() { tt__AudioEncoding_::soap_default(NULL); }
	virtual ~tt__AudioEncoding_() { }
};
#endif

#ifndef SOAP_TYPE_tt__StreamType_
#define SOAP_TYPE_tt__StreamType_ (795)
/* Primitive tt:StreamType schema type: */
class SOAP_CMAC tt__StreamType_ : public xsd__anyType
{
public:
	enum tt__StreamType __item;
public:
	virtual int soap_type() const { return 795; } /* = unique id SOAP_TYPE_tt__StreamType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StreamType_() { tt__StreamType_::soap_default(NULL); }
	virtual ~tt__StreamType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__TransportProtocol_
#define SOAP_TYPE_tt__TransportProtocol_ (797)
/* Primitive tt:TransportProtocol schema type: */
class SOAP_CMAC tt__TransportProtocol_ : public xsd__anyType
{
public:
	enum tt__TransportProtocol __item;
public:
	virtual int soap_type() const { return 797; } /* = unique id SOAP_TYPE_tt__TransportProtocol_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TransportProtocol_() { tt__TransportProtocol_::soap_default(NULL); }
	virtual ~tt__TransportProtocol_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ScopeDefinition_
#define SOAP_TYPE_tt__ScopeDefinition_ (799)
/* Primitive tt:ScopeDefinition schema type: */
class SOAP_CMAC tt__ScopeDefinition_ : public xsd__anyType
{
public:
	enum tt__ScopeDefinition __item;
public:
	virtual int soap_type() const { return 799; } /* = unique id SOAP_TYPE_tt__ScopeDefinition_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ScopeDefinition_() { tt__ScopeDefinition_::soap_default(NULL); }
	virtual ~tt__ScopeDefinition_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DiscoveryMode_
#define SOAP_TYPE_tt__DiscoveryMode_ (801)
/* Primitive tt:DiscoveryMode schema type: */
class SOAP_CMAC tt__DiscoveryMode_ : public xsd__anyType
{
public:
	enum tt__DiscoveryMode __item;
public:
	virtual int soap_type() const { return 801; } /* = unique id SOAP_TYPE_tt__DiscoveryMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DiscoveryMode_() { tt__DiscoveryMode_::soap_default(NULL); }
	virtual ~tt__DiscoveryMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Duplex_
#define SOAP_TYPE_tt__Duplex_ (803)
/* Primitive tt:Duplex schema type: */
class SOAP_CMAC tt__Duplex_ : public xsd__anyType
{
public:
	enum tt__Duplex __item;
public:
	virtual int soap_type() const { return 803; } /* = unique id SOAP_TYPE_tt__Duplex_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Duplex_() { tt__Duplex_::soap_default(NULL); }
	virtual ~tt__Duplex_() { }
};
#endif

#ifndef SOAP_TYPE_tt__IANA_IfTypes__
#define SOAP_TYPE_tt__IANA_IfTypes__ (805)
/* Primitive tt:IANA-IfTypes schema type: */
class SOAP_CMAC tt__IANA_IfTypes__ : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 805; } /* = unique id SOAP_TYPE_tt__IANA_IfTypes__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IANA_IfTypes__() { tt__IANA_IfTypes__::soap_default(NULL); }
	virtual ~tt__IANA_IfTypes__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration_
#define SOAP_TYPE_tt__IPv6DHCPConfiguration_ (807)
/* Primitive tt:IPv6DHCPConfiguration schema type: */
class SOAP_CMAC tt__IPv6DHCPConfiguration_ : public xsd__anyType
{
public:
	enum tt__IPv6DHCPConfiguration __item;
public:
	virtual int soap_type() const { return 807; } /* = unique id SOAP_TYPE_tt__IPv6DHCPConfiguration_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6DHCPConfiguration_() { tt__IPv6DHCPConfiguration_::soap_default(NULL); }
	virtual ~tt__IPv6DHCPConfiguration_() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolType_
#define SOAP_TYPE_tt__NetworkProtocolType_ (809)
/* Primitive tt:NetworkProtocolType schema type: */
class SOAP_CMAC tt__NetworkProtocolType_ : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType __item;
public:
	virtual int soap_type() const { return 809; } /* = unique id SOAP_TYPE_tt__NetworkProtocolType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocolType_() { tt__NetworkProtocolType_::soap_default(NULL); }
	virtual ~tt__NetworkProtocolType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHostType_
#define SOAP_TYPE_tt__NetworkHostType_ (811)
/* Primitive tt:NetworkHostType schema type: */
class SOAP_CMAC tt__NetworkHostType_ : public xsd__anyType
{
public:
	enum tt__NetworkHostType __item;
public:
	virtual int soap_type() const { return 811; } /* = unique id SOAP_TYPE_tt__NetworkHostType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHostType_() { tt__NetworkHostType_::soap_default(NULL); }
	virtual ~tt__NetworkHostType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (813)
/* Primitive tt:IPv4Address schema type: */
class SOAP_CMAC tt__IPv4Address__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 813; } /* = unique id SOAP_TYPE_tt__IPv4Address__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4Address__() { tt__IPv4Address__::soap_default(NULL); }
	virtual ~tt__IPv4Address__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (815)
/* Primitive tt:IPv6Address schema type: */
class SOAP_CMAC tt__IPv6Address__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 815; } /* = unique id SOAP_TYPE_tt__IPv6Address__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6Address__() { tt__IPv6Address__::soap_default(NULL); }
	virtual ~tt__IPv6Address__() { }
};
#endif

#ifndef SOAP_TYPE_tt__HwAddress__
#define SOAP_TYPE_tt__HwAddress__ (817)
/* Primitive tt:HwAddress schema type: */
class SOAP_CMAC tt__HwAddress__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 817; } /* = unique id SOAP_TYPE_tt__HwAddress__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HwAddress__() { tt__HwAddress__::soap_default(NULL); }
	virtual ~tt__HwAddress__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (819)
/* Primitive tt:IPType schema type: */
class SOAP_CMAC tt__IPType_ : public xsd__anyType
{
public:
	enum tt__IPType __item;
public:
	virtual int soap_type() const { return 819; } /* = unique id SOAP_TYPE_tt__IPType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPType_() { tt__IPType_::soap_default(NULL); }
	virtual ~tt__IPType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSName__
#define SOAP_TYPE_tt__DNSName__ (821)
/* Primitive tt:DNSName schema type: */
class SOAP_CMAC tt__DNSName__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 821; } /* = unique id SOAP_TYPE_tt__DNSName__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSName__() { tt__DNSName__::soap_default(NULL); }
	virtual ~tt__DNSName__() { }
};
#endif

#ifndef SOAP_TYPE_tt__Domain__
#define SOAP_TYPE_tt__Domain__ (823)
/* Primitive tt:Domain schema type: */
class SOAP_CMAC tt__Domain__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 823; } /* = unique id SOAP_TYPE_tt__Domain__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Domain__() { tt__Domain__::soap_default(NULL); }
	virtual ~tt__Domain__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterType_
#define SOAP_TYPE_tt__IPAddressFilterType_ (825)
/* Primitive tt:IPAddressFilterType schema type: */
class SOAP_CMAC tt__IPAddressFilterType_ : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType __item;
public:
	virtual int soap_type() const { return 825; } /* = unique id SOAP_TYPE_tt__IPAddressFilterType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilterType_() { tt__IPAddressFilterType_::soap_default(NULL); }
	virtual ~tt__IPAddressFilterType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSType_
#define SOAP_TYPE_tt__DynamicDNSType_ (827)
/* Primitive tt:DynamicDNSType schema type: */
class SOAP_CMAC tt__DynamicDNSType_ : public xsd__anyType
{
public:
	enum tt__DynamicDNSType __item;
public:
	virtual int soap_type() const { return 827; } /* = unique id SOAP_TYPE_tt__DynamicDNSType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSType_() { tt__DynamicDNSType_::soap_default(NULL); }
	virtual ~tt__DynamicDNSType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__CapabilityCategory_
#define SOAP_TYPE_tt__CapabilityCategory_ (829)
/* Primitive tt:CapabilityCategory schema type: */
class SOAP_CMAC tt__CapabilityCategory_ : public xsd__anyType
{
public:
	enum tt__CapabilityCategory __item;
public:
	virtual int soap_type() const { return 829; } /* = unique id SOAP_TYPE_tt__CapabilityCategory_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CapabilityCategory_() { tt__CapabilityCategory_::soap_default(NULL); }
	virtual ~tt__CapabilityCategory_() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLogType_
#define SOAP_TYPE_tt__SystemLogType_ (831)
/* Primitive tt:SystemLogType schema type: */
class SOAP_CMAC tt__SystemLogType_ : public xsd__anyType
{
public:
	enum tt__SystemLogType __item;
public:
	virtual int soap_type() const { return 831; } /* = unique id SOAP_TYPE_tt__SystemLogType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLogType_() { tt__SystemLogType_::soap_default(NULL); }
	virtual ~tt__SystemLogType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__FactoryDefaultType_
#define SOAP_TYPE_tt__FactoryDefaultType_ (833)
/* Primitive tt:FactoryDefaultType schema type: */
class SOAP_CMAC tt__FactoryDefaultType_ : public xsd__anyType
{
public:
	enum tt__FactoryDefaultType __item;
public:
	virtual int soap_type() const { return 833; } /* = unique id SOAP_TYPE_tt__FactoryDefaultType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FactoryDefaultType_() { tt__FactoryDefaultType_::soap_default(NULL); }
	virtual ~tt__FactoryDefaultType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__SetDateTimeType_
#define SOAP_TYPE_tt__SetDateTimeType_ (835)
/* Primitive tt:SetDateTimeType schema type: */
class SOAP_CMAC tt__SetDateTimeType_ : public xsd__anyType
{
public:
	enum tt__SetDateTimeType __item;
public:
	virtual int soap_type() const { return 835; } /* = unique id SOAP_TYPE_tt__SetDateTimeType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SetDateTimeType_() { tt__SetDateTimeType_::soap_default(NULL); }
	virtual ~tt__SetDateTimeType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__UserLevel_
#define SOAP_TYPE_tt__UserLevel_ (837)
/* Primitive tt:UserLevel schema type: */
class SOAP_CMAC tt__UserLevel_ : public xsd__anyType
{
public:
	enum tt__UserLevel __item;
public:
	virtual int soap_type() const { return 837; } /* = unique id SOAP_TYPE_tt__UserLevel_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__UserLevel_() { tt__UserLevel_::soap_default(NULL); }
	virtual ~tt__UserLevel_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayLogicalState_
#define SOAP_TYPE_tt__RelayLogicalState_ (839)
/* Primitive tt:RelayLogicalState schema type: */
class SOAP_CMAC tt__RelayLogicalState_ : public xsd__anyType
{
public:
	enum tt__RelayLogicalState __item;
public:
	virtual int soap_type() const { return 839; } /* = unique id SOAP_TYPE_tt__RelayLogicalState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayLogicalState_() { tt__RelayLogicalState_::soap_default(NULL); }
	virtual ~tt__RelayLogicalState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayIdleState_
#define SOAP_TYPE_tt__RelayIdleState_ (841)
/* Primitive tt:RelayIdleState schema type: */
class SOAP_CMAC tt__RelayIdleState_ : public xsd__anyType
{
public:
	enum tt__RelayIdleState __item;
public:
	virtual int soap_type() const { return 841; } /* = unique id SOAP_TYPE_tt__RelayIdleState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayIdleState_() { tt__RelayIdleState_::soap_default(NULL); }
	virtual ~tt__RelayIdleState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayMode_
#define SOAP_TYPE_tt__RelayMode_ (843)
/* Primitive tt:RelayMode schema type: */
class SOAP_CMAC tt__RelayMode_ : public xsd__anyType
{
public:
	enum tt__RelayMode __item;
public:
	virtual int soap_type() const { return 843; } /* = unique id SOAP_TYPE_tt__RelayMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayMode_() { tt__RelayMode_::soap_default(NULL); }
	virtual ~tt__RelayMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AuxiliaryData__
#define SOAP_TYPE_tt__AuxiliaryData__ (845)
/* Primitive tt:AuxiliaryData schema type: */
class SOAP_CMAC tt__AuxiliaryData__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 845; } /* = unique id SOAP_TYPE_tt__AuxiliaryData__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AuxiliaryData__() { tt__AuxiliaryData__::soap_default(NULL); }
	virtual ~tt__AuxiliaryData__() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (847)
/* Primitive tt:MoveStatus schema type: */
class SOAP_CMAC tt__MoveStatus_ : public xsd__anyType
{
public:
	enum tt__MoveStatus __item;
public:
	virtual int soap_type() const { return 847; } /* = unique id SOAP_TYPE_tt__MoveStatus_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveStatus_() { tt__MoveStatus_::soap_default(NULL); }
	virtual ~tt__MoveStatus_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (849)
/* Primitive tt:AutoFocusMode schema type: */
class SOAP_CMAC tt__AutoFocusMode_ : public xsd__anyType
{
public:
	enum tt__AutoFocusMode __item;
public:
	virtual int soap_type() const { return 849; } /* = unique id SOAP_TYPE_tt__AutoFocusMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AutoFocusMode_() { tt__AutoFocusMode_::soap_default(NULL); }
	virtual ~tt__AutoFocusMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (851)
/* Primitive tt:WideDynamicMode schema type: */
class SOAP_CMAC tt__WideDynamicMode_ : public xsd__anyType
{
public:
	enum tt__WideDynamicMode __item;
public:
	virtual int soap_type() const { return 851; } /* = unique id SOAP_TYPE_tt__WideDynamicMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicMode_() { tt__WideDynamicMode_::soap_default(NULL); }
	virtual ~tt__WideDynamicMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (853)
/* Primitive tt:BacklightCompensationMode schema type: */
class SOAP_CMAC tt__BacklightCompensationMode_ : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode __item;
public:
	virtual int soap_type() const { return 853; } /* = unique id SOAP_TYPE_tt__BacklightCompensationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationMode_() { tt__BacklightCompensationMode_::soap_default(NULL); }
	virtual ~tt__BacklightCompensationMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (855)
/* Primitive tt:ExposurePriority schema type: */
class SOAP_CMAC tt__ExposurePriority_ : public xsd__anyType
{
public:
	enum tt__ExposurePriority __item;
public:
	virtual int soap_type() const { return 855; } /* = unique id SOAP_TYPE_tt__ExposurePriority_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposurePriority_() { tt__ExposurePriority_::soap_default(NULL); }
	virtual ~tt__ExposurePriority_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (857)
/* Primitive tt:ExposureMode schema type: */
class SOAP_CMAC tt__ExposureMode_ : public xsd__anyType
{
public:
	enum tt__ExposureMode __item;
public:
	virtual int soap_type() const { return 857; } /* = unique id SOAP_TYPE_tt__ExposureMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureMode_() { tt__ExposureMode_::soap_default(NULL); }
	virtual ~tt__ExposureMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Enabled_
#define SOAP_TYPE_tt__Enabled_ (859)
/* Primitive tt:Enabled schema type: */
class SOAP_CMAC tt__Enabled_ : public xsd__anyType
{
public:
	enum tt__Enabled __item;
public:
	virtual int soap_type() const { return 859; } /* = unique id SOAP_TYPE_tt__Enabled_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Enabled_() { tt__Enabled_::soap_default(NULL); }
	virtual ~tt__Enabled_() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (861)
/* Primitive tt:WhiteBalanceMode schema type: */
class SOAP_CMAC tt__WhiteBalanceMode_ : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode __item;
public:
	virtual int soap_type() const { return 861; } /* = unique id SOAP_TYPE_tt__WhiteBalanceMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceMode_() { tt__WhiteBalanceMode_::soap_default(NULL); }
	virtual ~tt__WhiteBalanceMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (863)
/* Primitive tt:IrCutFilterMode schema type: */
class SOAP_CMAC tt__IrCutFilterMode_ : public xsd__anyType
{
public:
	enum tt__IrCutFilterMode __item;
public:
	virtual int soap_type() const { return 863; } /* = unique id SOAP_TYPE_tt__IrCutFilterMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IrCutFilterMode_() { tt__IrCutFilterMode_::soap_default(NULL); }
	virtual ~tt__IrCutFilterMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__TopicNamespaceLocation__
#define SOAP_TYPE_tt__TopicNamespaceLocation__ (865)
/* Primitive tt:TopicNamespaceLocation schema type: */
class SOAP_CMAC tt__TopicNamespaceLocation__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 865; } /* = unique id SOAP_TYPE_tt__TopicNamespaceLocation__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TopicNamespaceLocation__() { tt__TopicNamespaceLocation__::soap_default(NULL); }
	virtual ~tt__TopicNamespaceLocation__() { }
};
#endif

#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (867)
/* Primitive tt:PropertyOperation schema type: */
class SOAP_CMAC tt__PropertyOperation_ : public xsd__anyType
{
public:
	enum tt__PropertyOperation __item;
public:
	virtual int soap_type() const { return 867; } /* = unique id SOAP_TYPE_tt__PropertyOperation_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PropertyOperation_() { tt__PropertyOperation_::soap_default(NULL); }
	virtual ~tt__PropertyOperation_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Direction_
#define SOAP_TYPE_tt__Direction_ (869)
/* Primitive tt:Direction schema type: */
class SOAP_CMAC tt__Direction_ : public xsd__anyType
{
public:
	enum tt__Direction __item;
public:
	virtual int soap_type() const { return 869; } /* = unique id SOAP_TYPE_tt__Direction_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Direction_() { tt__Direction_::soap_default(NULL); }
	virtual ~tt__Direction_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ClassType_
#define SOAP_TYPE_tt__ClassType_ (871)
/* Primitive tt:ClassType schema type: */
class SOAP_CMAC tt__ClassType_ : public xsd__anyType
{
public:
	enum tt__ClassType __item;
public:
	virtual int soap_type() const { return 871; } /* = unique id SOAP_TYPE_tt__ClassType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ClassType_() { tt__ClassType_::soap_default(NULL); }
	virtual ~tt__ClassType_() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FullTopicExpression__
#define SOAP_TYPE_ns3__FullTopicExpression__ (873)
/* Primitive ns3:FullTopicExpression schema type: */
class SOAP_CMAC ns3__FullTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 873; } /* = unique id SOAP_TYPE_ns3__FullTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FullTopicExpression__() { ns3__FullTopicExpression__::soap_default(NULL); }
	virtual ~ns3__FullTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ConcreteTopicExpression__
#define SOAP_TYPE_ns3__ConcreteTopicExpression__ (875)
/* Primitive ns3:ConcreteTopicExpression schema type: */
class SOAP_CMAC ns3__ConcreteTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 875; } /* = unique id SOAP_TYPE_ns3__ConcreteTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ConcreteTopicExpression__() { ns3__ConcreteTopicExpression__::soap_default(NULL); }
	virtual ~ns3__ConcreteTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SimpleTopicExpression__
#define SOAP_TYPE_ns3__SimpleTopicExpression__ (877)
/* Primitive ns3:SimpleTopicExpression schema type: */
class SOAP_CMAC ns3__SimpleTopicExpression__ : public xsd__anyType
{
public:
	xsd__QName __item;
public:
	virtual int soap_type() const { return 877; } /* = unique id SOAP_TYPE_ns3__SimpleTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SimpleTopicExpression__() { ns3__SimpleTopicExpression__::soap_default(NULL); }
	virtual ~ns3__SimpleTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns6__RelationshipType_
#define SOAP_TYPE_ns6__RelationshipType_ (879)
/* Primitive ns6:RelationshipType schema type: */
class SOAP_CMAC ns6__RelationshipType_ : public xsd__anyType
{
public:
	enum ns6__RelationshipType __item;
public:
	virtual int soap_type() const { return 879; } /* = unique id SOAP_TYPE_ns6__RelationshipType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__RelationshipType_() { ns6__RelationshipType_::soap_default(NULL); }
	virtual ~ns6__RelationshipType_() { }
};
#endif

#ifndef SOAP_TYPE_ns6__FaultCodeType_
#define SOAP_TYPE_ns6__FaultCodeType_ (881)
/* Primitive ns6:FaultCodeType schema type: */
class SOAP_CMAC ns6__FaultCodeType_ : public xsd__anyType
{
public:
	enum ns6__FaultCodeType __item;
public:
	virtual int soap_type() const { return 881; } /* = unique id SOAP_TYPE_ns6__FaultCodeType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__FaultCodeType_() { ns6__FaultCodeType_::soap_default(NULL); }
	virtual ~ns6__FaultCodeType_() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetSupportedRules
#define SOAP_TYPE__tan__GetSupportedRules (161)
/* tan:GetSupportedRules */
class SOAP_CMAC _tan__GetSupportedRules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE__tan__GetSupportedRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetSupportedRules(): soap(NULL) { _tan__GetSupportedRules::soap_default(NULL); }
	virtual ~_tan__GetSupportedRules() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetSupportedRulesResponse
#define SOAP_TYPE__tan__GetSupportedRulesResponse (162)
/* tan:GetSupportedRulesResponse */
class SOAP_CMAC _tan__GetSupportedRulesResponse
{
public:
	class tt__SupportedRules *SupportedRules;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:SupportedRules */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 162; } /* = unique id SOAP_TYPE__tan__GetSupportedRulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetSupportedRulesResponse(): SupportedRules(NULL), soap(NULL) { _tan__GetSupportedRulesResponse::soap_default(NULL); }
	virtual ~_tan__GetSupportedRulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__CreateRules
#define SOAP_TYPE__tan__CreateRules (163)
/* tan:CreateRules */
class SOAP_CMAC _tan__CreateRules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	std::vector<class tt__Config * >Rule;	/* required element of type tt:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE__tan__CreateRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__CreateRules(): soap(NULL) { _tan__CreateRules::soap_default(NULL); }
	virtual ~_tan__CreateRules() { }
};
#endif

#ifndef SOAP_TYPE__tan__CreateRulesResponse
#define SOAP_TYPE__tan__CreateRulesResponse (164)
/* tan:CreateRulesResponse */
class SOAP_CMAC _tan__CreateRulesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE__tan__CreateRulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__CreateRulesResponse(): soap(NULL) { _tan__CreateRulesResponse::soap_default(NULL); }
	virtual ~_tan__CreateRulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__DeleteRules
#define SOAP_TYPE__tan__DeleteRules (165)
/* tan:DeleteRules */
class SOAP_CMAC _tan__DeleteRules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	std::vector<std::string >RuleName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 165; } /* = unique id SOAP_TYPE__tan__DeleteRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__DeleteRules(): soap(NULL) { _tan__DeleteRules::soap_default(NULL); }
	virtual ~_tan__DeleteRules() { }
};
#endif

#ifndef SOAP_TYPE__tan__DeleteRulesResponse
#define SOAP_TYPE__tan__DeleteRulesResponse (166)
/* tan:DeleteRulesResponse */
class SOAP_CMAC _tan__DeleteRulesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique id SOAP_TYPE__tan__DeleteRulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__DeleteRulesResponse(): soap(NULL) { _tan__DeleteRulesResponse::soap_default(NULL); }
	virtual ~_tan__DeleteRulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__ModifyRules
#define SOAP_TYPE__tan__ModifyRules (167)
/* tan:ModifyRules */
class SOAP_CMAC _tan__ModifyRules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	std::vector<tt__Config * >Rule;	/* required element of type tt:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE__tan__ModifyRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__ModifyRules(): soap(NULL) { _tan__ModifyRules::soap_default(NULL); }
	virtual ~_tan__ModifyRules() { }
};
#endif

#ifndef SOAP_TYPE__tan__ModifyRulesResponse
#define SOAP_TYPE__tan__ModifyRulesResponse (168)
/* tan:ModifyRulesResponse */
class SOAP_CMAC _tan__ModifyRulesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE__tan__ModifyRulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__ModifyRulesResponse(): soap(NULL) { _tan__ModifyRulesResponse::soap_default(NULL); }
	virtual ~_tan__ModifyRulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetRules
#define SOAP_TYPE__tan__GetRules (169)
/* tan:GetRules */
class SOAP_CMAC _tan__GetRules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE__tan__GetRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetRules(): soap(NULL) { _tan__GetRules::soap_default(NULL); }
	virtual ~_tan__GetRules() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetRulesResponse
#define SOAP_TYPE__tan__GetRulesResponse (170)
/* tan:GetRulesResponse */
class SOAP_CMAC _tan__GetRulesResponse
{
public:
	std::vector<tt__Config * >Rule;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE__tan__GetRulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetRulesResponse(): soap(NULL) { _tan__GetRulesResponse::soap_default(NULL); }
	virtual ~_tan__GetRulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetSupportedAnalyticsModules
#define SOAP_TYPE__tan__GetSupportedAnalyticsModules (171)
/* tan:GetSupportedAnalyticsModules */
class SOAP_CMAC _tan__GetSupportedAnalyticsModules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique id SOAP_TYPE__tan__GetSupportedAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetSupportedAnalyticsModules(): soap(NULL) { _tan__GetSupportedAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__GetSupportedAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse
#define SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse (172)
/* tan:GetSupportedAnalyticsModulesResponse */
class SOAP_CMAC _tan__GetSupportedAnalyticsModulesResponse
{
public:
	class tt__SupportedAnalyticsModules *SupportedAnalyticsModules;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:SupportedAnalyticsModules */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetSupportedAnalyticsModulesResponse(): SupportedAnalyticsModules(NULL), soap(NULL) { _tan__GetSupportedAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__GetSupportedAnalyticsModulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__CreateAnalyticsModules
#define SOAP_TYPE__tan__CreateAnalyticsModules (173)
/* tan:CreateAnalyticsModules */
class SOAP_CMAC _tan__CreateAnalyticsModules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	std::vector<tt__Config * >AnalyticsModule;	/* required element of type tt:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique id SOAP_TYPE__tan__CreateAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__CreateAnalyticsModules(): soap(NULL) { _tan__CreateAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__CreateAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE__tan__CreateAnalyticsModulesResponse
#define SOAP_TYPE__tan__CreateAnalyticsModulesResponse (174)
/* tan:CreateAnalyticsModulesResponse */
class SOAP_CMAC _tan__CreateAnalyticsModulesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE__tan__CreateAnalyticsModulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__CreateAnalyticsModulesResponse(): soap(NULL) { _tan__CreateAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__CreateAnalyticsModulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__DeleteAnalyticsModules
#define SOAP_TYPE__tan__DeleteAnalyticsModules (175)
/* tan:DeleteAnalyticsModules */
class SOAP_CMAC _tan__DeleteAnalyticsModules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	std::vector<std::string >AnalyticsModuleName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE__tan__DeleteAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__DeleteAnalyticsModules(): soap(NULL) { _tan__DeleteAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__DeleteAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE__tan__DeleteAnalyticsModulesResponse
#define SOAP_TYPE__tan__DeleteAnalyticsModulesResponse (176)
/* tan:DeleteAnalyticsModulesResponse */
class SOAP_CMAC _tan__DeleteAnalyticsModulesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE__tan__DeleteAnalyticsModulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__DeleteAnalyticsModulesResponse(): soap(NULL) { _tan__DeleteAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__DeleteAnalyticsModulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__ModifyAnalyticsModules
#define SOAP_TYPE__tan__ModifyAnalyticsModules (177)
/* tan:ModifyAnalyticsModules */
class SOAP_CMAC _tan__ModifyAnalyticsModules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	std::vector<tt__Config * >AnalyticsModule;	/* required element of type tt:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique id SOAP_TYPE__tan__ModifyAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__ModifyAnalyticsModules(): soap(NULL) { _tan__ModifyAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__ModifyAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE__tan__ModifyAnalyticsModulesResponse
#define SOAP_TYPE__tan__ModifyAnalyticsModulesResponse (178)
/* tan:ModifyAnalyticsModulesResponse */
class SOAP_CMAC _tan__ModifyAnalyticsModulesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE__tan__ModifyAnalyticsModulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__ModifyAnalyticsModulesResponse(): soap(NULL) { _tan__ModifyAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__ModifyAnalyticsModulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetAnalyticsModules
#define SOAP_TYPE__tan__GetAnalyticsModules (179)
/* tan:GetAnalyticsModules */
class SOAP_CMAC _tan__GetAnalyticsModules
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE__tan__GetAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetAnalyticsModules(): soap(NULL) { _tan__GetAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__GetAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE__tan__GetAnalyticsModulesResponse
#define SOAP_TYPE__tan__GetAnalyticsModulesResponse (180)
/* tan:GetAnalyticsModulesResponse */
class SOAP_CMAC _tan__GetAnalyticsModulesResponse
{
public:
	std::vector<tt__Config * >AnalyticsModule;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique id SOAP_TYPE__tan__GetAnalyticsModulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tan__GetAnalyticsModulesResponse(): soap(NULL) { _tan__GetAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__GetAnalyticsModulesResponse() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (181)
/* Primitive tt:DeviceEntity schema type: */
class SOAP_CMAC tt__DeviceEntity : public xsd__anyType
{
public:
	std::string token;	/* required attribute */
public:
	virtual int soap_type() const { return 181; } /* = unique id SOAP_TYPE_tt__DeviceEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceEntity() { tt__DeviceEntity::soap_default(NULL); }
	virtual ~tt__DeviceEntity() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (182)
/* Primitive tt:IntRectangle schema type: */
class SOAP_CMAC tt__IntRectangle : public xsd__anyType
{
public:
	int x;	/* required attribute */
	int y;	/* required attribute */
	int width;	/* required attribute */
	int height;	/* required attribute */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE_tt__IntRectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRectangle() { tt__IntRectangle::soap_default(NULL); }
	virtual ~tt__IntRectangle() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (183)
/* tt:IntRectangleRange */
class SOAP_CMAC tt__IntRectangleRange : public xsd__anyType
{
public:
	class tt__IntRange *XRange;	/* required element of type tt:IntRange */
	tt__IntRange *YRange;	/* required element of type tt:IntRange */
	tt__IntRange *WidthRange;	/* required element of type tt:IntRange */
	tt__IntRange *HeightRange;	/* required element of type tt:IntRange */
public:
	virtual int soap_type() const { return 183; } /* = unique id SOAP_TYPE_tt__IntRectangleRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRectangleRange(): XRange(NULL), YRange(NULL), WidthRange(NULL), HeightRange(NULL) { tt__IntRectangleRange::soap_default(NULL); }
	virtual ~tt__IntRectangleRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (184)
/* tt:IntRange */
class SOAP_CMAC tt__IntRange : public xsd__anyType
{
public:
	int Min;	/* required element of type xsd:int */
	int Max;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 184; } /* = unique id SOAP_TYPE_tt__IntRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRange() { tt__IntRange::soap_default(NULL); }
	virtual ~tt__IntRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (185)
/* tt:FloatRange */
class SOAP_CMAC tt__FloatRange : public xsd__anyType
{
public:
	float Min;	/* required element of type xsd:float */
	float Max;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 185; } /* = unique id SOAP_TYPE_tt__FloatRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FloatRange() { tt__FloatRange::soap_default(NULL); }
	virtual ~tt__FloatRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (186)
/* tt:DurationRange */
class SOAP_CMAC tt__DurationRange : public xsd__anyType
{
public:
	LONG64 Min;	/* external */
	LONG64 Max;	/* external */
public:
	virtual int soap_type() const { return 186; } /* = unique id SOAP_TYPE_tt__DurationRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DurationRange() { tt__DurationRange::soap_default(NULL); }
	virtual ~tt__DurationRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (187)
/* tt:IntList */
class SOAP_CMAC tt__IntList : public xsd__anyType
{
public:
	std::vector<int >Items;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 187; } /* = unique id SOAP_TYPE_tt__IntList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntList() { tt__IntList::soap_default(NULL); }
	virtual ~tt__IntList() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (189)
/* tt:VideoSourceExtension */
class SOAP_CMAC tt__VideoSourceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 189; } /* = unique id SOAP_TYPE_tt__VideoSourceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceExtension() { tt__VideoSourceExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (191)
/* tt:Profile */
class SOAP_CMAC tt__Profile : public xsd__anyType
{
public:
	std::string Name;	/* required element of type tt:Name */
	class tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of type tt:VideoSourceConfiguration */
	class tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of type tt:AudioSourceConfiguration */
	class tt__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of type tt:VideoEncoderConfiguration */
	class tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of type tt:AudioEncoderConfiguration */
	class tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of type tt:VideoAnalyticsConfiguration */
	class tt__PTZConfiguration *PTZConfiguration;	/* optional element of type tt:PTZConfiguration */
	class tt__MetadataConfiguration *MetadataConfiguration;	/* optional element of type tt:MetadataConfiguration */
	class tt__ProfileExtension *Extension;	/* optional element of type tt:ProfileExtension */
	std::string token;	/* required attribute */
	bool *fixed;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 191; } /* = unique id SOAP_TYPE_tt__Profile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Profile(): VideoSourceConfiguration(NULL), AudioSourceConfiguration(NULL), VideoEncoderConfiguration(NULL), AudioEncoderConfiguration(NULL), VideoAnalyticsConfiguration(NULL), PTZConfiguration(NULL), MetadataConfiguration(NULL), Extension(NULL), fixed(NULL), __anyAttribute(NULL) { tt__Profile::soap_default(NULL); }
	virtual ~tt__Profile() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (192)
/* tt:ProfileExtension */
class SOAP_CMAC tt__ProfileExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 192; } /* = unique id SOAP_TYPE_tt__ProfileExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileExtension() { tt__ProfileExtension::soap_default(NULL); }
	virtual ~tt__ProfileExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (193)
/* tt:ConfigurationEntity */
class SOAP_CMAC tt__ConfigurationEntity : public xsd__anyType
{
public:
	std::string Name;	/* required element of type tt:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
public:
	virtual int soap_type() const { return 193; } /* = unique id SOAP_TYPE_tt__ConfigurationEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigurationEntity() { tt__ConfigurationEntity::soap_default(NULL); }
	virtual ~tt__ConfigurationEntity() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (195)
/* tt:VideoSourceConfigurationOptions */
class SOAP_CMAC tt__VideoSourceConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRectangleRange *BoundsRange;	/* required element of type tt:IntRectangleRange */
	std::vector<std::string >VideoSourceTokensAvailable;	/* required element of type tt:ReferenceToken */
	class tt__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of type tt:VideoSourceConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE_tt__VideoSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptions(): BoundsRange(NULL), Extension(NULL), __anyAttribute(NULL) { tt__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (196)
/* tt:VideoSourceConfigurationOptionsExtension */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 196; } /* = unique id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptionsExtension() { tt__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (198)
/* tt:VideoResolution */
class SOAP_CMAC tt__VideoResolution : public xsd__anyType
{
public:
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 198; } /* = unique id SOAP_TYPE_tt__VideoResolution */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoResolution() { tt__VideoResolution::soap_default(NULL); }
	virtual ~tt__VideoResolution() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (199)
/* tt:VideoRateControl */
class SOAP_CMAC tt__VideoRateControl : public xsd__anyType
{
public:
	int FrameRateLimit;	/* required element of type xsd:int */
	int EncodingInterval;	/* required element of type xsd:int */
	int BitrateLimit;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE_tt__VideoRateControl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoRateControl() { tt__VideoRateControl::soap_default(NULL); }
	virtual ~tt__VideoRateControl() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (200)
/* tt:Mpeg4Configuration */
class SOAP_CMAC tt__Mpeg4Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum tt__Mpeg4Profile Mpeg4Profile;	/* required element of type tt:Mpeg4Profile */
public:
	virtual int soap_type() const { return 200; } /* = unique id SOAP_TYPE_tt__Mpeg4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Configuration() { tt__Mpeg4Configuration::soap_default(NULL); }
	virtual ~tt__Mpeg4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (201)
/* tt:H264Configuration */
class SOAP_CMAC tt__H264Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum tt__H264Profile H264Profile;	/* required element of type tt:H264Profile */
public:
	virtual int soap_type() const { return 201; } /* = unique id SOAP_TYPE_tt__H264Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Configuration() { tt__H264Configuration::soap_default(NULL); }
	virtual ~tt__H264Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (202)
/* tt:VideoEncoderConfigurationOptions */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRange *QualityRange;	/* required element of type tt:IntRange */
	class tt__JpegOptions *JPEG;	/* optional element of type tt:JpegOptions */
	class tt__Mpeg4Options *MPEG4;	/* optional element of type tt:Mpeg4Options */
	class tt__H264Options *H264;	/* optional element of type tt:H264Options */
	class tt__VideoEncoderOptionsExtension *Extension;	/* optional element of type tt:VideoEncoderOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 202; } /* = unique id SOAP_TYPE_tt__VideoEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderConfigurationOptions(): QualityRange(NULL), JPEG(NULL), MPEG4(NULL), H264(NULL), Extension(NULL), __anyAttribute(NULL) { tt__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (203)
/* tt:VideoEncoderOptionsExtension */
class SOAP_CMAC tt__VideoEncoderOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 203; } /* = unique id SOAP_TYPE_tt__VideoEncoderOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderOptionsExtension() { tt__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (204)
/* tt:JpegOptions */
class SOAP_CMAC tt__JpegOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
public:
	virtual int soap_type() const { return 204; } /* = unique id SOAP_TYPE_tt__JpegOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JpegOptions(): FrameRateRange(NULL), EncodingIntervalRange(NULL) { tt__JpegOptions::soap_default(NULL); }
	virtual ~tt__JpegOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (205)
/* tt:Mpeg4Options */
class SOAP_CMAC tt__Mpeg4Options : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
	std::vector<enum tt__Mpeg4Profile >Mpeg4ProfilesSupported;	/* required element of type tt:Mpeg4Profile */
public:
	virtual int soap_type() const { return 205; } /* = unique id SOAP_TYPE_tt__Mpeg4Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Options(): GovLengthRange(NULL), FrameRateRange(NULL), EncodingIntervalRange(NULL) { tt__Mpeg4Options::soap_default(NULL); }
	virtual ~tt__Mpeg4Options() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (206)
/* tt:H264Options */
class SOAP_CMAC tt__H264Options : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
	std::vector<enum tt__H264Profile >H264ProfilesSupported;	/* required element of type tt:H264Profile */
public:
	virtual int soap_type() const { return 206; } /* = unique id SOAP_TYPE_tt__H264Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Options(): GovLengthRange(NULL), FrameRateRange(NULL), EncodingIntervalRange(NULL) { tt__H264Options::soap_default(NULL); }
	virtual ~tt__H264Options() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (208)
/* tt:AudioSourceConfigurationOptions */
class SOAP_CMAC tt__AudioSourceConfigurationOptions : public xsd__anyType
{
public:
	std::vector<std::string >InputTokensAvailable;	/* required element of type tt:ReferenceToken */
	class tt__AudioSourceOptionsExtension *Extension;	/* optional element of type tt:AudioSourceOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 208; } /* = unique id SOAP_TYPE_tt__AudioSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceConfigurationOptions(): Extension(NULL), __anyAttribute(NULL) { tt__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (209)
/* tt:AudioSourceOptionsExtension */
class SOAP_CMAC tt__AudioSourceOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 209; } /* = unique id SOAP_TYPE_tt__AudioSourceOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceOptionsExtension() { tt__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioSourceOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (211)
/* tt:AudioEncoderConfigurationOptions */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions : public xsd__anyType
{
public:
	std::vector<class tt__AudioEncoderConfigurationOption * >Options;	/* optional element of type tt:AudioEncoderConfigurationOption */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 211; } /* = unique id SOAP_TYPE_tt__AudioEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfigurationOptions(): __anyAttribute(NULL) { tt__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (212)
/* tt:AudioEncoderConfigurationOption */
class SOAP_CMAC tt__AudioEncoderConfigurationOption : public xsd__anyType
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of type tt:AudioEncoding */
	tt__IntList *BitrateList;	/* required element of type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of type tt:IntList */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 212; } /* = unique id SOAP_TYPE_tt__AudioEncoderConfigurationOption */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfigurationOption(): BitrateList(NULL), SampleRateList(NULL), __anyAttribute(NULL) { tt__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOption() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (215)
/* tt:PTZFilter */
class SOAP_CMAC tt__PTZFilter : public xsd__anyType
{
public:
	bool Status;	/* required element of type xsd:boolean */
	bool Position;	/* required element of type xsd:boolean */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 215; } /* = unique id SOAP_TYPE_tt__PTZFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZFilter(): __anyAttribute(NULL) { tt__PTZFilter::soap_default(NULL); }
	virtual ~tt__PTZFilter() { }
};
#endif

#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (915)
/* tt:EventSubscription-SubscriptionPolicy */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 915; } /* = unique id SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__EventSubscription_SubscriptionPolicy() { _tt__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (216)
/* tt:EventSubscription */
class SOAP_CMAC tt__EventSubscription : public xsd__anyType
{
public:
	class ns1__FilterType *Filter;	/* optional element of type ns1:FilterType */
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type tt:EventSubscription-SubscriptionPolicy */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 216; } /* = unique id SOAP_TYPE_tt__EventSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventSubscription(): Filter(NULL), SubscriptionPolicy(NULL), __anyAttribute(NULL) { tt__EventSubscription::soap_default(NULL); }
	virtual ~tt__EventSubscription() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (217)
/* tt:MetadataConfigurationOptions */
class SOAP_CMAC tt__MetadataConfigurationOptions : public xsd__anyType
{
public:
	class tt__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of type tt:PTZStatusFilterOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 217; } /* = unique id SOAP_TYPE_tt__MetadataConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfigurationOptions(): PTZStatusFilterOptions(NULL), __anyAttribute(NULL) { tt__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (218)
/* tt:PTZStatusFilterOptions */
class SOAP_CMAC tt__PTZStatusFilterOptions : public xsd__anyType
{
public:
	bool PanTiltStatusSupported;	/* required element of type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 218; } /* = unique id SOAP_TYPE_tt__PTZStatusFilterOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatusFilterOptions(): __anyAttribute(NULL) { tt__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (219)
/* tt:MulticastConfiguration */
class SOAP_CMAC tt__MulticastConfiguration : public xsd__anyType
{
public:
	class tt__IPAddress *Address;	/* required element of type tt:IPAddress */
	int Port;	/* required element of type xsd:int */
	int TTL;	/* required element of type xsd:int */
	bool AutoStart;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 219; } /* = unique id SOAP_TYPE_tt__MulticastConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MulticastConfiguration(): Address(NULL), __anyAttribute(NULL) { tt__MulticastConfiguration::soap_default(NULL); }
	virtual ~tt__MulticastConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (220)
/* tt:StreamSetup */
class SOAP_CMAC tt__StreamSetup : public xsd__anyType
{
public:
	enum tt__StreamType Stream;	/* required element of type tt:StreamType */
	class tt__Transport *Transport;	/* required element of type tt:Transport */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 220; } /* = unique id SOAP_TYPE_tt__StreamSetup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StreamSetup(): Transport(NULL), __anyAttribute(NULL) { tt__StreamSetup::soap_default(NULL); }
	virtual ~tt__StreamSetup() { }
};
#endif

#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (221)
/* tt:Transport */
class SOAP_CMAC tt__Transport : public xsd__anyType
{
public:
	enum tt__TransportProtocol Protocol;	/* required element of type tt:TransportProtocol */
	tt__Transport *Tunnel;	/* optional element of type tt:Transport */
public:
	virtual int soap_type() const { return 221; } /* = unique id SOAP_TYPE_tt__Transport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Transport(): Tunnel(NULL) { tt__Transport::soap_default(NULL); }
	virtual ~tt__Transport() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (222)
/* tt:MediaUri */
class SOAP_CMAC tt__MediaUri : public xsd__anyType
{
public:
	std::string Uri;	/* required element of type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of type xsd:boolean */
	LONG64 Timeout;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE_tt__MediaUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaUri(): __anyAttribute(NULL) { tt__MediaUri::soap_default(NULL); }
	virtual ~tt__MediaUri() { }
};
#endif

#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (223)
/* tt:Scope */
class SOAP_CMAC tt__Scope : public xsd__anyType
{
public:
	enum tt__ScopeDefinition ScopeDef;	/* required element of type tt:ScopeDefinition */
	std::string ScopeItem;	/* required element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 223; } /* = unique id SOAP_TYPE_tt__Scope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Scope() { tt__Scope::soap_default(NULL); }
	virtual ~tt__Scope() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (225)
/* tt:NetworkInterfaceExtension */
class SOAP_CMAC tt__NetworkInterfaceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 225; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceExtension() { tt__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (226)
/* tt:NetworkInterfaceLink */
class SOAP_CMAC tt__NetworkInterfaceLink : public xsd__anyType
{
public:
	class tt__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of type tt:NetworkInterfaceConnectionSetting */
	tt__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of type tt:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of type tt:IANA-IfTypes */
public:
	virtual int soap_type() const { return 226; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceLink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceLink(): AdminSettings(NULL), OperSettings(NULL) { tt__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceLink() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (227)
/* tt:NetworkInterfaceConnectionSetting */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting : public xsd__anyType
{
public:
	bool AutoNegotiation;	/* required element of type xsd:boolean */
	int Speed;	/* required element of type xsd:int */
	enum tt__Duplex Duplex;	/* required element of type tt:Duplex */
public:
	virtual int soap_type() const { return 227; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceConnectionSetting */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceConnectionSetting() { tt__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConnectionSetting() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (228)
/* tt:NetworkInterfaceInfo */
class SOAP_CMAC tt__NetworkInterfaceInfo : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type xsd:string */
	std::string HwAddress;	/* required element of type tt:HwAddress */
	int *MTU;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 228; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceInfo(): Name(NULL), MTU(NULL) { tt__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceInfo() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (229)
/* tt:IPv6NetworkInterface */
class SOAP_CMAC tt__IPv6NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class tt__IPv6Configuration *Config;	/* optional element of type tt:IPv6Configuration */
public:
	virtual int soap_type() const { return 229; } /* = unique id SOAP_TYPE_tt__IPv6NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6NetworkInterface(): Config(NULL) { tt__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (230)
/* tt:IPv4NetworkInterface */
class SOAP_CMAC tt__IPv4NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class tt__IPv4Configuration *Config;	/* required element of type tt:IPv4Configuration */
public:
	virtual int soap_type() const { return 230; } /* = unique id SOAP_TYPE_tt__IPv4NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4NetworkInterface(): Config(NULL) { tt__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (231)
/* tt:IPv4Configuration */
class SOAP_CMAC tt__IPv4Configuration : public xsd__anyType
{
public:
	std::vector<class tt__PrefixedIPv4Address * >Manual;	/* optional element of type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *LinkLocal;	/* optional element of type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *FromDHCP;	/* optional element of type tt:PrefixedIPv4Address */
	bool DHCP;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 231; } /* = unique id SOAP_TYPE_tt__IPv4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4Configuration(): LinkLocal(NULL), FromDHCP(NULL), __anyAttribute(NULL) { tt__IPv4Configuration::soap_default(NULL); }
	virtual ~tt__IPv4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (232)
/* tt:IPv6Configuration */
class SOAP_CMAC tt__IPv6Configuration : public xsd__anyType
{
public:
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	enum tt__IPv6DHCPConfiguration DHCP;	/* required element of type tt:IPv6DHCPConfiguration */
	std::vector<class tt__PrefixedIPv6Address * >Manual;	/* optional element of type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address * >LinkLocal;	/* optional element of type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address * >FromDHCP;	/* optional element of type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address * >FromRA;	/* optional element of type tt:PrefixedIPv6Address */
	class tt__IPv6ConfigurationExtension *Extension;	/* optional element of type tt:IPv6ConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 232; } /* = unique id SOAP_TYPE_tt__IPv6Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6Configuration(): AcceptRouterAdvert(NULL), Extension(NULL), __anyAttribute(NULL) { tt__IPv6Configuration::soap_default(NULL); }
	virtual ~tt__IPv6Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (233)
/* tt:IPv6ConfigurationExtension */
class SOAP_CMAC tt__IPv6ConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 233; } /* = unique id SOAP_TYPE_tt__IPv6ConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6ConfigurationExtension() { tt__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~tt__IPv6ConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (234)
/* tt:NetworkProtocol */
class SOAP_CMAC tt__NetworkProtocol : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType Name;	/* required element of type tt:NetworkProtocolType */
	bool Enabled;	/* required element of type xsd:boolean */
	std::vector<int >Port;	/* required element of type xsd:int */
	class tt__NetworkProtocolExtension *Extension;	/* optional element of type tt:NetworkProtocolExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 234; } /* = unique id SOAP_TYPE_tt__NetworkProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocol(): Extension(NULL), __anyAttribute(NULL) { tt__NetworkProtocol::soap_default(NULL); }
	virtual ~tt__NetworkProtocol() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (235)
/* tt:NetworkProtocolExtension */
class SOAP_CMAC tt__NetworkProtocolExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 235; } /* = unique id SOAP_TYPE_tt__NetworkProtocolExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocolExtension() { tt__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~tt__NetworkProtocolExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (236)
/* tt:NetworkHost */
class SOAP_CMAC tt__NetworkHost : public xsd__anyType
{
public:
	enum tt__NetworkHostType Type;	/* required element of type tt:NetworkHostType */
	std::string *IPv4Address;	/* optional element of type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of type tt:IPv6Address */
	std::string *DNSname;	/* optional element of type tt:DNSName */
	class tt__NetworkHostExtension *Extension;	/* optional element of type tt:NetworkHostExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 236; } /* = unique id SOAP_TYPE_tt__NetworkHost */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHost(): IPv4Address(NULL), IPv6Address(NULL), DNSname(NULL), Extension(NULL), __anyAttribute(NULL) { tt__NetworkHost::soap_default(NULL); }
	virtual ~tt__NetworkHost() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (237)
/* tt:NetworkHostExtension */
class SOAP_CMAC tt__NetworkHostExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 237; } /* = unique id SOAP_TYPE_tt__NetworkHostExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHostExtension() { tt__NetworkHostExtension::soap_default(NULL); }
	virtual ~tt__NetworkHostExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (238)
/* tt:IPAddress */
class SOAP_CMAC tt__IPAddress : public xsd__anyType
{
public:
	enum tt__IPType Type;	/* required element of type tt:IPType */
	std::string *IPv4Address;	/* optional element of type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of type tt:IPv6Address */
public:
	virtual int soap_type() const { return 238; } /* = unique id SOAP_TYPE_tt__IPAddress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddress(): IPv4Address(NULL), IPv6Address(NULL) { tt__IPAddress::soap_default(NULL); }
	virtual ~tt__IPAddress() { }
};
#endif

#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (239)
/* tt:PrefixedIPv4Address */
class SOAP_CMAC tt__PrefixedIPv4Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of type tt:IPv4Address */
	int PrefixLength;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 239; } /* = unique id SOAP_TYPE_tt__PrefixedIPv4Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PrefixedIPv4Address() { tt__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv4Address() { }
};
#endif

#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (240)
/* tt:PrefixedIPv6Address */
class SOAP_CMAC tt__PrefixedIPv6Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of type tt:IPv6Address */
	int PrefixLength;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 240; } /* = unique id SOAP_TYPE_tt__PrefixedIPv6Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PrefixedIPv6Address() { tt__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv6Address() { }
};
#endif

#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (241)
/* tt:HostnameInformation */
class SOAP_CMAC tt__HostnameInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::string *Name;	/* optional element of type xsd:token */
	class tt__HostnameInformationExtension *Extension;	/* optional element of type tt:HostnameInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 241; } /* = unique id SOAP_TYPE_tt__HostnameInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HostnameInformation(): Name(NULL), Extension(NULL), __anyAttribute(NULL) { tt__HostnameInformation::soap_default(NULL); }
	virtual ~tt__HostnameInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (242)
/* tt:HostnameInformationExtension */
class SOAP_CMAC tt__HostnameInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 242; } /* = unique id SOAP_TYPE_tt__HostnameInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HostnameInformationExtension() { tt__HostnameInformationExtension::soap_default(NULL); }
	virtual ~tt__HostnameInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (243)
/* tt:DNSInformation */
class SOAP_CMAC tt__DNSInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<std::string >SearchDomain;	/* optional element of type xsd:token */
	std::vector<tt__IPAddress * >DNSFromDHCP;	/* optional element of type tt:IPAddress */
	std::vector<tt__IPAddress * >DNSManual;	/* optional element of type tt:IPAddress */
	class tt__DNSInformationExtension *Extension;	/* optional element of type tt:DNSInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 243; } /* = unique id SOAP_TYPE_tt__DNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSInformation(): Extension(NULL), __anyAttribute(NULL) { tt__DNSInformation::soap_default(NULL); }
	virtual ~tt__DNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (244)
/* tt:DNSInformationExtension */
class SOAP_CMAC tt__DNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 244; } /* = unique id SOAP_TYPE_tt__DNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSInformationExtension() { tt__DNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (245)
/* tt:NTPInformation */
class SOAP_CMAC tt__NTPInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<tt__NetworkHost * >NTPFromDHCP;	/* optional element of type tt:NetworkHost */
	std::vector<tt__NetworkHost * >NTPManual;	/* optional element of type tt:NetworkHost */
	class tt__NTPInformationExtension *Extension;	/* optional element of type tt:NTPInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 245; } /* = unique id SOAP_TYPE_tt__NTPInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NTPInformation(): Extension(NULL), __anyAttribute(NULL) { tt__NTPInformation::soap_default(NULL); }
	virtual ~tt__NTPInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (246)
/* tt:NTPInformationExtension */
class SOAP_CMAC tt__NTPInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 246; } /* = unique id SOAP_TYPE_tt__NTPInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NTPInformationExtension() { tt__NTPInformationExtension::soap_default(NULL); }
	virtual ~tt__NTPInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (247)
/* tt:DynamicDNSInformation */
class SOAP_CMAC tt__DynamicDNSInformation : public xsd__anyType
{
public:
	enum tt__DynamicDNSType Type;	/* required element of type tt:DynamicDNSType */
	std::string *Name;	/* optional element of type tt:DNSName */
	LONG64 *TTL;	/* optional element of type xsd:duration */
	class tt__DynamicDNSInformationExtension *Extension;	/* optional element of type tt:DynamicDNSInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 247; } /* = unique id SOAP_TYPE_tt__DynamicDNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSInformation(): Name(NULL), TTL(NULL), Extension(NULL), __anyAttribute(NULL) { tt__DynamicDNSInformation::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (248)
/* tt:DynamicDNSInformationExtension */
class SOAP_CMAC tt__DynamicDNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 248; } /* = unique id SOAP_TYPE_tt__DynamicDNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSInformationExtension() { tt__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (249)
/* tt:NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	tt__NetworkInterfaceConnectionSetting *Link;	/* optional element of type tt:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of type xsd:int */
	class tt__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of type tt:IPv4NetworkInterfaceSetConfiguration */
	class tt__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of type tt:IPv6NetworkInterfaceSetConfiguration */
	class tt__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of type tt:NetworkInterfaceSetConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 249; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfiguration(): Enabled(NULL), Link(NULL), MTU(NULL), IPv4(NULL), IPv6(NULL), Extension(NULL), __anyAttribute(NULL) { tt__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (250)
/* tt:NetworkInterfaceSetConfigurationExtension */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 250; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfigurationExtension() { tt__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (251)
/* tt:IPv6NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	std::vector<tt__PrefixedIPv6Address * >Manual;	/* optional element of type tt:PrefixedIPv6Address */
	enum tt__IPv6DHCPConfiguration *DHCP;	/* optional element of type tt:IPv6DHCPConfiguration */
public:
	virtual int soap_type() const { return 251; } /* = unique id SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6NetworkInterfaceSetConfiguration(): Enabled(NULL), AcceptRouterAdvert(NULL), DHCP(NULL) { tt__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (252)
/* tt:IPv4NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	std::vector<tt__PrefixedIPv4Address * >Manual;	/* optional element of type tt:PrefixedIPv4Address */
	bool *DHCP;	/* optional element of type xsd:boolean */
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4NetworkInterfaceSetConfiguration(): Enabled(NULL), DHCP(NULL) { tt__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (253)
/* tt:NetworkGateway */
class SOAP_CMAC tt__NetworkGateway : public xsd__anyType
{
public:
	std::vector<std::string >IPv4Address;	/* optional element of type tt:IPv4Address */
	std::vector<std::string >IPv6Address;	/* optional element of type tt:IPv6Address */
public:
	virtual int soap_type() const { return 253; } /* = unique id SOAP_TYPE_tt__NetworkGateway */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkGateway() { tt__NetworkGateway::soap_default(NULL); }
	virtual ~tt__NetworkGateway() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (254)
/* tt:NetworkZeroConfiguration */
class SOAP_CMAC tt__NetworkZeroConfiguration : public xsd__anyType
{
public:
	std::string InterfaceToken;	/* required element of type tt:ReferenceToken */
	bool Enabled;	/* required element of type xsd:boolean */
	std::vector<std::string >Addresses;	/* optional element of type tt:IPv4Address */
	class tt__NetworkZeroConfigurationExtension *Extension;	/* optional element of type tt:NetworkZeroConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 254; } /* = unique id SOAP_TYPE_tt__NetworkZeroConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfiguration(): Extension(NULL), __anyAttribute(NULL) { tt__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (255)
/* tt:NetworkZeroConfigurationExtension */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 255; } /* = unique id SOAP_TYPE_tt__NetworkZeroConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfigurationExtension() { tt__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (256)
/* tt:IPAddressFilter */
class SOAP_CMAC tt__IPAddressFilter : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType Type;	/* required element of type tt:IPAddressFilterType */
	std::vector<tt__PrefixedIPv4Address * >IPv4Address;	/* optional element of type tt:PrefixedIPv4Address */
	std::vector<tt__PrefixedIPv6Address * >IPv6Address;	/* optional element of type tt:PrefixedIPv6Address */
	class tt__IPAddressFilterExtension *Extension;	/* optional element of type tt:IPAddressFilterExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 256; } /* = unique id SOAP_TYPE_tt__IPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilter(): Extension(NULL), __anyAttribute(NULL) { tt__IPAddressFilter::soap_default(NULL); }
	virtual ~tt__IPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (257)
/* tt:IPAddressFilterExtension */
class SOAP_CMAC tt__IPAddressFilterExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 257; } /* = unique id SOAP_TYPE_tt__IPAddressFilterExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilterExtension() { tt__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~tt__IPAddressFilterExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (258)
/* tt:Capabilities */
class SOAP_CMAC tt__Capabilities : public xsd__anyType
{
public:
	class tt__AnalyticsCapabilities *Analytics;	/* optional element of type tt:AnalyticsCapabilities */
	class tt__DeviceCapabilities *Device;	/* optional element of type tt:DeviceCapabilities */
	class tt__EventCapabilities *Events;	/* optional element of type tt:EventCapabilities */
	class tt__ImagingCapabilities *Imaging;	/* optional element of type tt:ImagingCapabilities */
	class tt__MediaCapabilities *Media;	/* optional element of type tt:MediaCapabilities */
	class tt__PTZCapabilities *PTZ;	/* optional element of type tt:PTZCapabilities */
	class tt__CapabilitiesExtension *Extension;	/* optional element of type tt:CapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 258; } /* = unique id SOAP_TYPE_tt__Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Capabilities(): Analytics(NULL), Device(NULL), Events(NULL), Imaging(NULL), Media(NULL), PTZ(NULL), Extension(NULL), __anyAttribute(NULL) { tt__Capabilities::soap_default(NULL); }
	virtual ~tt__Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (259)
/* tt:CapabilitiesExtension */
class SOAP_CMAC tt__CapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 259; } /* = unique id SOAP_TYPE_tt__CapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CapabilitiesExtension() { tt__CapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (260)
/* tt:AnalyticsCapabilities */
class SOAP_CMAC tt__AnalyticsCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool RuleSupport;	/* required element of type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 260; } /* = unique id SOAP_TYPE_tt__AnalyticsCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsCapabilities(): __anyAttribute(NULL) { tt__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (261)
/* tt:DeviceCapabilities */
class SOAP_CMAC tt__DeviceCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	class tt__NetworkCapabilities *Network;	/* optional element of type tt:NetworkCapabilities */
	class tt__SystemCapabilities *System;	/* optional element of type tt:SystemCapabilities */
	class tt__IOCapabilities *IO;	/* optional element of type tt:IOCapabilities */
	class tt__SecurityCapabilities *Security;	/* optional element of type tt:SecurityCapabilities */
	class tt__DeviceCapabilitiesExtension *Extension;	/* optional element of type tt:DeviceCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 261; } /* = unique id SOAP_TYPE_tt__DeviceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceCapabilities(): Network(NULL), System(NULL), IO(NULL), Security(NULL), Extension(NULL), __anyAttribute(NULL) { tt__DeviceCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (262)
/* tt:DeviceCapabilitiesExtension */
class SOAP_CMAC tt__DeviceCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 262; } /* = unique id SOAP_TYPE_tt__DeviceCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceCapabilitiesExtension() { tt__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__DeviceCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (263)
/* tt:EventCapabilities */
class SOAP_CMAC tt__EventCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of type xsd:boolean */
	bool WSPullPointSupport;	/* required element of type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 263; } /* = unique id SOAP_TYPE_tt__EventCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventCapabilities(): __anyAttribute(NULL) { tt__EventCapabilities::soap_default(NULL); }
	virtual ~tt__EventCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (264)
/* tt:IOCapabilities */
class SOAP_CMAC tt__IOCapabilities : public xsd__anyType
{
public:
	int *InputConnectors;	/* optional element of type xsd:int */
	int *RelayOutputs;	/* optional element of type xsd:int */
	class tt__IOCapabilitiesExtension *Extension;	/* optional element of type tt:IOCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 264; } /* = unique id SOAP_TYPE_tt__IOCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilities(): InputConnectors(NULL), RelayOutputs(NULL), Extension(NULL), __anyAttribute(NULL) { tt__IOCapabilities::soap_default(NULL); }
	virtual ~tt__IOCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (265)
/* tt:IOCapabilitiesExtension */
class SOAP_CMAC tt__IOCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 265; } /* = unique id SOAP_TYPE_tt__IOCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilitiesExtension() { tt__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (266)
/* tt:MediaCapabilities */
class SOAP_CMAC tt__MediaCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	class tt__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of type tt:RealTimeStreamingCapabilities */
	std::vector<char * >__any;
	class tt__MediaCapabilitiesExtension *Extension;	/* optional element of type tt:MediaCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 266; } /* = unique id SOAP_TYPE_tt__MediaCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaCapabilities(): StreamingCapabilities(NULL), Extension(NULL), __anyAttribute(NULL) { tt__MediaCapabilities::soap_default(NULL); }
	virtual ~tt__MediaCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (267)
/* tt:MediaCapabilitiesExtension */
class SOAP_CMAC tt__MediaCapabilitiesExtension : public xsd__anyType
{
public:
	class tt__ProfileCapabilities *ProfileCapabilities;	/* required element of type tt:ProfileCapabilities */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 267; } /* = unique id SOAP_TYPE_tt__MediaCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaCapabilitiesExtension(): ProfileCapabilities(NULL), __anyAttribute(NULL) { tt__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__MediaCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (268)
/* tt:RealTimeStreamingCapabilities */
class SOAP_CMAC tt__RealTimeStreamingCapabilities : public xsd__anyType
{
public:
	bool *RTPMulticast;	/* optional element of type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of type xsd:boolean */
	class tt__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of type tt:RealTimeStreamingCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 268; } /* = unique id SOAP_TYPE_tt__RealTimeStreamingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RealTimeStreamingCapabilities(): RTPMulticast(NULL), RTP_USCORETCP(NULL), RTP_USCORERTSP_USCORETCP(NULL), Extension(NULL), __anyAttribute(NULL) { tt__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (269)
/* tt:RealTimeStreamingCapabilitiesExtension */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 269; } /* = unique id SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RealTimeStreamingCapabilitiesExtension() { tt__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (270)
/* tt:ProfileCapabilities */
class SOAP_CMAC tt__ProfileCapabilities : public xsd__anyType
{
public:
	int MaximumNumberOfProfiles;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 270; } /* = unique id SOAP_TYPE_tt__ProfileCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileCapabilities(): __anyAttribute(NULL) { tt__ProfileCapabilities::soap_default(NULL); }
	virtual ~tt__ProfileCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (271)
/* tt:NetworkCapabilities */
class SOAP_CMAC tt__NetworkCapabilities : public xsd__anyType
{
public:
	bool *IPFilter;	/* optional element of type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of type xsd:boolean */
	bool *IPVersion6;	/* optional element of type xsd:boolean */
	bool *DynDNS;	/* optional element of type xsd:boolean */
	class tt__NetworkCapabilitiesExtension *Extension;	/* optional element of type tt:NetworkCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 271; } /* = unique id SOAP_TYPE_tt__NetworkCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilities(): IPFilter(NULL), ZeroConfiguration(NULL), IPVersion6(NULL), DynDNS(NULL), Extension(NULL), __anyAttribute(NULL) { tt__NetworkCapabilities::soap_default(NULL); }
	virtual ~tt__NetworkCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (272)
/* tt:NetworkCapabilitiesExtension */
class SOAP_CMAC tt__NetworkCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 272; } /* = unique id SOAP_TYPE_tt__NetworkCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilitiesExtension() { tt__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (273)
/* tt:SecurityCapabilities */
class SOAP_CMAC tt__SecurityCapabilities : public xsd__anyType
{
public:
	bool TLS1_x002e1;	/* required element of type xsd:boolean */
	bool TLS1_x002e2;	/* required element of type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of type xsd:boolean */
	bool X_x002e509Token;	/* required element of type xsd:boolean */
	bool SAMLToken;	/* required element of type xsd:boolean */
	bool KerberosToken;	/* required element of type xsd:boolean */
	bool RELToken;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	class tt__SecurityCapabilitiesExtension *Extension;	/* optional element of type tt:SecurityCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 273; } /* = unique id SOAP_TYPE_tt__SecurityCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilities(): Extension(NULL), __anyAttribute(NULL) { tt__SecurityCapabilities::soap_default(NULL); }
	virtual ~tt__SecurityCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (274)
/* tt:SecurityCapabilitiesExtension */
class SOAP_CMAC tt__SecurityCapabilitiesExtension : public xsd__anyType
{
public:
	bool TLS1_x002e0;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 274; } /* = unique id SOAP_TYPE_tt__SecurityCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilitiesExtension() { tt__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__StorageCapabilities
#define SOAP_TYPE_tt__StorageCapabilities (275)
/* tt:StorageCapabilities */
class SOAP_CMAC tt__StorageCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 275; } /* = unique id SOAP_TYPE_tt__StorageCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StorageCapabilities(): __anyAttribute(NULL) { tt__StorageCapabilities::soap_default(NULL); }
	virtual ~tt__StorageCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (276)
/* tt:SystemCapabilities */
class SOAP_CMAC tt__SystemCapabilities : public xsd__anyType
{
public:
	bool DiscoveryResolve;	/* required element of type xsd:boolean */
	bool DiscoveryBye;	/* required element of type xsd:boolean */
	bool RemoteDiscovery;	/* required element of type xsd:boolean */
	bool SystemBackup;	/* required element of type xsd:boolean */
	bool SystemLogging;	/* required element of type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of type xsd:boolean */
	std::vector<class tt__OnvifVersion * >SupportedVersions;	/* required element of type tt:OnvifVersion */
	class tt__SystemCapabilitiesExtension *Extension;	/* optional element of type tt:SystemCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 276; } /* = unique id SOAP_TYPE_tt__SystemCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilities(): Extension(NULL), __anyAttribute(NULL) { tt__SystemCapabilities::soap_default(NULL); }
	virtual ~tt__SystemCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (277)
/* tt:SystemCapabilitiesExtension */
class SOAP_CMAC tt__SystemCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 277; } /* = unique id SOAP_TYPE_tt__SystemCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilitiesExtension() { tt__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (278)
/* tt:OnvifVersion */
class SOAP_CMAC tt__OnvifVersion : public xsd__anyType
{
public:
	int Major;	/* required element of type xsd:int */
	int Minor;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 278; } /* = unique id SOAP_TYPE_tt__OnvifVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OnvifVersion() { tt__OnvifVersion::soap_default(NULL); }
	virtual ~tt__OnvifVersion() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (279)
/* tt:ImagingCapabilities */
class SOAP_CMAC tt__ImagingCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 279; } /* = unique id SOAP_TYPE_tt__ImagingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingCapabilities(): __anyAttribute(NULL) { tt__ImagingCapabilities::soap_default(NULL); }
	virtual ~tt__ImagingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (280)
/* tt:PTZCapabilities */
class SOAP_CMAC tt__PTZCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 280; } /* = unique id SOAP_TYPE_tt__PTZCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZCapabilities(): __anyAttribute(NULL) { tt__PTZCapabilities::soap_default(NULL); }
	virtual ~tt__PTZCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (281)
/* tt:SystemLog */
class SOAP_CMAC tt__SystemLog : public xsd__anyType
{
public:
	class tt__AttachmentData *Binary;	/* optional element of type tt:AttachmentData */
	std::string *String;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 281; } /* = unique id SOAP_TYPE_tt__SystemLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLog(): Binary(NULL), String(NULL) { tt__SystemLog::soap_default(NULL); }
	virtual ~tt__SystemLog() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (282)
/* tt:SupportInformation */
class SOAP_CMAC tt__SupportInformation : public xsd__anyType
{
public:
	tt__AttachmentData *Binary;	/* optional element of type tt:AttachmentData */
	std::string *String;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 282; } /* = unique id SOAP_TYPE_tt__SupportInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportInformation(): Binary(NULL), String(NULL) { tt__SupportInformation::soap_default(NULL); }
	virtual ~tt__SupportInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (283)
/* tt:BinaryData */
class SOAP_CMAC tt__BinaryData : public xsd__anyType
{
public:
	xsd__base64Binary Data;	/* required element of type xsd:base64Binary */
	char *xmime__contentType;	/* optional attribute */
public:
	virtual int soap_type() const { return 283; } /* = unique id SOAP_TYPE_tt__BinaryData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BinaryData(): xmime__contentType(NULL) { tt__BinaryData::soap_default(NULL); }
	virtual ~tt__BinaryData() { }
};
#endif

#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (284)
/* tt:AttachmentData */
class SOAP_CMAC tt__AttachmentData : public xsd__anyType
{
public:
	struct _xop__Include xop__Include;	/* required element of type xop:Include */
	char *xmime__contentType;	/* optional attribute */
public:
	virtual int soap_type() const { return 284; } /* = unique id SOAP_TYPE_tt__AttachmentData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AttachmentData(): xmime__contentType(NULL) { tt__AttachmentData::soap_default(NULL); }
	virtual ~tt__AttachmentData() { }
};
#endif

#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (285)
/* tt:BackupFile */
class SOAP_CMAC tt__BackupFile : public xsd__anyType
{
public:
	std::string Name;	/* required element of type xsd:string */
	tt__AttachmentData *Data;	/* required element of type tt:AttachmentData */
public:
	virtual int soap_type() const { return 285; } /* = unique id SOAP_TYPE_tt__BackupFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BackupFile(): Data(NULL) { tt__BackupFile::soap_default(NULL); }
	virtual ~tt__BackupFile() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (286)
/* tt:SystemDateTime */
class SOAP_CMAC tt__SystemDateTime : public xsd__anyType
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of type xsd:boolean */
	class tt__TimeZone *TimeZone;	/* optional element of type tt:TimeZone */
	class tt__DateTime *UTCDateTime;	/* optional element of type tt:DateTime */
	tt__DateTime *LocalDateTime;	/* optional element of type tt:DateTime */
	class tt__SystemDateTimeExtension *Extension;	/* optional element of type tt:SystemDateTimeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 286; } /* = unique id SOAP_TYPE_tt__SystemDateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemDateTime(): TimeZone(NULL), UTCDateTime(NULL), LocalDateTime(NULL), Extension(NULL), __anyAttribute(NULL) { tt__SystemDateTime::soap_default(NULL); }
	virtual ~tt__SystemDateTime() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (287)
/* tt:SystemDateTimeExtension */
class SOAP_CMAC tt__SystemDateTimeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 287; } /* = unique id SOAP_TYPE_tt__SystemDateTimeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemDateTimeExtension() { tt__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~tt__SystemDateTimeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (288)
/* tt:DateTime */
class SOAP_CMAC tt__DateTime : public xsd__anyType
{
public:
	class tt__Time *Time;	/* required element of type tt:Time */
	class tt__Date *Date;	/* required element of type tt:Date */
public:
	virtual int soap_type() const { return 288; } /* = unique id SOAP_TYPE_tt__DateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DateTime(): Time(NULL), Date(NULL) { tt__DateTime::soap_default(NULL); }
	virtual ~tt__DateTime() { }
};
#endif

#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (289)
/* tt:Date */
class SOAP_CMAC tt__Date : public xsd__anyType
{
public:
	int Year;	/* required element of type xsd:int */
	int Month;	/* required element of type xsd:int */
	int Day;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 289; } /* = unique id SOAP_TYPE_tt__Date */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Date() { tt__Date::soap_default(NULL); }
	virtual ~tt__Date() { }
};
#endif

#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (290)
/* tt:Time */
class SOAP_CMAC tt__Time : public xsd__anyType
{
public:
	int Hour;	/* required element of type xsd:int */
	int Minute;	/* required element of type xsd:int */
	int Second;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 290; } /* = unique id SOAP_TYPE_tt__Time */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Time() { tt__Time::soap_default(NULL); }
	virtual ~tt__Time() { }
};
#endif

#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (291)
/* tt:TimeZone */
class SOAP_CMAC tt__TimeZone : public xsd__anyType
{
public:
	std::string TZ;	/* required element of type xsd:token */
public:
	virtual int soap_type() const { return 291; } /* = unique id SOAP_TYPE_tt__TimeZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TimeZone() { tt__TimeZone::soap_default(NULL); }
	virtual ~tt__TimeZone() { }
};
#endif

#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (292)
/* tt:User */
class SOAP_CMAC tt__User : public xsd__anyType
{
public:
	std::string Username;	/* required element of type xsd:string */
	std::string *Password;	/* optional element of type xsd:string */
	enum tt__UserLevel UserLevel;	/* required element of type tt:UserLevel */
	class tt__UserExtension *Extension;	/* optional element of type tt:UserExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 292; } /* = unique id SOAP_TYPE_tt__User */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__User(): Password(NULL), Extension(NULL), __anyAttribute(NULL) { tt__User::soap_default(NULL); }
	virtual ~tt__User() { }
};
#endif

#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (293)
/* tt:UserExtension */
class SOAP_CMAC tt__UserExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 293; } /* = unique id SOAP_TYPE_tt__UserExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__UserExtension() { tt__UserExtension::soap_default(NULL); }
	virtual ~tt__UserExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (294)
/* tt:CertificateGenerationParameters */
class SOAP_CMAC tt__CertificateGenerationParameters : public xsd__anyType
{
public:
	std::string *CertificateID;	/* optional element of type xsd:token */
	std::string *Subject;	/* optional element of type xsd:string */
	std::string *ValidNotBefore;	/* optional element of type xsd:token */
	std::string *ValidNotAfter;	/* optional element of type xsd:token */
	class tt__CertificateGenerationParametersExtension *Extension;	/* optional element of type tt:CertificateGenerationParametersExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 294; } /* = unique id SOAP_TYPE_tt__CertificateGenerationParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateGenerationParameters(): CertificateID(NULL), Subject(NULL), ValidNotBefore(NULL), ValidNotAfter(NULL), Extension(NULL), __anyAttribute(NULL) { tt__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParameters() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (295)
/* tt:CertificateGenerationParametersExtension */
class SOAP_CMAC tt__CertificateGenerationParametersExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 295; } /* = unique id SOAP_TYPE_tt__CertificateGenerationParametersExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateGenerationParametersExtension() { tt__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParametersExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (296)
/* tt:Certificate */
class SOAP_CMAC tt__Certificate : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	tt__BinaryData *Certificate;	/* required element of type tt:BinaryData */
public:
	virtual int soap_type() const { return 296; } /* = unique id SOAP_TYPE_tt__Certificate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Certificate(): Certificate(NULL) { tt__Certificate::soap_default(NULL); }
	virtual ~tt__Certificate() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (297)
/* tt:CertificateStatus */
class SOAP_CMAC tt__CertificateStatus : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	bool Status;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 297; } /* = unique id SOAP_TYPE_tt__CertificateStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateStatus(): __anyAttribute(NULL) { tt__CertificateStatus::soap_default(NULL); }
	virtual ~tt__CertificateStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (298)
/* tt:RelayOutputSettings */
class SOAP_CMAC tt__RelayOutputSettings : public xsd__anyType
{
public:
	enum tt__RelayMode Mode;	/* required element of type tt:RelayMode */
	LONG64 DelayTime;	/* external */
	enum tt__RelayIdleState IdleState;	/* required element of type tt:RelayIdleState */
public:
	virtual int soap_type() const { return 298; } /* = unique id SOAP_TYPE_tt__RelayOutputSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayOutputSettings() { tt__RelayOutputSettings::soap_default(NULL); }
	virtual ~tt__RelayOutputSettings() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (301)
/* tt:PTZNodeExtension */
class SOAP_CMAC tt__PTZNodeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 301; } /* = unique id SOAP_TYPE_tt__PTZNodeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNodeExtension() { tt__PTZNodeExtension::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (303)
/* tt:PTZConfigurationExtension */
class SOAP_CMAC tt__PTZConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 303; } /* = unique id SOAP_TYPE_tt__PTZConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationExtension() { tt__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (304)
/* tt:PTZConfigurationOptions */
class SOAP_CMAC tt__PTZConfigurationOptions : public xsd__anyType
{
public:
	class tt__PTZSpaces *Spaces;	/* required element of type tt:PTZSpaces */
	tt__DurationRange *PTZTimeout;	/* required element of type tt:DurationRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 304; } /* = unique id SOAP_TYPE_tt__PTZConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationOptions(): Spaces(NULL), PTZTimeout(NULL), __anyAttribute(NULL) { tt__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (305)
/* tt:PanTiltLimits */
class SOAP_CMAC tt__PanTiltLimits : public xsd__anyType
{
public:
	class tt__Space2DDescription *Range;	/* required element of type tt:Space2DDescription */
public:
	virtual int soap_type() const { return 305; } /* = unique id SOAP_TYPE_tt__PanTiltLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PanTiltLimits(): Range(NULL) { tt__PanTiltLimits::soap_default(NULL); }
	virtual ~tt__PanTiltLimits() { }
};
#endif

#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (306)
/* tt:ZoomLimits */
class SOAP_CMAC tt__ZoomLimits : public xsd__anyType
{
public:
	class tt__Space1DDescription *Range;	/* required element of type tt:Space1DDescription */
public:
	virtual int soap_type() const { return 306; } /* = unique id SOAP_TYPE_tt__ZoomLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ZoomLimits(): Range(NULL) { tt__ZoomLimits::soap_default(NULL); }
	virtual ~tt__ZoomLimits() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (307)
/* tt:PTZSpaces */
class SOAP_CMAC tt__PTZSpaces : public xsd__anyType
{
public:
	std::vector<tt__Space2DDescription * >AbsolutePanTiltPositionSpace;	/* optional element of type tt:Space2DDescription */
	std::vector<tt__Space1DDescription * >AbsoluteZoomPositionSpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space2DDescription * >RelativePanTiltTranslationSpace;	/* optional element of type tt:Space2DDescription */
	std::vector<tt__Space1DDescription * >RelativeZoomTranslationSpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space2DDescription * >ContinuousPanTiltVelocitySpace;	/* optional element of type tt:Space2DDescription */
	std::vector<tt__Space1DDescription * >ContinuousZoomVelocitySpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space1DDescription * >PanTiltSpeedSpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space1DDescription * >ZoomSpeedSpace;	/* optional element of type tt:Space1DDescription */
	class tt__PTZSpacesExtension *Extension;	/* optional element of type tt:PTZSpacesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 307; } /* = unique id SOAP_TYPE_tt__PTZSpaces */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpaces(): Extension(NULL), __anyAttribute(NULL) { tt__PTZSpaces::soap_default(NULL); }
	virtual ~tt__PTZSpaces() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (308)
/* tt:PTZSpacesExtension */
class SOAP_CMAC tt__PTZSpacesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 308; } /* = unique id SOAP_TYPE_tt__PTZSpacesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpacesExtension() { tt__PTZSpacesExtension::soap_default(NULL); }
	virtual ~tt__PTZSpacesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (309)
/* tt:Space2DDescription */
class SOAP_CMAC tt__Space2DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of type tt:FloatRange */
	tt__FloatRange *YRange;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 309; } /* = unique id SOAP_TYPE_tt__Space2DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Space2DDescription(): XRange(NULL), YRange(NULL) { tt__Space2DDescription::soap_default(NULL); }
	virtual ~tt__Space2DDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (310)
/* tt:Space1DDescription */
class SOAP_CMAC tt__Space1DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 310; } /* = unique id SOAP_TYPE_tt__Space1DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Space1DDescription(): XRange(NULL) { tt__Space1DDescription::soap_default(NULL); }
	virtual ~tt__Space1DDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (311)
/* Primitive tt:Vector2D schema type: */
class SOAP_CMAC tt__Vector2D : public xsd__anyType
{
public:
	float x;	/* required attribute */
	float y;	/* required attribute */
	std::string *space;	/* optional attribute */
public:
	virtual int soap_type() const { return 311; } /* = unique id SOAP_TYPE_tt__Vector2D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector2D(): space(NULL) { tt__Vector2D::soap_default(NULL); }
	virtual ~tt__Vector2D() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (312)
/* Primitive tt:Vector1D schema type: */
class SOAP_CMAC tt__Vector1D : public xsd__anyType
{
public:
	float x;	/* required attribute */
	std::string *space;	/* optional attribute */
public:
	virtual int soap_type() const { return 312; } /* = unique id SOAP_TYPE_tt__Vector1D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector1D(): space(NULL) { tt__Vector1D::soap_default(NULL); }
	virtual ~tt__Vector1D() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (313)
/* tt:PTZVector */
class SOAP_CMAC tt__PTZVector : public xsd__anyType
{
public:
	tt__Vector2D *PanTilt;	/* optional element of type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of type tt:Vector1D */
public:
	virtual int soap_type() const { return 313; } /* = unique id SOAP_TYPE_tt__PTZVector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZVector(): PanTilt(NULL), Zoom(NULL) { tt__PTZVector::soap_default(NULL); }
	virtual ~tt__PTZVector() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (314)
/* tt:PTZSpeed */
class SOAP_CMAC tt__PTZSpeed : public xsd__anyType
{
public:
	tt__Vector2D *PanTilt;	/* optional element of type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of type tt:Vector1D */
public:
	virtual int soap_type() const { return 314; } /* = unique id SOAP_TYPE_tt__PTZSpeed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpeed(): PanTilt(NULL), Zoom(NULL) { tt__PTZSpeed::soap_default(NULL); }
	virtual ~tt__PTZSpeed() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (315)
/* tt:PTZStatus */
class SOAP_CMAC tt__PTZStatus : public xsd__anyType
{
public:
	tt__PTZVector *Position;	/* optional element of type tt:PTZVector */
	class tt__PTZMoveStatus *MoveStatus;	/* optional element of type tt:PTZMoveStatus */
	std::string *Error;	/* optional element of type xsd:string */
	time_t UtcTime;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 315; } /* = unique id SOAP_TYPE_tt__PTZStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatus(): Position(NULL), MoveStatus(NULL), Error(NULL), __anyAttribute(NULL) { tt__PTZStatus::soap_default(NULL); }
	virtual ~tt__PTZStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (316)
/* tt:PTZPreset */
class SOAP_CMAC tt__PTZPreset : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type tt:Name */
	tt__PTZVector *PTZPosition;	/* optional element of type tt:PTZVector */
	std::string *token;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 316; } /* = unique id SOAP_TYPE_tt__PTZPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPreset(): Name(NULL), PTZPosition(NULL), token(NULL), __anyAttribute(NULL) { tt__PTZPreset::soap_default(NULL); }
	virtual ~tt__PTZPreset() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (317)
/* tt:PTZMoveStatus */
class SOAP_CMAC tt__PTZMoveStatus : public xsd__anyType
{
public:
	enum tt__MoveStatus *PanTilt;	/* optional element of type tt:MoveStatus */
	enum tt__MoveStatus *Zoom;	/* optional element of type tt:MoveStatus */
public:
	virtual int soap_type() const { return 317; } /* = unique id SOAP_TYPE_tt__PTZMoveStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZMoveStatus(): PanTilt(NULL), Zoom(NULL) { tt__PTZMoveStatus::soap_default(NULL); }
	virtual ~tt__PTZMoveStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (318)
/* tt:ImagingStatus */
class SOAP_CMAC tt__ImagingStatus : public xsd__anyType
{
public:
	class tt__FocusStatus *FocusStatus;	/* required element of type tt:FocusStatus */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 318; } /* = unique id SOAP_TYPE_tt__ImagingStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus(): FocusStatus(NULL), __anyAttribute(NULL) { tt__ImagingStatus::soap_default(NULL); }
	virtual ~tt__ImagingStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (319)
/* tt:FocusStatus */
class SOAP_CMAC tt__FocusStatus : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of type tt:MoveStatus */
	std::string Error;	/* required element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 319; } /* = unique id SOAP_TYPE_tt__FocusStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus(): __anyAttribute(NULL) { tt__FocusStatus::soap_default(NULL); }
	virtual ~tt__FocusStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (320)
/* tt:FocusConfiguration */
class SOAP_CMAC tt__FocusConfiguration : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of type tt:AutoFocusMode */
	float DefaultSpeed;	/* required element of type xsd:float */
	float NearLimit;	/* required element of type xsd:float */
	float FarLimit;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 320; } /* = unique id SOAP_TYPE_tt__FocusConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration(): __anyAttribute(NULL) { tt__FocusConfiguration::soap_default(NULL); }
	virtual ~tt__FocusConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (321)
/* tt:ImagingSettings */
class SOAP_CMAC tt__ImagingSettings : public xsd__anyType
{
public:
	class tt__BacklightCompensation *BacklightCompensation;	/* optional element of type tt:BacklightCompensation */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class tt__Exposure *Exposure;	/* optional element of type tt:Exposure */
	tt__FocusConfiguration *Focus;	/* optional element of type tt:FocusConfiguration */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class tt__WideDynamicRange *WideDynamicRange;	/* optional element of type tt:WideDynamicRange */
	class tt__WhiteBalance *WhiteBalance;	/* optional element of type tt:WhiteBalance */
	class tt__ImagingSettingsExtension *Extension;	/* optional element of type tt:ImagingSettingsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 321; } /* = unique id SOAP_TYPE_tt__ImagingSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettings(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), IrCutFilter(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ImagingSettings::soap_default(NULL); }
	virtual ~tt__ImagingSettings() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (322)
/* tt:ImagingSettingsExtension */
class SOAP_CMAC tt__ImagingSettingsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 322; } /* = unique id SOAP_TYPE_tt__ImagingSettingsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension() { tt__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (323)
/* tt:Exposure */
class SOAP_CMAC tt__Exposure : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of type tt:ExposureMode */
	enum tt__ExposurePriority Priority;	/* required element of type tt:ExposurePriority */
	class tt__Rectangle *Window;	/* required element of type tt:Rectangle */
	float MinExposureTime;	/* required element of type xsd:float */
	float MaxExposureTime;	/* required element of type xsd:float */
	float MinGain;	/* required element of type xsd:float */
	float MaxGain;	/* required element of type xsd:float */
	float MinIris;	/* required element of type xsd:float */
	float MaxIris;	/* required element of type xsd:float */
	float ExposureTime;	/* required element of type xsd:float */
	float Gain;	/* required element of type xsd:float */
	float Iris;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 323; } /* = unique id SOAP_TYPE_tt__Exposure */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Exposure(): Window(NULL) { tt__Exposure::soap_default(NULL); }
	virtual ~tt__Exposure() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (324)
/* tt:WideDynamicRange */
class SOAP_CMAC tt__WideDynamicRange : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of type tt:WideDynamicMode */
	float Level;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 324; } /* = unique id SOAP_TYPE_tt__WideDynamicRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRange() { tt__WideDynamicRange::soap_default(NULL); }
	virtual ~tt__WideDynamicRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (325)
/* tt:BacklightCompensation */
class SOAP_CMAC tt__BacklightCompensation : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of type tt:BacklightCompensationMode */
	float Level;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 325; } /* = unique id SOAP_TYPE_tt__BacklightCompensation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensation() { tt__BacklightCompensation::soap_default(NULL); }
	virtual ~tt__BacklightCompensation() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (326)
/* tt:ImagingOptions */
class SOAP_CMAC tt__ImagingOptions : public xsd__anyType
{
public:
	class tt__BacklightCompensationOptions *BacklightCompensation;	/* required element of type tt:BacklightCompensationOptions */
	tt__FloatRange *Brightness;	/* required element of type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* required element of type tt:FloatRange */
	tt__FloatRange *Contrast;	/* required element of type tt:FloatRange */
	class tt__ExposureOptions *Exposure;	/* required element of type tt:ExposureOptions */
	class tt__FocusOptions *Focus;	/* required element of type tt:FocusOptions */
	std::vector<enum tt__IrCutFilterMode >IrCutFilterModes;	/* required element of type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* required element of type tt:FloatRange */
	class tt__WideDynamicRangeOptions *WideDynamicRange;	/* required element of type tt:WideDynamicRangeOptions */
	class tt__WhiteBalanceOptions *WhiteBalance;	/* required element of type tt:WhiteBalanceOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 326; } /* = unique id SOAP_TYPE_tt__ImagingOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), __anyAttribute(NULL) { tt__ImagingOptions::soap_default(NULL); }
	virtual ~tt__ImagingOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (327)
/* tt:WideDynamicRangeOptions */
class SOAP_CMAC tt__WideDynamicRangeOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode >Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 327; } /* = unique id SOAP_TYPE_tt__WideDynamicRangeOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRangeOptions(): Level(NULL) { tt__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (328)
/* tt:BacklightCompensationOptions */
class SOAP_CMAC tt__BacklightCompensationOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode >Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 328; } /* = unique id SOAP_TYPE_tt__BacklightCompensationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationOptions(): Level(NULL) { tt__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (329)
/* tt:FocusOptions */
class SOAP_CMAC tt__FocusOptions : public xsd__anyType
{
public:
	std::vector<enum tt__AutoFocusMode >AutoFocusModes;	/* optional element of type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* required element of type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* required element of type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 329; } /* = unique id SOAP_TYPE_tt__FocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions(): DefaultSpeed(NULL), NearLimit(NULL), FarLimit(NULL) { tt__FocusOptions::soap_default(NULL); }
	virtual ~tt__FocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (330)
/* tt:ExposureOptions */
class SOAP_CMAC tt__ExposureOptions : public xsd__anyType
{
public:
	std::vector<enum tt__ExposureMode >Mode;	/* required element of type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority >Priority;	/* required element of type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *MinGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *MinIris;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* required element of type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *Gain;	/* required element of type tt:FloatRange */
	tt__FloatRange *Iris;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 330; } /* = unique id SOAP_TYPE_tt__ExposureOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureOptions(): MinExposureTime(NULL), MaxExposureTime(NULL), MinGain(NULL), MaxGain(NULL), MinIris(NULL), MaxIris(NULL), ExposureTime(NULL), Gain(NULL), Iris(NULL) { tt__ExposureOptions::soap_default(NULL); }
	virtual ~tt__ExposureOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (331)
/* tt:WhiteBalanceOptions */
class SOAP_CMAC tt__WhiteBalanceOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WhiteBalanceMode >Mode;	/* required element of type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *YbGain;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 331; } /* = unique id SOAP_TYPE_tt__WhiteBalanceOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions(): YrGain(NULL), YbGain(NULL) { tt__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (332)
/* tt:FocusMove */
class SOAP_CMAC tt__FocusMove : public xsd__anyType
{
public:
	class tt__AbsoluteFocus *Absolute;	/* optional element of type tt:AbsoluteFocus */
	class tt__RelativeFocus *Relative;	/* optional element of type tt:RelativeFocus */
	class tt__ContinuousFocus *Continuous;	/* optional element of type tt:ContinuousFocus */
public:
	virtual int soap_type() const { return 332; } /* = unique id SOAP_TYPE_tt__FocusMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusMove(): Absolute(NULL), Relative(NULL), Continuous(NULL) { tt__FocusMove::soap_default(NULL); }
	virtual ~tt__FocusMove() { }
};
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (333)
/* tt:AbsoluteFocus */
class SOAP_CMAC tt__AbsoluteFocus : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 333; } /* = unique id SOAP_TYPE_tt__AbsoluteFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AbsoluteFocus(): Speed(NULL) { tt__AbsoluteFocus::soap_default(NULL); }
	virtual ~tt__AbsoluteFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (334)
/* tt:RelativeFocus */
class SOAP_CMAC tt__RelativeFocus : public xsd__anyType
{
public:
	float Distance;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 334; } /* = unique id SOAP_TYPE_tt__RelativeFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocus(): Speed(NULL) { tt__RelativeFocus::soap_default(NULL); }
	virtual ~tt__RelativeFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (335)
/* tt:ContinuousFocus */
class SOAP_CMAC tt__ContinuousFocus : public xsd__anyType
{
public:
	float Speed;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 335; } /* = unique id SOAP_TYPE_tt__ContinuousFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ContinuousFocus() { tt__ContinuousFocus::soap_default(NULL); }
	virtual ~tt__ContinuousFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (336)
/* tt:MoveOptions */
class SOAP_CMAC tt__MoveOptions : public xsd__anyType
{
public:
	class tt__AbsoluteFocusOptions *Absolute;	/* optional element of type tt:AbsoluteFocusOptions */
	class tt__RelativeFocusOptions *Relative;	/* optional element of type tt:RelativeFocusOptions */
	class tt__ContinuousFocusOptions *Continuous;	/* optional element of type tt:ContinuousFocusOptions */
public:
	virtual int soap_type() const { return 336; } /* = unique id SOAP_TYPE_tt__MoveOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveOptions(): Absolute(NULL), Relative(NULL), Continuous(NULL) { tt__MoveOptions::soap_default(NULL); }
	virtual ~tt__MoveOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (337)
/* tt:AbsoluteFocusOptions */
class SOAP_CMAC tt__AbsoluteFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Position;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 337; } /* = unique id SOAP_TYPE_tt__AbsoluteFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AbsoluteFocusOptions(): Position(NULL), Speed(NULL) { tt__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~tt__AbsoluteFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (338)
/* tt:RelativeFocusOptions */
class SOAP_CMAC tt__RelativeFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 338; } /* = unique id SOAP_TYPE_tt__RelativeFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocusOptions(): Distance(NULL), Speed(NULL) { tt__RelativeFocusOptions::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (339)
/* tt:ContinuousFocusOptions */
class SOAP_CMAC tt__ContinuousFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Speed;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 339; } /* = unique id SOAP_TYPE_tt__ContinuousFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ContinuousFocusOptions(): Speed(NULL) { tt__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~tt__ContinuousFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (340)
/* tt:WhiteBalance */
class SOAP_CMAC tt__WhiteBalance : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of type tt:WhiteBalanceMode */
	float CrGain;	/* required element of type xsd:float */
	float CbGain;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 340; } /* = unique id SOAP_TYPE_tt__WhiteBalance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance(): __anyAttribute(NULL) { tt__WhiteBalance::soap_default(NULL); }
	virtual ~tt__WhiteBalance() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (341)
/* tt:ImagingStatus20 */
class SOAP_CMAC tt__ImagingStatus20 : public xsd__anyType
{
public:
	class tt__FocusStatus20 *FocusStatus20;	/* optional element of type tt:FocusStatus20 */
	class tt__ImagingStatus20Extension *Extension;	/* optional element of type tt:ImagingStatus20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 341; } /* = unique id SOAP_TYPE_tt__ImagingStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus20(): FocusStatus20(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ImagingStatus20::soap_default(NULL); }
	virtual ~tt__ImagingStatus20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (342)
/* tt:ImagingStatus20Extension */
class SOAP_CMAC tt__ImagingStatus20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 342; } /* = unique id SOAP_TYPE_tt__ImagingStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus20Extension() { tt__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~tt__ImagingStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (343)
/* tt:FocusStatus20 */
class SOAP_CMAC tt__FocusStatus20 : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of type tt:MoveStatus */
	std::string *Error;	/* optional element of type xsd:string */
	class tt__FocusStatus20Extension *Extension;	/* optional element of type tt:FocusStatus20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 343; } /* = unique id SOAP_TYPE_tt__FocusStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus20(): Error(NULL), Extension(NULL), __anyAttribute(NULL) { tt__FocusStatus20::soap_default(NULL); }
	virtual ~tt__FocusStatus20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (344)
/* tt:FocusStatus20Extension */
class SOAP_CMAC tt__FocusStatus20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 344; } /* = unique id SOAP_TYPE_tt__FocusStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus20Extension() { tt__FocusStatus20Extension::soap_default(NULL); }
	virtual ~tt__FocusStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (345)
/* tt:ImagingSettings20 */
class SOAP_CMAC tt__ImagingSettings20 : public xsd__anyType
{
public:
	class tt__BacklightCompensation20 *BacklightCompensation;	/* optional element of type tt:BacklightCompensation20 */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class tt__Exposure20 *Exposure;	/* optional element of type tt:Exposure20 */
	class tt__FocusConfiguration20 *Focus;	/* optional element of type tt:FocusConfiguration20 */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class tt__WideDynamicRange20 *WideDynamicRange;	/* optional element of type tt:WideDynamicRange20 */
	class tt__WhiteBalance20 *WhiteBalance;	/* optional element of type tt:WhiteBalance20 */
	class tt__ImagingSettingsExtension20 *Extension;	/* optional element of type tt:ImagingSettingsExtension20 */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 345; } /* = unique id SOAP_TYPE_tt__ImagingSettings20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettings20(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), IrCutFilter(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ImagingSettings20::soap_default(NULL); }
	virtual ~tt__ImagingSettings20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (346)
/* tt:ImagingSettingsExtension20 */
class SOAP_CMAC tt__ImagingSettingsExtension20 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 346; } /* = unique id SOAP_TYPE_tt__ImagingSettingsExtension20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension20() { tt__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (347)
/* tt:WideDynamicRange20 */
class SOAP_CMAC tt__WideDynamicRange20 : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of type tt:WideDynamicMode */
	float *Level;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 347; } /* = unique id SOAP_TYPE_tt__WideDynamicRange20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRange20(): Level(NULL) { tt__WideDynamicRange20::soap_default(NULL); }
	virtual ~tt__WideDynamicRange20() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (348)
/* tt:BacklightCompensation20 */
class SOAP_CMAC tt__BacklightCompensation20 : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of type tt:BacklightCompensationMode */
	float *Level;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 348; } /* = unique id SOAP_TYPE_tt__BacklightCompensation20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensation20(): Level(NULL) { tt__BacklightCompensation20::soap_default(NULL); }
	virtual ~tt__BacklightCompensation20() { }
};
#endif

#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (349)
/* tt:Exposure20 */
class SOAP_CMAC tt__Exposure20 : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of type tt:ExposureMode */
	enum tt__ExposurePriority *Priority;	/* optional element of type tt:ExposurePriority */
	tt__Rectangle *Window;	/* optional element of type tt:Rectangle */
	float *MinExposureTime;	/* optional element of type xsd:float */
	float *MaxExposureTime;	/* optional element of type xsd:float */
	float *MinGain;	/* optional element of type xsd:float */
	float *MaxGain;	/* optional element of type xsd:float */
	float *MinIris;	/* optional element of type xsd:float */
	float *MaxIris;	/* optional element of type xsd:float */
	float *ExposureTime;	/* optional element of type xsd:float */
	float *Gain;	/* optional element of type xsd:float */
	float *Iris;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 349; } /* = unique id SOAP_TYPE_tt__Exposure20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Exposure20(): Priority(NULL), Window(NULL), MinExposureTime(NULL), MaxExposureTime(NULL), MinGain(NULL), MaxGain(NULL), MinIris(NULL), MaxIris(NULL), ExposureTime(NULL), Gain(NULL), Iris(NULL) { tt__Exposure20::soap_default(NULL); }
	virtual ~tt__Exposure20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (350)
/* tt:ImagingOptions20 */
class SOAP_CMAC tt__ImagingOptions20 : public xsd__anyType
{
public:
	class tt__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of type tt:BacklightCompensationOptions20 */
	tt__FloatRange *Brightness;	/* optional element of type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Contrast;	/* optional element of type tt:FloatRange */
	class tt__ExposureOptions20 *Exposure;	/* optional element of type tt:ExposureOptions20 */
	class tt__FocusOptions20 *Focus;	/* optional element of type tt:FocusOptions20 */
	std::vector<enum tt__IrCutFilterMode >IrCutFilterModes;	/* optional element of type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* optional element of type tt:FloatRange */
	class tt__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of type tt:WideDynamicRangeOptions20 */
	class tt__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of type tt:WhiteBalanceOptions20 */
	class tt__ImagingOptions20Extension *Extension;	/* optional element of type tt:ImagingOptions20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 350; } /* = unique id SOAP_TYPE_tt__ImagingOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ImagingOptions20::soap_default(NULL); }
	virtual ~tt__ImagingOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (351)
/* tt:ImagingOptions20Extension */
class SOAP_CMAC tt__ImagingOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 351; } /* = unique id SOAP_TYPE_tt__ImagingOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20Extension() { tt__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (352)
/* tt:WideDynamicRangeOptions20 */
class SOAP_CMAC tt__WideDynamicRangeOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode >Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 352; } /* = unique id SOAP_TYPE_tt__WideDynamicRangeOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRangeOptions20(): Level(NULL) { tt__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (353)
/* tt:BacklightCompensationOptions20 */
class SOAP_CMAC tt__BacklightCompensationOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__BacklightCompensationMode >Mode;	/* required element of type tt:BacklightCompensationMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 353; } /* = unique id SOAP_TYPE_tt__BacklightCompensationOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationOptions20(): Level(NULL) { tt__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (354)
/* tt:ExposureOptions20 */
class SOAP_CMAC tt__ExposureOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__ExposureMode >Mode;	/* required element of type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority >Priority;	/* optional element of type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MinGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MinIris;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* optional element of type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Gain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Iris;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 354; } /* = unique id SOAP_TYPE_tt__ExposureOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureOptions20(): MinExposureTime(NULL), MaxExposureTime(NULL), MinGain(NULL), MaxGain(NULL), MinIris(NULL), MaxIris(NULL), ExposureTime(NULL), Gain(NULL), Iris(NULL) { tt__ExposureOptions20::soap_default(NULL); }
	virtual ~tt__ExposureOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (355)
/* tt:MoveOptions20 */
class SOAP_CMAC tt__MoveOptions20 : public xsd__anyType
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of type tt:AbsoluteFocusOptions */
	class tt__RelativeFocusOptions20 *Relative;	/* optional element of type tt:RelativeFocusOptions20 */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of type tt:ContinuousFocusOptions */
public:
	virtual int soap_type() const { return 355; } /* = unique id SOAP_TYPE_tt__MoveOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveOptions20(): Absolute(NULL), Relative(NULL), Continuous(NULL) { tt__MoveOptions20::soap_default(NULL); }
	virtual ~tt__MoveOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (356)
/* tt:RelativeFocusOptions20 */
class SOAP_CMAC tt__RelativeFocusOptions20 : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 356; } /* = unique id SOAP_TYPE_tt__RelativeFocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocusOptions20(): Distance(NULL), Speed(NULL) { tt__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (357)
/* tt:WhiteBalance20 */
class SOAP_CMAC tt__WhiteBalance20 : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of type tt:WhiteBalanceMode */
	float *CrGain;	/* optional element of type xsd:float */
	float *CbGain;	/* optional element of type xsd:float */
	class tt__WhiteBalance20Extension *Extension;	/* optional element of type tt:WhiteBalance20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 357; } /* = unique id SOAP_TYPE_tt__WhiteBalance20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance20(): CrGain(NULL), CbGain(NULL), Extension(NULL), __anyAttribute(NULL) { tt__WhiteBalance20::soap_default(NULL); }
	virtual ~tt__WhiteBalance20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (358)
/* tt:WhiteBalance20Extension */
class SOAP_CMAC tt__WhiteBalance20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 358; } /* = unique id SOAP_TYPE_tt__WhiteBalance20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance20Extension() { tt__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalance20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (359)
/* tt:FocusConfiguration20 */
class SOAP_CMAC tt__FocusConfiguration20 : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of type tt:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of type xsd:float */
	float *NearLimit;	/* optional element of type xsd:float */
	float *FarLimit;	/* optional element of type xsd:float */
	class tt__FocusConfiguration20Extension *Extension;	/* required element of type tt:FocusConfiguration20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 359; } /* = unique id SOAP_TYPE_tt__FocusConfiguration20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration20(): DefaultSpeed(NULL), NearLimit(NULL), FarLimit(NULL), Extension(NULL), __anyAttribute(NULL) { tt__FocusConfiguration20::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (360)
/* tt:FocusConfiguration20Extension */
class SOAP_CMAC tt__FocusConfiguration20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 360; } /* = unique id SOAP_TYPE_tt__FocusConfiguration20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration20Extension() { tt__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (361)
/* tt:WhiteBalanceOptions20 */
class SOAP_CMAC tt__WhiteBalanceOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__WhiteBalanceMode >Mode;	/* required element of type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *YbGain;	/* optional element of type tt:FloatRange */
	class tt__WhiteBalanceOptions20Extension *Extension;	/* optional element of type tt:WhiteBalanceOptions20Extension */
public:
	virtual int soap_type() const { return 361; } /* = unique id SOAP_TYPE_tt__WhiteBalanceOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions20(): YrGain(NULL), YbGain(NULL), Extension(NULL) { tt__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (362)
/* tt:WhiteBalanceOptions20Extension */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 362; } /* = unique id SOAP_TYPE_tt__WhiteBalanceOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions20Extension() { tt__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (363)
/* tt:FocusOptions20 */
class SOAP_CMAC tt__FocusOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__AutoFocusMode >AutoFocusModes;	/* optional element of type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* optional element of type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* optional element of type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* optional element of type tt:FloatRange */
	class tt__FocusOptions20Extension *Extension;	/* optional element of type tt:FocusOptions20Extension */
public:
	virtual int soap_type() const { return 363; } /* = unique id SOAP_TYPE_tt__FocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions20(): DefaultSpeed(NULL), NearLimit(NULL), FarLimit(NULL), Extension(NULL) { tt__FocusOptions20::soap_default(NULL); }
	virtual ~tt__FocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (364)
/* tt:FocusOptions20Extension */
class SOAP_CMAC tt__FocusOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 364; } /* = unique id SOAP_TYPE_tt__FocusOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions20Extension() { tt__FocusOptions20Extension::soap_default(NULL); }
	virtual ~tt__FocusOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (365)
/* tt:MessageExtension */
class SOAP_CMAC tt__MessageExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 365; } /* = unique id SOAP_TYPE_tt__MessageExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageExtension() { tt__MessageExtension::soap_default(NULL); }
	virtual ~tt__MessageExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1048)
/* tt:ItemList-SimpleItem */
class SOAP_CMAC _tt__ItemList_SimpleItem
{
public:
	std::string Name;	/* required attribute */
	std::string Value;	/* required attribute */
public:
	virtual int soap_type() const { return 1048; } /* = unique id SOAP_TYPE__tt__ItemList_SimpleItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemList_SimpleItem() { _tt__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_tt__ItemList_SimpleItem() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1050)
/* tt:ItemList-ElementItem */
class SOAP_CMAC _tt__ItemList_ElementItem
{
public:
	char *__any;
	std::string Name;	/* required attribute */
public:
	virtual int soap_type() const { return 1050; } /* = unique id SOAP_TYPE__tt__ItemList_ElementItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemList_ElementItem(): __any(NULL) { _tt__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_tt__ItemList_ElementItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (366)
/* tt:ItemList */
class SOAP_CMAC tt__ItemList : public xsd__anyType
{
public:
	int __sizeSimpleItem;	/* sequence of elements <SimpleItem> */
	_tt__ItemList_SimpleItem *SimpleItem;	/* optional element of type tt:ItemList-SimpleItem */
	int __sizeElementItem;	/* sequence of elements <ElementItem> */
	_tt__ItemList_ElementItem *ElementItem;	/* optional element of type tt:ItemList-ElementItem */
	class tt__ItemListExtension *Extension;	/* optional element of type tt:ItemListExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 366; } /* = unique id SOAP_TYPE_tt__ItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemList(): SimpleItem(NULL), ElementItem(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ItemList::soap_default(NULL); }
	virtual ~tt__ItemList() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (367)
/* tt:ItemListExtension */
class SOAP_CMAC tt__ItemListExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 367; } /* = unique id SOAP_TYPE_tt__ItemListExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListExtension() { tt__ItemListExtension::soap_default(NULL); }
	virtual ~tt__ItemListExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (368)
/* tt:MessageDescription */
class SOAP_CMAC tt__MessageDescription : public xsd__anyType
{
public:
	class tt__ItemListDescription *Source;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of type tt:ItemListDescription */
	class tt__MessageDescriptionExtension *Extension;	/* optional element of type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 368; } /* = unique id SOAP_TYPE_tt__MessageDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageDescription(): Source(NULL), Key(NULL), Data(NULL), Extension(NULL), IsProperty(NULL), __anyAttribute(NULL) { tt__MessageDescription::soap_default(NULL); }
	virtual ~tt__MessageDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (369)
/* tt:MessageDescriptionExtension */
class SOAP_CMAC tt__MessageDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 369; } /* = unique id SOAP_TYPE_tt__MessageDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageDescriptionExtension() { tt__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~tt__MessageDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1055)
/* tt:ItemListDescription-SimpleItemDescription */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription
{
public:
	std::string Name;	/* required attribute */
	xsd__QName Type;	/* required attribute */
public:
	virtual int soap_type() const { return 1055; } /* = unique id SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemListDescription_SimpleItemDescription() { _tt__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1057)
/* tt:ItemListDescription-ElementItemDescription */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription
{
public:
	std::string Name;	/* required attribute */
	xsd__QName Type;	/* required attribute */
public:
	virtual int soap_type() const { return 1057; } /* = unique id SOAP_TYPE__tt__ItemListDescription_ElementItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemListDescription_ElementItemDescription() { _tt__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_ElementItemDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (370)
/* tt:ItemListDescription */
class SOAP_CMAC tt__ItemListDescription : public xsd__anyType
{
public:
	int __sizeSimpleItemDescription;	/* sequence of elements <SimpleItemDescription> */
	_tt__ItemListDescription_SimpleItemDescription *SimpleItemDescription;	/* optional element of type tt:ItemListDescription-SimpleItemDescription */
	int __sizeElementItemDescription;	/* sequence of elements <ElementItemDescription> */
	_tt__ItemListDescription_ElementItemDescription *ElementItemDescription;	/* optional element of type tt:ItemListDescription-ElementItemDescription */
	class tt__ItemListDescriptionExtension *Extension;	/* optional element of type tt:ItemListDescriptionExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 370; } /* = unique id SOAP_TYPE_tt__ItemListDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListDescription(): SimpleItemDescription(NULL), ElementItemDescription(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ItemListDescription::soap_default(NULL); }
	virtual ~tt__ItemListDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (371)
/* tt:ItemListDescriptionExtension */
class SOAP_CMAC tt__ItemListDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 371; } /* = unique id SOAP_TYPE_tt__ItemListDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListDescriptionExtension() { tt__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ItemListDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (372)
/* Primitive tt:Vector schema type: */
class SOAP_CMAC tt__Vector : public xsd__anyType
{
public:
	float *x;	/* optional attribute */
	float *y;	/* optional attribute */
public:
	virtual int soap_type() const { return 372; } /* = unique id SOAP_TYPE_tt__Vector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector(): x(NULL), y(NULL) { tt__Vector::soap_default(NULL); }
	virtual ~tt__Vector() { }
};
#endif

#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (373)
/* Primitive tt:Rectangle schema type: */
class SOAP_CMAC tt__Rectangle : public xsd__anyType
{
public:
	float *bottom;	/* optional attribute */
	float *top;	/* optional attribute */
	float *right;	/* optional attribute */
	float *left;	/* optional attribute */
public:
	virtual int soap_type() const { return 373; } /* = unique id SOAP_TYPE_tt__Rectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Rectangle(): bottom(NULL), top(NULL), right(NULL), left(NULL) { tt__Rectangle::soap_default(NULL); }
	virtual ~tt__Rectangle() { }
};
#endif

#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (374)
/* tt:Polygon */
class SOAP_CMAC tt__Polygon : public xsd__anyType
{
public:
	std::vector<tt__Vector * >Point;	/* required element of type tt:Vector */
public:
	virtual int soap_type() const { return 374; } /* = unique id SOAP_TYPE_tt__Polygon */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Polygon() { tt__Polygon::soap_default(NULL); }
	virtual ~tt__Polygon() { }
};
#endif

#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (375)
/* tt:Polyline */
class SOAP_CMAC tt__Polyline : public xsd__anyType
{
public:
	std::vector<tt__Vector * >Point;	/* required element of type tt:Vector */
public:
	virtual int soap_type() const { return 375; } /* = unique id SOAP_TYPE_tt__Polyline */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Polyline() { tt__Polyline::soap_default(NULL); }
	virtual ~tt__Polyline() { }
};
#endif

#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (376)
/* Primitive tt:Color schema type: */
class SOAP_CMAC tt__Color : public xsd__anyType
{
public:
	float X;	/* required attribute */
	float Y;	/* required attribute */
	float Z;	/* required attribute */
	std::string *Colorspace;	/* optional attribute */
public:
	virtual int soap_type() const { return 376; } /* = unique id SOAP_TYPE_tt__Color */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Color(): Colorspace(NULL) { tt__Color::soap_default(NULL); }
	virtual ~tt__Color() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (377)
/* Primitive tt:ColorCovariance schema type: */
class SOAP_CMAC tt__ColorCovariance : public xsd__anyType
{
public:
	float XX;	/* required attribute */
	float YY;	/* required attribute */
	float ZZ;	/* required attribute */
	float *XY;	/* optional attribute */
	float *XZ;	/* optional attribute */
	float *YZ;	/* optional attribute */
	std::string *Colorspace;	/* optional attribute */
public:
	virtual int soap_type() const { return 377; } /* = unique id SOAP_TYPE_tt__ColorCovariance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorCovariance(): XY(NULL), XZ(NULL), YZ(NULL), Colorspace(NULL) { tt__ColorCovariance::soap_default(NULL); }
	virtual ~tt__ColorCovariance() { }
};
#endif

#ifndef SOAP_TYPE_tt__Appearance
#define SOAP_TYPE_tt__Appearance (378)
/* tt:Appearance */
class SOAP_CMAC tt__Appearance : public xsd__anyType
{
public:
	class tt__Transformation *Transformation;	/* optional element of type tt:Transformation */
	class tt__ShapeDescriptor *Shape;	/* optional element of type tt:ShapeDescriptor */
	class tt__ColorDescriptor *Color;	/* optional element of type tt:ColorDescriptor */
	class tt__ClassDescriptor *Class;	/* optional element of type tt:ClassDescriptor */
	class tt__AppearanceExtension *Extension;	/* optional element of type tt:AppearanceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 378; } /* = unique id SOAP_TYPE_tt__Appearance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Appearance(): Transformation(NULL), Shape(NULL), Color(NULL), Class(NULL), Extension(NULL), __anyAttribute(NULL) { tt__Appearance::soap_default(NULL); }
	virtual ~tt__Appearance() { }
};
#endif

#ifndef SOAP_TYPE_tt__AppearanceExtension
#define SOAP_TYPE_tt__AppearanceExtension (379)
/* tt:AppearanceExtension */
class SOAP_CMAC tt__AppearanceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 379; } /* = unique id SOAP_TYPE_tt__AppearanceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AppearanceExtension() { tt__AppearanceExtension::soap_default(NULL); }
	virtual ~tt__AppearanceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ShapeDescriptor
#define SOAP_TYPE_tt__ShapeDescriptor (380)
/* tt:ShapeDescriptor */
class SOAP_CMAC tt__ShapeDescriptor : public xsd__anyType
{
public:
	tt__Rectangle *BoundingBox;	/* required element of type tt:Rectangle */
	tt__Vector *CenterOfGravity;	/* required element of type tt:Vector */
	std::vector<tt__Polygon * >Polygon;	/* optional element of type tt:Polygon */
	class tt__ShapeDescriptorExtension *Extension;	/* optional element of type tt:ShapeDescriptorExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 380; } /* = unique id SOAP_TYPE_tt__ShapeDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ShapeDescriptor(): BoundingBox(NULL), CenterOfGravity(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ShapeDescriptor::soap_default(NULL); }
	virtual ~tt__ShapeDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__ShapeDescriptorExtension
#define SOAP_TYPE_tt__ShapeDescriptorExtension (381)
/* tt:ShapeDescriptorExtension */
class SOAP_CMAC tt__ShapeDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 381; } /* = unique id SOAP_TYPE_tt__ShapeDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ShapeDescriptorExtension() { tt__ShapeDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ShapeDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1070)
/* tt:ColorDescriptor-ColorCluster */
class SOAP_CMAC _tt__ColorDescriptor_ColorCluster
{
public:
	tt__Color *Color;	/* required element of type tt:Color */
	float *Weight;	/* optional element of type xsd:float */
	tt__ColorCovariance *Covariance;	/* optional element of type tt:ColorCovariance */
public:
	virtual int soap_type() const { return 1070; } /* = unique id SOAP_TYPE__tt__ColorDescriptor_ColorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ColorDescriptor_ColorCluster(): Color(NULL), Weight(NULL), Covariance(NULL) { _tt__ColorDescriptor_ColorCluster::soap_default(NULL); }
	virtual ~_tt__ColorDescriptor_ColorCluster() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorDescriptor
#define SOAP_TYPE_tt__ColorDescriptor (382)
/* tt:ColorDescriptor */
class SOAP_CMAC tt__ColorDescriptor : public xsd__anyType
{
public:
	int __sizeColorCluster;	/* sequence of elements <ColorCluster> */
	_tt__ColorDescriptor_ColorCluster *ColorCluster;	/* optional element of type tt:ColorDescriptor-ColorCluster */
	class tt__ColorDescriptorExtension *Extension;	/* optional element of type tt:ColorDescriptorExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 382; } /* = unique id SOAP_TYPE_tt__ColorDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorDescriptor(): ColorCluster(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ColorDescriptor::soap_default(NULL); }
	virtual ~tt__ColorDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorDescriptorExtension
#define SOAP_TYPE_tt__ColorDescriptorExtension (383)
/* tt:ColorDescriptorExtension */
class SOAP_CMAC tt__ColorDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 383; } /* = unique id SOAP_TYPE_tt__ColorDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorDescriptorExtension() { tt__ColorDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ColorDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ClassDescriptor_ClassCandidate
#define SOAP_TYPE__tt__ClassDescriptor_ClassCandidate (1075)
/* tt:ClassDescriptor-ClassCandidate */
class SOAP_CMAC _tt__ClassDescriptor_ClassCandidate
{
public:
	enum tt__ClassType Type;	/* required element of type tt:ClassType */
	float Likelihood;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 1075; } /* = unique id SOAP_TYPE__tt__ClassDescriptor_ClassCandidate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ClassDescriptor_ClassCandidate() { _tt__ClassDescriptor_ClassCandidate::soap_default(NULL); }
	virtual ~_tt__ClassDescriptor_ClassCandidate() { }
};
#endif

#ifndef SOAP_TYPE_tt__ClassDescriptor
#define SOAP_TYPE_tt__ClassDescriptor (384)
/* tt:ClassDescriptor */
class SOAP_CMAC tt__ClassDescriptor : public xsd__anyType
{
public:
	int __sizeClassCandidate;	/* sequence of elements <ClassCandidate> */
	_tt__ClassDescriptor_ClassCandidate *ClassCandidate;	/* optional element of type tt:ClassDescriptor-ClassCandidate */
	class tt__ClassDescriptorExtension *Extension;	/* optional element of type tt:ClassDescriptorExtension */
public:
	virtual int soap_type() const { return 384; } /* = unique id SOAP_TYPE_tt__ClassDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ClassDescriptor(): ClassCandidate(NULL), Extension(NULL) { tt__ClassDescriptor::soap_default(NULL); }
	virtual ~tt__ClassDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__ClassDescriptorExtension
#define SOAP_TYPE_tt__ClassDescriptorExtension (385)
/* tt:ClassDescriptorExtension */
class SOAP_CMAC tt__ClassDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 385; } /* = unique id SOAP_TYPE_tt__ClassDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ClassDescriptorExtension() { tt__ClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ClassDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectExtension
#define SOAP_TYPE_tt__ObjectExtension (387)
/* tt:ObjectExtension */
class SOAP_CMAC tt__ObjectExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 387; } /* = unique id SOAP_TYPE_tt__ObjectExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectExtension() { tt__ObjectExtension::soap_default(NULL); }
	virtual ~tt__ObjectExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (388)
/* tt:Transformation */
class SOAP_CMAC tt__Transformation : public xsd__anyType
{
public:
	tt__Vector *Translate;	/* optional element of type tt:Vector */
	tt__Vector *Scale;	/* optional element of type tt:Vector */
	class tt__TransformationExtension *Extension;	/* optional element of type tt:TransformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 388; } /* = unique id SOAP_TYPE_tt__Transformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Transformation(): Translate(NULL), Scale(NULL), Extension(NULL), __anyAttribute(NULL) { tt__Transformation::soap_default(NULL); }
	virtual ~tt__Transformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (389)
/* tt:TransformationExtension */
class SOAP_CMAC tt__TransformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 389; } /* = unique id SOAP_TYPE_tt__TransformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TransformationExtension() { tt__TransformationExtension::soap_default(NULL); }
	virtual ~tt__TransformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Frame
#define SOAP_TYPE_tt__Frame (390)
/* tt:Frame */
class SOAP_CMAC tt__Frame : public xsd__anyType
{
public:
	tt__PTZStatus *PTZStatus;	/* optional element of type tt:PTZStatus */
	tt__Transformation *Transformation;	/* optional element of type tt:Transformation */
	std::vector<class tt__Object * >Object;	/* optional element of type tt:Object */
	class tt__ObjectTree *ObjectTree;	/* optional element of type tt:ObjectTree */
	class tt__FrameExtension *Extension;	/* optional element of type tt:FrameExtension */
	time_t UtcTime;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 390; } /* = unique id SOAP_TYPE_tt__Frame */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Frame(): PTZStatus(NULL), Transformation(NULL), ObjectTree(NULL), Extension(NULL), __anyAttribute(NULL) { tt__Frame::soap_default(NULL); }
	virtual ~tt__Frame() { }
};
#endif

#ifndef SOAP_TYPE_tt__FrameExtension
#define SOAP_TYPE_tt__FrameExtension (391)
/* tt:FrameExtension */
class SOAP_CMAC tt__FrameExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 391; } /* = unique id SOAP_TYPE_tt__FrameExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FrameExtension() { tt__FrameExtension::soap_default(NULL); }
	virtual ~tt__FrameExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Merge
#define SOAP_TYPE_tt__Merge (392)
/* tt:Merge */
class SOAP_CMAC tt__Merge : public xsd__anyType
{
public:
	std::vector<class tt__ObjectId * >from;	/* required element of type tt:ObjectId */
	tt__ObjectId *to;	/* required element of type tt:ObjectId */
public:
	virtual int soap_type() const { return 392; } /* = unique id SOAP_TYPE_tt__Merge */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Merge(): to(NULL) { tt__Merge::soap_default(NULL); }
	virtual ~tt__Merge() { }
};
#endif

#ifndef SOAP_TYPE_tt__Split
#define SOAP_TYPE_tt__Split (393)
/* tt:Split */
class SOAP_CMAC tt__Split : public xsd__anyType
{
public:
	tt__ObjectId *from;	/* required element of type tt:ObjectId */
	std::vector<tt__ObjectId * >to;	/* required element of type tt:ObjectId */
public:
	virtual int soap_type() const { return 393; } /* = unique id SOAP_TYPE_tt__Split */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Split(): from(NULL) { tt__Split::soap_default(NULL); }
	virtual ~tt__Split() { }
};
#endif

#ifndef SOAP_TYPE_tt__Rename
#define SOAP_TYPE_tt__Rename (394)
/* tt:Rename */
class SOAP_CMAC tt__Rename : public xsd__anyType
{
public:
	tt__ObjectId *from;	/* required element of type tt:ObjectId */
	tt__ObjectId *to;	/* required element of type tt:ObjectId */
public:
	virtual int soap_type() const { return 394; } /* = unique id SOAP_TYPE_tt__Rename */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Rename(): from(NULL), to(NULL) { tt__Rename::soap_default(NULL); }
	virtual ~tt__Rename() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectId
#define SOAP_TYPE_tt__ObjectId (395)
/* Primitive tt:ObjectId schema type: */
class SOAP_CMAC tt__ObjectId : public xsd__anyType
{
public:
	std::string *ObjectId;	/* optional attribute */
public:
	virtual int soap_type() const { return 395; } /* = unique id SOAP_TYPE_tt__ObjectId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectId(): ObjectId(NULL) { tt__ObjectId::soap_default(NULL); }
	virtual ~tt__ObjectId() { }
};
#endif

#ifndef SOAP_TYPE__tt__Behaviour_Removed
#define SOAP_TYPE__tt__Behaviour_Removed (1087)
/* tt:Behaviour-Removed */
class SOAP_CMAC _tt__Behaviour_Removed
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1087; } /* = unique id SOAP_TYPE__tt__Behaviour_Removed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__Behaviour_Removed() { _tt__Behaviour_Removed::soap_default(NULL); }
	virtual ~_tt__Behaviour_Removed() { }
};
#endif

#ifndef SOAP_TYPE__tt__Behaviour_Idle
#define SOAP_TYPE__tt__Behaviour_Idle (1089)
/* tt:Behaviour-Idle */
class SOAP_CMAC _tt__Behaviour_Idle
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1089; } /* = unique id SOAP_TYPE__tt__Behaviour_Idle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__Behaviour_Idle() { _tt__Behaviour_Idle::soap_default(NULL); }
	virtual ~_tt__Behaviour_Idle() { }
};
#endif

#ifndef SOAP_TYPE_tt__Behaviour
#define SOAP_TYPE_tt__Behaviour (396)
/* tt:Behaviour */
class SOAP_CMAC tt__Behaviour : public xsd__anyType
{
public:
	_tt__Behaviour_Removed *Removed;	/* optional element of type tt:Behaviour-Removed */
	_tt__Behaviour_Idle *Idle;	/* optional element of type tt:Behaviour-Idle */
	class tt__BehaviourExtension *Extension;	/* optional element of type tt:BehaviourExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 396; } /* = unique id SOAP_TYPE_tt__Behaviour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Behaviour(): Removed(NULL), Idle(NULL), Extension(NULL), __anyAttribute(NULL) { tt__Behaviour::soap_default(NULL); }
	virtual ~tt__Behaviour() { }
};
#endif

#ifndef SOAP_TYPE_tt__BehaviourExtension
#define SOAP_TYPE_tt__BehaviourExtension (397)
/* tt:BehaviourExtension */
class SOAP_CMAC tt__BehaviourExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 397; } /* = unique id SOAP_TYPE_tt__BehaviourExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BehaviourExtension() { tt__BehaviourExtension::soap_default(NULL); }
	virtual ~tt__BehaviourExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectTree
#define SOAP_TYPE_tt__ObjectTree (398)
/* tt:ObjectTree */
class SOAP_CMAC tt__ObjectTree : public xsd__anyType
{
public:
	std::vector<tt__Rename * >Rename;	/* optional element of type tt:Rename */
	std::vector<tt__Split * >Split;	/* optional element of type tt:Split */
	std::vector<tt__Merge * >Merge;	/* optional element of type tt:Merge */
	std::vector<tt__ObjectId * >Delete;	/* optional element of type tt:ObjectId */
	class tt__ObjectTreeExtension *Extension;	/* optional element of type tt:ObjectTreeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 398; } /* = unique id SOAP_TYPE_tt__ObjectTree */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectTree(): Extension(NULL), __anyAttribute(NULL) { tt__ObjectTree::soap_default(NULL); }
	virtual ~tt__ObjectTree() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectTreeExtension
#define SOAP_TYPE_tt__ObjectTreeExtension (399)
/* tt:ObjectTreeExtension */
class SOAP_CMAC tt__ObjectTreeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 399; } /* = unique id SOAP_TYPE_tt__ObjectTreeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectTreeExtension() { tt__ObjectTreeExtension::soap_default(NULL); }
	virtual ~tt__ObjectTreeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (400)
/* tt:AnalyticsEngineConfiguration */
class SOAP_CMAC tt__AnalyticsEngineConfiguration : public xsd__anyType
{
public:
	std::vector<tt__Config * >AnalyticsModule;	/* optional element of type tt:Config */
	class tt__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of type tt:AnalyticsEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 400; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineConfiguration(): Extension(NULL), __anyAttribute(NULL) { tt__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (401)
/* tt:AnalyticsEngineConfigurationExtension */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 401; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineConfigurationExtension() { tt__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (402)
/* tt:RuleEngineConfiguration */
class SOAP_CMAC tt__RuleEngineConfiguration : public xsd__anyType
{
public:
	std::vector<tt__Config * >Rule;	/* optional element of type tt:Config */
	class tt__RuleEngineConfigurationExtension *Extension;	/* optional element of type tt:RuleEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 402; } /* = unique id SOAP_TYPE_tt__RuleEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RuleEngineConfiguration(): Extension(NULL), __anyAttribute(NULL) { tt__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~tt__RuleEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (403)
/* tt:RuleEngineConfigurationExtension */
class SOAP_CMAC tt__RuleEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 403; } /* = unique id SOAP_TYPE_tt__RuleEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RuleEngineConfigurationExtension() { tt__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RuleEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (404)
/* tt:Config */
class SOAP_CMAC tt__Config : public xsd__anyType
{
public:
	tt__ItemList *Parameters;	/* required element of type tt:ItemList */
	std::string Name;	/* required attribute */
	xsd__QName Type;	/* required attribute */
public:
	virtual int soap_type() const { return 404; } /* = unique id SOAP_TYPE_tt__Config */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Config(): Parameters(NULL) { tt__Config::soap_default(NULL); }
	virtual ~tt__Config() { }
};
#endif

#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (1102)
/* tt:ConfigDescription-Messages */
class SOAP_CMAC _tt__ConfigDescription_Messages
{
public:
	tt__ItemListDescription *Source;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	std::string ParentTopic;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 1102; } /* = unique id SOAP_TYPE__tt__ConfigDescription_Messages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ConfigDescription_Messages(): Source(NULL), Key(NULL), Data(NULL), Extension(NULL), IsProperty(NULL), __anyAttribute(NULL) { _tt__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_tt__ConfigDescription_Messages() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (405)
/* tt:ConfigDescription */
class SOAP_CMAC tt__ConfigDescription : public xsd__anyType
{
public:
	tt__ItemListDescription *Parameters;	/* required element of type tt:ItemListDescription */
	int __sizeMessages;	/* sequence of elements <Messages> */
	_tt__ConfigDescription_Messages *Messages;	/* optional element of type tt:ConfigDescription-Messages */
	class tt__ConfigDescriptionExtension *Extension;	/* optional element of type tt:ConfigDescriptionExtension */
	xsd__QName Name;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 405; } /* = unique id SOAP_TYPE_tt__ConfigDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigDescription(): Parameters(NULL), Messages(NULL), Extension(NULL), __anyAttribute(NULL) { tt__ConfigDescription::soap_default(NULL); }
	virtual ~tt__ConfigDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (406)
/* tt:ConfigDescriptionExtension */
class SOAP_CMAC tt__ConfigDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 406; } /* = unique id SOAP_TYPE_tt__ConfigDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigDescriptionExtension() { tt__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ConfigDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (407)
/* tt:SupportedRules */
class SOAP_CMAC tt__SupportedRules : public xsd__anyType
{
public:
	std::vector<std::string >RuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	std::vector<tt__ConfigDescription * >RuleDescription;	/* optional element of type tt:ConfigDescription */
	class tt__SupportedRulesExtension *Extension;	/* optional element of type tt:SupportedRulesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 407; } /* = unique id SOAP_TYPE_tt__SupportedRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedRules(): Extension(NULL), __anyAttribute(NULL) { tt__SupportedRules::soap_default(NULL); }
	virtual ~tt__SupportedRules() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (408)
/* tt:SupportedRulesExtension */
class SOAP_CMAC tt__SupportedRulesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 408; } /* = unique id SOAP_TYPE_tt__SupportedRulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedRulesExtension() { tt__SupportedRulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedRulesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (409)
/* tt:SupportedAnalyticsModules */
class SOAP_CMAC tt__SupportedAnalyticsModules : public xsd__anyType
{
public:
	std::vector<std::string >AnalyticsModuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	std::vector<tt__ConfigDescription * >AnalyticsModuleDescription;	/* optional element of type tt:ConfigDescription */
	class tt__SupportedAnalyticsModulesExtension *Extension;	/* optional element of type tt:SupportedAnalyticsModulesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 409; } /* = unique id SOAP_TYPE_tt__SupportedAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedAnalyticsModules(): Extension(NULL), __anyAttribute(NULL) { tt__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (410)
/* tt:SupportedAnalyticsModulesExtension */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 410; } /* = unique id SOAP_TYPE_tt__SupportedAnalyticsModulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedAnalyticsModulesExtension() { tt__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModulesExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_MetadataStream
#define SOAP_TYPE__tt__union_MetadataStream (1115)
/* xsd:choice */
union _tt__union_MetadataStream
{
#define SOAP_UNION__tt__union_MetadataStream_VideoAnalytics	(1)
	class tt__VideoAnalyticsStream *VideoAnalytics;
#define SOAP_UNION__tt__union_MetadataStream_PTZ	(2)
	class tt__PTZStream *PTZ;
#define SOAP_UNION__tt__union_MetadataStream_Event	(3)
	class tt__EventStream *Event;
#define SOAP_UNION__tt__union_MetadataStream_Extension	(4)
	class tt__MetadataStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_MetadataStream
#define SOAP_TYPE___tt__union_MetadataStream (1110)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_MetadataStream
{
public:
	int __union_MetadataStream;	/* union discriminant (of union defined below) */
	union _tt__union_MetadataStream union_MetadataStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1110; } /* = unique id SOAP_TYPE___tt__union_MetadataStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_MetadataStream() { __tt__union_MetadataStream::soap_default(NULL); }
	virtual ~__tt__union_MetadataStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataStream
#define SOAP_TYPE_tt__MetadataStream (411)
/* tt:MetadataStream */
class SOAP_CMAC tt__MetadataStream : public xsd__anyType
{
public:
	int __size_MetadataStream;	/* sequence of elements <-union-MetadataStream> */
	__tt__union_MetadataStream *__union_MetadataStream;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 411; } /* = unique id SOAP_TYPE_tt__MetadataStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataStream(): __union_MetadataStream(NULL), __anyAttribute(NULL) { tt__MetadataStream::soap_default(NULL); }
	virtual ~tt__MetadataStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataStreamExtension
#define SOAP_TYPE_tt__MetadataStreamExtension (412)
/* tt:MetadataStreamExtension */
class SOAP_CMAC tt__MetadataStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 412; } /* = unique id SOAP_TYPE_tt__MetadataStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataStreamExtension() { tt__MetadataStreamExtension::soap_default(NULL); }
	virtual ~tt__MetadataStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_VideoAnalyticsStream
#define SOAP_TYPE__tt__union_VideoAnalyticsStream (1120)
/* xsd:choice */
union _tt__union_VideoAnalyticsStream
{
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Frame	(1)
	tt__Frame *Frame;
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Extension	(2)
	class tt__VideoAnalyticsStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_VideoAnalyticsStream
#define SOAP_TYPE___tt__union_VideoAnalyticsStream (1117)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_VideoAnalyticsStream
{
public:
	int __union_VideoAnalyticsStream;	/* union discriminant (of union defined below) */
	union _tt__union_VideoAnalyticsStream union_VideoAnalyticsStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1117; } /* = unique id SOAP_TYPE___tt__union_VideoAnalyticsStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_VideoAnalyticsStream() { __tt__union_VideoAnalyticsStream::soap_default(NULL); }
	virtual ~__tt__union_VideoAnalyticsStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsStream
#define SOAP_TYPE_tt__VideoAnalyticsStream (413)
/* tt:VideoAnalyticsStream */
class SOAP_CMAC tt__VideoAnalyticsStream : public xsd__anyType
{
public:
	int __size_VideoAnalyticsStream;	/* sequence of elements <-union-VideoAnalyticsStream> */
	__tt__union_VideoAnalyticsStream *__union_VideoAnalyticsStream;
public:
	virtual int soap_type() const { return 413; } /* = unique id SOAP_TYPE_tt__VideoAnalyticsStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAnalyticsStream(): __union_VideoAnalyticsStream(NULL) { tt__VideoAnalyticsStream::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsStreamExtension
#define SOAP_TYPE_tt__VideoAnalyticsStreamExtension (414)
/* tt:VideoAnalyticsStreamExtension */
class SOAP_CMAC tt__VideoAnalyticsStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 414; } /* = unique id SOAP_TYPE_tt__VideoAnalyticsStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAnalyticsStreamExtension() { tt__VideoAnalyticsStreamExtension::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_PTZStream
#define SOAP_TYPE__tt__union_PTZStream (1124)
/* xsd:choice */
union _tt__union_PTZStream
{
#define SOAP_UNION__tt__union_PTZStream_PTZStatus	(1)
	tt__PTZStatus *PTZStatus;
#define SOAP_UNION__tt__union_PTZStream_Extension	(2)
	class tt__PTZStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_PTZStream
#define SOAP_TYPE___tt__union_PTZStream (1122)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_PTZStream
{
public:
	int __union_PTZStream;	/* union discriminant (of union defined below) */
	union _tt__union_PTZStream union_PTZStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1122; } /* = unique id SOAP_TYPE___tt__union_PTZStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_PTZStream() { __tt__union_PTZStream::soap_default(NULL); }
	virtual ~__tt__union_PTZStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStream
#define SOAP_TYPE_tt__PTZStream (415)
/* tt:PTZStream */
class SOAP_CMAC tt__PTZStream : public xsd__anyType
{
public:
	int __size_PTZStream;	/* sequence of elements <-union-PTZStream> */
	__tt__union_PTZStream *__union_PTZStream;
public:
	virtual int soap_type() const { return 415; } /* = unique id SOAP_TYPE_tt__PTZStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStream(): __union_PTZStream(NULL) { tt__PTZStream::soap_default(NULL); }
	virtual ~tt__PTZStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStreamExtension
#define SOAP_TYPE_tt__PTZStreamExtension (416)
/* tt:PTZStreamExtension */
class SOAP_CMAC tt__PTZStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 416; } /* = unique id SOAP_TYPE_tt__PTZStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStreamExtension() { tt__PTZStreamExtension::soap_default(NULL); }
	virtual ~tt__PTZStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_EventStream
#define SOAP_TYPE__tt__union_EventStream (1129)
/* xsd:choice */
union _tt__union_EventStream
{
#define SOAP_UNION__tt__union_EventStream_ns1__NotificationMessage	(1)
	class ns1__NotificationMessageHolderType *ns1__NotificationMessage;
#define SOAP_UNION__tt__union_EventStream_Extension	(2)
	class tt__EventStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_EventStream
#define SOAP_TYPE___tt__union_EventStream (1126)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_EventStream
{
public:
	int __union_EventStream;	/* union discriminant (of union defined below) */
	union _tt__union_EventStream union_EventStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1126; } /* = unique id SOAP_TYPE___tt__union_EventStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_EventStream() { __tt__union_EventStream::soap_default(NULL); }
	virtual ~__tt__union_EventStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventStream
#define SOAP_TYPE_tt__EventStream (417)
/* tt:EventStream */
class SOAP_CMAC tt__EventStream : public xsd__anyType
{
public:
	int __size_EventStream;	/* sequence of elements <-union-EventStream> */
	__tt__union_EventStream *__union_EventStream;
public:
	virtual int soap_type() const { return 417; } /* = unique id SOAP_TYPE_tt__EventStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventStream(): __union_EventStream(NULL) { tt__EventStream::soap_default(NULL); }
	virtual ~tt__EventStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventStreamExtension
#define SOAP_TYPE_tt__EventStreamExtension (418)
/* tt:EventStreamExtension */
class SOAP_CMAC tt__EventStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 418; } /* = unique id SOAP_TYPE_tt__EventStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventStreamExtension() { tt__EventStreamExtension::soap_default(NULL); }
	virtual ~tt__EventStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (419)
/* tt:Message */
class SOAP_CMAC _tt__Message
{
public:
	tt__ItemList *Source;	/* optional element of type tt:ItemList */
	tt__ItemList *Key;	/* optional element of type tt:ItemList */
	tt__ItemList *Data;	/* optional element of type tt:ItemList */
	tt__MessageExtension *Extension;	/* optional element of type tt:MessageExtension */
	time_t UtcTime;	/* required attribute */
	enum tt__PropertyOperation *PropertyOperation;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 419; } /* = unique id SOAP_TYPE__tt__Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__Message(): Source(NULL), Key(NULL), Data(NULL), Extension(NULL), PropertyOperation(NULL), __anyAttribute(NULL), soap(NULL) { _tt__Message::soap_default(NULL); }
	virtual ~_tt__Message() { }
};
#endif

#ifndef SOAP_TYPE_ns1__QueryExpressionType
#define SOAP_TYPE_ns1__QueryExpressionType (420)
/* ns1:QueryExpressionType */
class SOAP_CMAC ns1__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 420; } /* = unique id SOAP_TYPE_ns1__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__QueryExpressionType(): __any(NULL), __mixed(NULL) { ns1__QueryExpressionType::soap_default(NULL); }
	virtual ~ns1__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TopicExpressionType
#define SOAP_TYPE_ns1__TopicExpressionType (421)
/* ns1:TopicExpressionType */
class SOAP_CMAC ns1__TopicExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 421; } /* = unique id SOAP_TYPE_ns1__TopicExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TopicExpressionType(): __any(NULL), __anyAttribute(NULL), __mixed(NULL) { ns1__TopicExpressionType::soap_default(NULL); }
	virtual ~ns1__TopicExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__FilterType
#define SOAP_TYPE_ns1__FilterType (422)
/* ns1:FilterType */
class SOAP_CMAC ns1__FilterType : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 422; } /* = unique id SOAP_TYPE_ns1__FilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__FilterType() { ns1__FilterType::soap_default(NULL); }
	virtual ~ns1__FilterType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubscriptionPolicyType
#define SOAP_TYPE_ns1__SubscriptionPolicyType (423)
/* ns1:SubscriptionPolicyType */
class SOAP_CMAC ns1__SubscriptionPolicyType : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 423; } /* = unique id SOAP_TYPE_ns1__SubscriptionPolicyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubscriptionPolicyType() { ns1__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~ns1__SubscriptionPolicyType() { }
};
#endif

#ifndef SOAP_TYPE__ns1__NotificationMessageHolderType_Message
#define SOAP_TYPE__ns1__NotificationMessageHolderType_Message (1135)
/* ns1:NotificationMessageHolderType-Message */
class SOAP_CMAC _ns1__NotificationMessageHolderType_Message
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1135; } /* = unique id SOAP_TYPE__ns1__NotificationMessageHolderType_Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__NotificationMessageHolderType_Message(): __any(NULL) { _ns1__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_ns1__NotificationMessageHolderType_Message() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NotificationMessageHolderType
#define SOAP_TYPE_ns1__NotificationMessageHolderType (424)
/* ns1:NotificationMessageHolderType */
class SOAP_CMAC ns1__NotificationMessageHolderType : public xsd__anyType
{
public:
	struct wsa5__EndpointReferenceType *SubscriptionReference;	/* optional element of type wsa5:EndpointReferenceType */
	ns1__TopicExpressionType *Topic;	/* optional element of type ns1:TopicExpressionType */
	struct wsa5__EndpointReferenceType *ProducerReference;	/* optional element of type wsa5:EndpointReferenceType */
	_ns1__NotificationMessageHolderType_Message Message;	/* required element of type ns1:NotificationMessageHolderType-Message */
public:
	virtual int soap_type() const { return 424; } /* = unique id SOAP_TYPE_ns1__NotificationMessageHolderType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NotificationMessageHolderType(): SubscriptionReference(NULL), Topic(NULL), ProducerReference(NULL) { ns1__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~ns1__NotificationMessageHolderType() { }
};
#endif

#ifndef SOAP_TYPE__ns1__NotificationProducerRP
#define SOAP_TYPE__ns1__NotificationProducerRP (445)
/* ns1:NotificationProducerRP */
class SOAP_CMAC _ns1__NotificationProducerRP
{
public:
	std::vector<ns1__TopicExpressionType * >TopicExpression;	/* optional element of type ns1:TopicExpressionType */
	bool *FixedTopicSet;	/* optional element of type xsd:boolean */
	std::vector<std::string >TopicExpressionDialect;	/* optional element of type xsd:anyURI */
	class ns3__TopicSetType *ns3__TopicSet;	/* optional element of type ns3:TopicSetType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 445; } /* = unique id SOAP_TYPE__ns1__NotificationProducerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__NotificationProducerRP(): FixedTopicSet(NULL), ns3__TopicSet(NULL), soap(NULL) { _ns1__NotificationProducerRP::soap_default(NULL); }
	virtual ~_ns1__NotificationProducerRP() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SubscriptionManagerRP
#define SOAP_TYPE__ns1__SubscriptionManagerRP (446)
/* ns1:SubscriptionManagerRP */
class SOAP_CMAC _ns1__SubscriptionManagerRP
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of type wsa5:EndpointReferenceType */
	ns1__FilterType *Filter;	/* optional element of type ns1:FilterType */
	ns1__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of type ns1:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 446; } /* = unique id SOAP_TYPE__ns1__SubscriptionManagerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SubscriptionManagerRP(): Filter(NULL), SubscriptionPolicy(NULL), CreationTime(NULL), soap(NULL) { _ns1__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_ns1__SubscriptionManagerRP() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Notify
#define SOAP_TYPE__ns1__Notify (447)
/* ns1:Notify */
class SOAP_CMAC _ns1__Notify
{
public:
	std::vector<ns1__NotificationMessageHolderType * >NotificationMessage;	/* required element of type ns1:NotificationMessageHolderType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 447; } /* = unique id SOAP_TYPE__ns1__Notify */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Notify(): soap(NULL) { _ns1__Notify::soap_default(NULL); }
	virtual ~_ns1__Notify() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UseRaw
#define SOAP_TYPE__ns1__UseRaw (448)
/* ns1:UseRaw */
class SOAP_CMAC _ns1__UseRaw
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 448; } /* = unique id SOAP_TYPE__ns1__UseRaw */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UseRaw(): soap(NULL) { _ns1__UseRaw::soap_default(NULL); }
	virtual ~_ns1__UseRaw() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__ns1__Subscribe_SubscriptionPolicy (1142)
/* ns1:Subscribe-SubscriptionPolicy */
class SOAP_CMAC _ns1__Subscribe_SubscriptionPolicy
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1142; } /* = unique id SOAP_TYPE__ns1__Subscribe_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Subscribe_SubscriptionPolicy() { _ns1__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_ns1__Subscribe_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Subscribe
#define SOAP_TYPE__ns1__Subscribe (449)
/* ns1:Subscribe */
class SOAP_CMAC _ns1__Subscribe
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of type wsa5:EndpointReferenceType */
	ns1__FilterType *Filter;	/* optional element of type ns1:FilterType */
	std::string *InitialTerminationTime;	/* optional element of type ns1:AbsoluteOrRelativeTimeType */
	_ns1__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type ns1:Subscribe-SubscriptionPolicy */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 449; } /* = unique id SOAP_TYPE__ns1__Subscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Subscribe(): Filter(NULL), InitialTerminationTime(NULL), SubscriptionPolicy(NULL), soap(NULL) { _ns1__Subscribe::soap_default(NULL); }
	virtual ~_ns1__Subscribe() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SubscribeResponse
#define SOAP_TYPE__ns1__SubscribeResponse (450)
/* ns1:SubscribeResponse */
class SOAP_CMAC _ns1__SubscribeResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type wsa5:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of type xsd:dateTime */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 450; } /* = unique id SOAP_TYPE__ns1__SubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SubscribeResponse(): CurrentTime(NULL), TerminationTime(NULL), soap(NULL) { _ns1__SubscribeResponse::soap_default(NULL); }
	virtual ~_ns1__SubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCurrentMessage
#define SOAP_TYPE__ns1__GetCurrentMessage (451)
/* ns1:GetCurrentMessage */
class SOAP_CMAC _ns1__GetCurrentMessage
{
public:
	ns1__TopicExpressionType *Topic;	/* required element of type ns1:TopicExpressionType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 451; } /* = unique id SOAP_TYPE__ns1__GetCurrentMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCurrentMessage(): Topic(NULL), soap(NULL) { _ns1__GetCurrentMessage::soap_default(NULL); }
	virtual ~_ns1__GetCurrentMessage() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCurrentMessageResponse
#define SOAP_TYPE__ns1__GetCurrentMessageResponse (452)
/* ns1:GetCurrentMessageResponse */
class SOAP_CMAC _ns1__GetCurrentMessageResponse
{
public:
	std::vector<char * >__any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 452; } /* = unique id SOAP_TYPE__ns1__GetCurrentMessageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCurrentMessageResponse(): soap(NULL) { _ns1__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_ns1__GetCurrentMessageResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMessages
#define SOAP_TYPE__ns1__GetMessages (453)
/* ns1:GetMessages */
class SOAP_CMAC _ns1__GetMessages
{
public:
	std::string *MaximumNumber;	/* optional element of type xsd:nonNegativeInteger */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 453; } /* = unique id SOAP_TYPE__ns1__GetMessages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMessages(): MaximumNumber(NULL), __anyAttribute(NULL), soap(NULL) { _ns1__GetMessages::soap_default(NULL); }
	virtual ~_ns1__GetMessages() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMessagesResponse
#define SOAP_TYPE__ns1__GetMessagesResponse (454)
/* ns1:GetMessagesResponse */
class SOAP_CMAC _ns1__GetMessagesResponse
{
public:
	std::vector<ns1__NotificationMessageHolderType * >NotificationMessage;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:NotificationMessageHolderType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 454; } /* = unique id SOAP_TYPE__ns1__GetMessagesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMessagesResponse(): __anyAttribute(NULL), soap(NULL) { _ns1__GetMessagesResponse::soap_default(NULL); }
	virtual ~_ns1__GetMessagesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DestroyPullPoint
#define SOAP_TYPE__ns1__DestroyPullPoint (455)
/* ns1:DestroyPullPoint */
class SOAP_CMAC _ns1__DestroyPullPoint
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 455; } /* = unique id SOAP_TYPE__ns1__DestroyPullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DestroyPullPoint(): __anyAttribute(NULL), soap(NULL) { _ns1__DestroyPullPoint::soap_default(NULL); }
	virtual ~_ns1__DestroyPullPoint() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DestroyPullPointResponse
#define SOAP_TYPE__ns1__DestroyPullPointResponse (456)
/* ns1:DestroyPullPointResponse */
class SOAP_CMAC _ns1__DestroyPullPointResponse
{
public:
	std::vector<char * >__any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 456; } /* = unique id SOAP_TYPE__ns1__DestroyPullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DestroyPullPointResponse(): __anyAttribute(NULL), soap(NULL) { _ns1__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_ns1__DestroyPullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreatePullPoint
#define SOAP_TYPE__ns1__CreatePullPoint (457)
/* ns1:CreatePullPoint */
class SOAP_CMAC _ns1__CreatePullPoint
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 457; } /* = unique id SOAP_TYPE__ns1__CreatePullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreatePullPoint(): __anyAttribute(NULL), soap(NULL) { _ns1__CreatePullPoint::soap_default(NULL); }
	virtual ~_ns1__CreatePullPoint() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreatePullPointResponse
#define SOAP_TYPE__ns1__CreatePullPointResponse (458)
/* ns1:CreatePullPointResponse */
class SOAP_CMAC _ns1__CreatePullPointResponse
{
public:
	struct wsa5__EndpointReferenceType PullPoint;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type wsa5:EndpointReferenceType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 458; } /* = unique id SOAP_TYPE__ns1__CreatePullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreatePullPointResponse(): __anyAttribute(NULL), soap(NULL) { _ns1__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_ns1__CreatePullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Renew
#define SOAP_TYPE__ns1__Renew (459)
/* ns1:Renew */
class SOAP_CMAC _ns1__Renew
{
public:
	std::string *TerminationTime;	/* required element of type ns1:AbsoluteOrRelativeTimeType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 459; } /* = unique id SOAP_TYPE__ns1__Renew */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Renew(): TerminationTime(NULL), soap(NULL) { _ns1__Renew::soap_default(NULL); }
	virtual ~_ns1__Renew() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RenewResponse
#define SOAP_TYPE__ns1__RenewResponse (460)
/* ns1:RenewResponse */
class SOAP_CMAC _ns1__RenewResponse
{
public:
	time_t TerminationTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 460; } /* = unique id SOAP_TYPE__ns1__RenewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RenewResponse(): CurrentTime(NULL), soap(NULL) { _ns1__RenewResponse::soap_default(NULL); }
	virtual ~_ns1__RenewResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Unsubscribe
#define SOAP_TYPE__ns1__Unsubscribe (461)
/* ns1:Unsubscribe */
class SOAP_CMAC _ns1__Unsubscribe
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 461; } /* = unique id SOAP_TYPE__ns1__Unsubscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Unsubscribe(): soap(NULL) { _ns1__Unsubscribe::soap_default(NULL); }
	virtual ~_ns1__Unsubscribe() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UnsubscribeResponse
#define SOAP_TYPE__ns1__UnsubscribeResponse (462)
/* ns1:UnsubscribeResponse */
class SOAP_CMAC _ns1__UnsubscribeResponse
{
public:
	std::vector<char * >__any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 462; } /* = unique id SOAP_TYPE__ns1__UnsubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UnsubscribeResponse(): soap(NULL) { _ns1__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_ns1__UnsubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PauseSubscription
#define SOAP_TYPE__ns1__PauseSubscription (463)
/* ns1:PauseSubscription */
class SOAP_CMAC _ns1__PauseSubscription
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 463; } /* = unique id SOAP_TYPE__ns1__PauseSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PauseSubscription(): soap(NULL) { _ns1__PauseSubscription::soap_default(NULL); }
	virtual ~_ns1__PauseSubscription() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PauseSubscriptionResponse
#define SOAP_TYPE__ns1__PauseSubscriptionResponse (464)
/* ns1:PauseSubscriptionResponse */
class SOAP_CMAC _ns1__PauseSubscriptionResponse
{
public:
	std::vector<char * >__any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 464; } /* = unique id SOAP_TYPE__ns1__PauseSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PauseSubscriptionResponse(): soap(NULL) { _ns1__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_ns1__PauseSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ResumeSubscription
#define SOAP_TYPE__ns1__ResumeSubscription (465)
/* ns1:ResumeSubscription */
class SOAP_CMAC _ns1__ResumeSubscription
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 465; } /* = unique id SOAP_TYPE__ns1__ResumeSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ResumeSubscription(): soap(NULL) { _ns1__ResumeSubscription::soap_default(NULL); }
	virtual ~_ns1__ResumeSubscription() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ResumeSubscriptionResponse
#define SOAP_TYPE__ns1__ResumeSubscriptionResponse (466)
/* ns1:ResumeSubscriptionResponse */
class SOAP_CMAC _ns1__ResumeSubscriptionResponse
{
public:
	std::vector<char * >__any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 466; } /* = unique id SOAP_TYPE__ns1__ResumeSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ResumeSubscriptionResponse(): soap(NULL) { _ns1__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_ns1__ResumeSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__BaseFaultType_ErrorCode
#define SOAP_TYPE__ns2__BaseFaultType_ErrorCode (1145)
/* ns2:BaseFaultType-ErrorCode */
class SOAP_CMAC _ns2__BaseFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1145; } /* = unique id SOAP_TYPE__ns2__BaseFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__BaseFaultType_ErrorCode() { _ns2__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns2__BaseFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns2__BaseFaultType_Description
#define SOAP_TYPE__ns2__BaseFaultType_Description (1147)
/* Primitive ns2:BaseFaultType-Description schema type: */
class SOAP_CMAC _ns2__BaseFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1147; } /* = unique id SOAP_TYPE__ns2__BaseFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__BaseFaultType_Description(): xml__lang(NULL) { _ns2__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_ns2__BaseFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns2__BaseFaultType_FaultCause
#define SOAP_TYPE__ns2__BaseFaultType_FaultCause (1150)
/* ns2:BaseFaultType-FaultCause */
class SOAP_CMAC _ns2__BaseFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1150; } /* = unique id SOAP_TYPE__ns2__BaseFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__BaseFaultType_FaultCause(): __any(NULL) { _ns2__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns2__BaseFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BaseFaultType
#define SOAP_TYPE_ns2__BaseFaultType (467)
/* ns2:BaseFaultType */
class SOAP_CMAC ns2__BaseFaultType : public xsd__anyType
{
public:
	std::vector<char * >__any;
	time_t Timestamp;	/* required element of type xsd:dateTime */
	struct wsa5__EndpointReferenceType *Originator;	/* optional element of type wsa5:EndpointReferenceType */
	_ns2__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of type ns2:BaseFaultType-ErrorCode */
	int __sizeDescription;	/* sequence of elements <Description> */
	_ns2__BaseFaultType_Description *Description;	/* optional element of type ns2:BaseFaultType-Description */
	_ns2__BaseFaultType_FaultCause *FaultCause;	/* optional element of type ns2:BaseFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 467; } /* = unique id SOAP_TYPE_ns2__BaseFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BaseFaultType(): Originator(NULL), ErrorCode(NULL), Description(NULL), FaultCause(NULL), __anyAttribute(NULL) { ns2__BaseFaultType::soap_default(NULL); }
	virtual ~ns2__BaseFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Documentation
#define SOAP_TYPE_ns3__Documentation (468)
/* ns3:Documentation */
class SOAP_CMAC ns3__Documentation : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__mixed;
public:
	virtual int soap_type() const { return 468; } /* = unique id SOAP_TYPE_ns3__Documentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Documentation(): __mixed(NULL) { ns3__Documentation::soap_default(NULL); }
	virtual ~ns3__Documentation() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ExtensibleDocumented
#define SOAP_TYPE_ns3__ExtensibleDocumented (469)
/* ns3:ExtensibleDocumented */
class SOAP_CMAC ns3__ExtensibleDocumented : public xsd__anyType
{
public:
	ns3__Documentation *documentation;	/* optional element of type ns3:Documentation */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 469; } /* = unique id SOAP_TYPE_ns3__ExtensibleDocumented */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ExtensibleDocumented(): documentation(NULL), __anyAttribute(NULL) { ns3__ExtensibleDocumented::soap_default(NULL); }
	virtual ~ns3__ExtensibleDocumented() { }
};
#endif

#ifndef SOAP_TYPE_ns3__QueryExpressionType
#define SOAP_TYPE_ns3__QueryExpressionType (470)
/* ns3:QueryExpressionType */
class SOAP_CMAC ns3__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 470; } /* = unique id SOAP_TYPE_ns3__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__QueryExpressionType(): __any(NULL), __mixed(NULL) { ns3__QueryExpressionType::soap_default(NULL); }
	virtual ~ns3__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (474)
/* tds:GetDeviceInformation */
class SOAP_CMAC _tds__GetDeviceInformation
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 474; } /* = unique id SOAP_TYPE__tds__GetDeviceInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDeviceInformation(): soap(NULL) { _tds__GetDeviceInformation::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformation() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (475)
/* tds:GetDeviceInformationResponse */
class SOAP_CMAC _tds__GetDeviceInformationResponse
{
public:
	std::string Manufacturer;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	std::string Model;	/* required element of type xsd:string */
	std::string FirmwareVersion;	/* required element of type xsd:string */
	std::string SerialNumber;	/* required element of type xsd:string */
	std::string HardwareId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 475; } /* = unique id SOAP_TYPE__tds__GetDeviceInformationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDeviceInformationResponse(): soap(NULL) { _tds__GetDeviceInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (476)
/* tds:SetSystemDateAndTime */
class SOAP_CMAC _tds__SetSystemDateAndTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of type tt:DateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 476; } /* = unique id SOAP_TYPE__tds__SetSystemDateAndTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetSystemDateAndTime(): TimeZone(NULL), UTCDateTime(NULL), soap(NULL) { _tds__SetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTime() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (477)
/* tds:SetSystemDateAndTimeResponse */
class SOAP_CMAC _tds__SetSystemDateAndTimeResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 477; } /* = unique id SOAP_TYPE__tds__SetSystemDateAndTimeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetSystemDateAndTimeResponse(): soap(NULL) { _tds__SetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTimeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (478)
/* tds:GetSystemDateAndTime */
class SOAP_CMAC _tds__GetSystemDateAndTime
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 478; } /* = unique id SOAP_TYPE__tds__GetSystemDateAndTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemDateAndTime(): soap(NULL) { _tds__GetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTime() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (479)
/* tds:GetSystemDateAndTimeResponse */
class SOAP_CMAC _tds__GetSystemDateAndTimeResponse
{
public:
	tt__SystemDateTime *SystemDateAndTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:SystemDateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 479; } /* = unique id SOAP_TYPE__tds__GetSystemDateAndTimeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemDateAndTimeResponse(): SystemDateAndTime(NULL), soap(NULL) { _tds__GetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTimeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (480)
/* tds:SetSystemFactoryDefault */
class SOAP_CMAC _tds__SetSystemFactoryDefault
{
public:
	enum tt__FactoryDefaultType FactoryDefault;	/* required element of type tt:FactoryDefaultType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 480; } /* = unique id SOAP_TYPE__tds__SetSystemFactoryDefault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetSystemFactoryDefault(): soap(NULL) { _tds__SetSystemFactoryDefault::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefault() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (481)
/* tds:SetSystemFactoryDefaultResponse */
class SOAP_CMAC _tds__SetSystemFactoryDefaultResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 481; } /* = unique id SOAP_TYPE__tds__SetSystemFactoryDefaultResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetSystemFactoryDefaultResponse(): soap(NULL) { _tds__SetSystemFactoryDefaultResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefaultResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (482)
/* tds:UpgradeSystemFirmware */
class SOAP_CMAC _tds__UpgradeSystemFirmware
{
public:
	tt__AttachmentData *Firmware;	/* required element of type tt:AttachmentData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 482; } /* = unique id SOAP_TYPE__tds__UpgradeSystemFirmware */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__UpgradeSystemFirmware(): Firmware(NULL), soap(NULL) { _tds__UpgradeSystemFirmware::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmware() { }
};
#endif

#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (483)
/* tds:UpgradeSystemFirmwareResponse */
class SOAP_CMAC _tds__UpgradeSystemFirmwareResponse
{
public:
	std::string *Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 483; } /* = unique id SOAP_TYPE__tds__UpgradeSystemFirmwareResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__UpgradeSystemFirmwareResponse(): Message(NULL), soap(NULL) { _tds__UpgradeSystemFirmwareResponse::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmwareResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (484)
/* tds:SystemReboot */
class SOAP_CMAC _tds__SystemReboot
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 484; } /* = unique id SOAP_TYPE__tds__SystemReboot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SystemReboot(): soap(NULL) { _tds__SystemReboot::soap_default(NULL); }
	virtual ~_tds__SystemReboot() { }
};
#endif

#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (485)
/* tds:SystemRebootResponse */
class SOAP_CMAC _tds__SystemRebootResponse
{
public:
	std::string Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 485; } /* = unique id SOAP_TYPE__tds__SystemRebootResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SystemRebootResponse(): soap(NULL) { _tds__SystemRebootResponse::soap_default(NULL); }
	virtual ~_tds__SystemRebootResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (486)
/* tds:RestoreSystem */
class SOAP_CMAC _tds__RestoreSystem
{
public:
	std::vector<tt__BackupFile * >BackupFiles;	/* required element of type tt:BackupFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 486; } /* = unique id SOAP_TYPE__tds__RestoreSystem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__RestoreSystem(): soap(NULL) { _tds__RestoreSystem::soap_default(NULL); }
	virtual ~_tds__RestoreSystem() { }
};
#endif

#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (487)
/* tds:RestoreSystemResponse */
class SOAP_CMAC _tds__RestoreSystemResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 487; } /* = unique id SOAP_TYPE__tds__RestoreSystemResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__RestoreSystemResponse(): soap(NULL) { _tds__RestoreSystemResponse::soap_default(NULL); }
	virtual ~_tds__RestoreSystemResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (488)
/* tds:GetSystemBackup */
class SOAP_CMAC _tds__GetSystemBackup
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 488; } /* = unique id SOAP_TYPE__tds__GetSystemBackup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemBackup(): soap(NULL) { _tds__GetSystemBackup::soap_default(NULL); }
	virtual ~_tds__GetSystemBackup() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (489)
/* tds:GetSystemBackupResponse */
class SOAP_CMAC _tds__GetSystemBackupResponse
{
public:
	std::vector<tt__BackupFile * >BackupFiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:BackupFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 489; } /* = unique id SOAP_TYPE__tds__GetSystemBackupResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemBackupResponse(): soap(NULL) { _tds__GetSystemBackupResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemBackupResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (490)
/* tds:GetSystemSupportInformation */
class SOAP_CMAC _tds__GetSystemSupportInformation
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 490; } /* = unique id SOAP_TYPE__tds__GetSystemSupportInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemSupportInformation(): soap(NULL) { _tds__GetSystemSupportInformation::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformation() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (491)
/* tds:GetSystemSupportInformationResponse */
class SOAP_CMAC _tds__GetSystemSupportInformationResponse
{
public:
	tt__SupportInformation *SupportInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:SupportInformation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 491; } /* = unique id SOAP_TYPE__tds__GetSystemSupportInformationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemSupportInformationResponse(): SupportInformation(NULL), soap(NULL) { _tds__GetSystemSupportInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (492)
/* tds:GetSystemLog */
class SOAP_CMAC _tds__GetSystemLog
{
public:
	enum tt__SystemLogType LogType;	/* required element of type tt:SystemLogType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 492; } /* = unique id SOAP_TYPE__tds__GetSystemLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemLog(): soap(NULL) { _tds__GetSystemLog::soap_default(NULL); }
	virtual ~_tds__GetSystemLog() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (493)
/* tds:GetSystemLogResponse */
class SOAP_CMAC _tds__GetSystemLogResponse
{
public:
	tt__SystemLog *SystemLog;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:SystemLog */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 493; } /* = unique id SOAP_TYPE__tds__GetSystemLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetSystemLogResponse(): SystemLog(NULL), soap(NULL) { _tds__GetSystemLogResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemLogResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (494)
/* tds:GetScopes */
class SOAP_CMAC _tds__GetScopes
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 494; } /* = unique id SOAP_TYPE__tds__GetScopes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetScopes(): soap(NULL) { _tds__GetScopes::soap_default(NULL); }
	virtual ~_tds__GetScopes() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (495)
/* tds:GetScopesResponse */
class SOAP_CMAC _tds__GetScopesResponse
{
public:
	std::vector<tt__Scope * >Scopes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:Scope */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 495; } /* = unique id SOAP_TYPE__tds__GetScopesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetScopesResponse(): soap(NULL) { _tds__GetScopesResponse::soap_default(NULL); }
	virtual ~_tds__GetScopesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (496)
/* tds:SetScopes */
class SOAP_CMAC _tds__SetScopes
{
public:
	std::vector<std::string >Scopes;	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 496; } /* = unique id SOAP_TYPE__tds__SetScopes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetScopes(): soap(NULL) { _tds__SetScopes::soap_default(NULL); }
	virtual ~_tds__SetScopes() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (497)
/* tds:SetScopesResponse */
class SOAP_CMAC _tds__SetScopesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 497; } /* = unique id SOAP_TYPE__tds__SetScopesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetScopesResponse(): soap(NULL) { _tds__SetScopesResponse::soap_default(NULL); }
	virtual ~_tds__SetScopesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (498)
/* tds:AddScopes */
class SOAP_CMAC _tds__AddScopes
{
public:
	std::vector<std::string >ScopeItem;	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 498; } /* = unique id SOAP_TYPE__tds__AddScopes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__AddScopes(): soap(NULL) { _tds__AddScopes::soap_default(NULL); }
	virtual ~_tds__AddScopes() { }
};
#endif

#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (499)
/* tds:AddScopesResponse */
class SOAP_CMAC _tds__AddScopesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 499; } /* = unique id SOAP_TYPE__tds__AddScopesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__AddScopesResponse(): soap(NULL) { _tds__AddScopesResponse::soap_default(NULL); }
	virtual ~_tds__AddScopesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (500)
/* tds:RemoveScopes */
class SOAP_CMAC _tds__RemoveScopes
{
public:
	std::vector<std::string >ScopeItem;	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 500; } /* = unique id SOAP_TYPE__tds__RemoveScopes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__RemoveScopes(): soap(NULL) { _tds__RemoveScopes::soap_default(NULL); }
	virtual ~_tds__RemoveScopes() { }
};
#endif

#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (501)
/* tds:RemoveScopesResponse */
class SOAP_CMAC _tds__RemoveScopesResponse
{
public:
	std::vector<std::string >ScopeItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 501; } /* = unique id SOAP_TYPE__tds__RemoveScopesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__RemoveScopesResponse(): soap(NULL) { _tds__RemoveScopesResponse::soap_default(NULL); }
	virtual ~_tds__RemoveScopesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (502)
/* tds:GetDiscoveryMode */
class SOAP_CMAC _tds__GetDiscoveryMode
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 502; } /* = unique id SOAP_TYPE__tds__GetDiscoveryMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDiscoveryMode(): soap(NULL) { _tds__GetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryMode() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (503)
/* tds:GetDiscoveryModeResponse */
class SOAP_CMAC _tds__GetDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:DiscoveryMode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 503; } /* = unique id SOAP_TYPE__tds__GetDiscoveryModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDiscoveryModeResponse(): soap(NULL) { _tds__GetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (504)
/* tds:SetDiscoveryMode */
class SOAP_CMAC _tds__SetDiscoveryMode
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* required element of type tt:DiscoveryMode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 504; } /* = unique id SOAP_TYPE__tds__SetDiscoveryMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDiscoveryMode(): soap(NULL) { _tds__SetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryMode() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (505)
/* tds:SetDiscoveryModeResponse */
class SOAP_CMAC _tds__SetDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 505; } /* = unique id SOAP_TYPE__tds__SetDiscoveryModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDiscoveryModeResponse(): soap(NULL) { _tds__SetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (506)
/* tds:GetRemoteDiscoveryMode */
class SOAP_CMAC _tds__GetRemoteDiscoveryMode
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 506; } /* = unique id SOAP_TYPE__tds__GetRemoteDiscoveryMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetRemoteDiscoveryMode(): soap(NULL) { _tds__GetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryMode() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (507)
/* tds:GetRemoteDiscoveryModeResponse */
class SOAP_CMAC _tds__GetRemoteDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:DiscoveryMode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 507; } /* = unique id SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetRemoteDiscoveryModeResponse(): soap(NULL) { _tds__GetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (508)
/* tds:SetRemoteDiscoveryMode */
class SOAP_CMAC _tds__SetRemoteDiscoveryMode
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* required element of type tt:DiscoveryMode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 508; } /* = unique id SOAP_TYPE__tds__SetRemoteDiscoveryMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetRemoteDiscoveryMode(): soap(NULL) { _tds__SetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryMode() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (509)
/* tds:SetRemoteDiscoveryModeResponse */
class SOAP_CMAC _tds__SetRemoteDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 509; } /* = unique id SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetRemoteDiscoveryModeResponse(): soap(NULL) { _tds__SetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (510)
/* tds:GetDPAddresses */
class SOAP_CMAC _tds__GetDPAddresses
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 510; } /* = unique id SOAP_TYPE__tds__GetDPAddresses */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDPAddresses(): soap(NULL) { _tds__GetDPAddresses::soap_default(NULL); }
	virtual ~_tds__GetDPAddresses() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (511)
/* tds:GetDPAddressesResponse */
class SOAP_CMAC _tds__GetDPAddressesResponse
{
public:
	std::vector<tt__NetworkHost * >DPAddress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:NetworkHost */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 511; } /* = unique id SOAP_TYPE__tds__GetDPAddressesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDPAddressesResponse(): soap(NULL) { _tds__GetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__GetDPAddressesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (512)
/* tds:SetDPAddresses */
class SOAP_CMAC _tds__SetDPAddresses
{
public:
	std::vector<tt__NetworkHost * >DPAddress;	/* optional element of type tt:NetworkHost */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 512; } /* = unique id SOAP_TYPE__tds__SetDPAddresses */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDPAddresses(): soap(NULL) { _tds__SetDPAddresses::soap_default(NULL); }
	virtual ~_tds__SetDPAddresses() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (513)
/* tds:SetDPAddressesResponse */
class SOAP_CMAC _tds__SetDPAddressesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 513; } /* = unique id SOAP_TYPE__tds__SetDPAddressesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDPAddressesResponse(): soap(NULL) { _tds__SetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__SetDPAddressesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (514)
/* tds:GetUsers */
class SOAP_CMAC _tds__GetUsers
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 514; } /* = unique id SOAP_TYPE__tds__GetUsers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetUsers(): soap(NULL) { _tds__GetUsers::soap_default(NULL); }
	virtual ~_tds__GetUsers() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (515)
/* tds:GetUsersResponse */
class SOAP_CMAC _tds__GetUsersResponse
{
public:
	std::vector<tt__User * >User;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:User */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 515; } /* = unique id SOAP_TYPE__tds__GetUsersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetUsersResponse(): soap(NULL) { _tds__GetUsersResponse::soap_default(NULL); }
	virtual ~_tds__GetUsersResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (516)
/* tds:CreateUsers */
class SOAP_CMAC _tds__CreateUsers
{
public:
	std::vector<tt__User * >User;	/* required element of type tt:User */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 516; } /* = unique id SOAP_TYPE__tds__CreateUsers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__CreateUsers(): soap(NULL) { _tds__CreateUsers::soap_default(NULL); }
	virtual ~_tds__CreateUsers() { }
};
#endif

#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (517)
/* tds:CreateUsersResponse */
class SOAP_CMAC _tds__CreateUsersResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 517; } /* = unique id SOAP_TYPE__tds__CreateUsersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__CreateUsersResponse(): soap(NULL) { _tds__CreateUsersResponse::soap_default(NULL); }
	virtual ~_tds__CreateUsersResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (518)
/* tds:DeleteUsers */
class SOAP_CMAC _tds__DeleteUsers
{
public:
	std::vector<std::string >Username;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 518; } /* = unique id SOAP_TYPE__tds__DeleteUsers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__DeleteUsers(): soap(NULL) { _tds__DeleteUsers::soap_default(NULL); }
	virtual ~_tds__DeleteUsers() { }
};
#endif

#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (519)
/* tds:DeleteUsersResponse */
class SOAP_CMAC _tds__DeleteUsersResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 519; } /* = unique id SOAP_TYPE__tds__DeleteUsersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__DeleteUsersResponse(): soap(NULL) { _tds__DeleteUsersResponse::soap_default(NULL); }
	virtual ~_tds__DeleteUsersResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (520)
/* tds:SetUser */
class SOAP_CMAC _tds__SetUser
{
public:
	std::vector<tt__User * >User;	/* required element of type tt:User */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 520; } /* = unique id SOAP_TYPE__tds__SetUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetUser(): soap(NULL) { _tds__SetUser::soap_default(NULL); }
	virtual ~_tds__SetUser() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (521)
/* tds:SetUserResponse */
class SOAP_CMAC _tds__SetUserResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 521; } /* = unique id SOAP_TYPE__tds__SetUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetUserResponse(): soap(NULL) { _tds__SetUserResponse::soap_default(NULL); }
	virtual ~_tds__SetUserResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (522)
/* tds:GetWsdlUrl */
class SOAP_CMAC _tds__GetWsdlUrl
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 522; } /* = unique id SOAP_TYPE__tds__GetWsdlUrl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetWsdlUrl(): soap(NULL) { _tds__GetWsdlUrl::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrl() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (523)
/* tds:GetWsdlUrlResponse */
class SOAP_CMAC _tds__GetWsdlUrlResponse
{
public:
	std::string WsdlUrl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 523; } /* = unique id SOAP_TYPE__tds__GetWsdlUrlResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetWsdlUrlResponse(): soap(NULL) { _tds__GetWsdlUrlResponse::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrlResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (524)
/* tds:GetCapabilities */
class SOAP_CMAC _tds__GetCapabilities
{
public:
	std::vector<enum tt__CapabilityCategory >Category;	/* optional element of type tt:CapabilityCategory */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 524; } /* = unique id SOAP_TYPE__tds__GetCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetCapabilities(): soap(NULL) { _tds__GetCapabilities::soap_default(NULL); }
	virtual ~_tds__GetCapabilities() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (525)
/* tds:GetCapabilitiesResponse */
class SOAP_CMAC _tds__GetCapabilitiesResponse
{
public:
	tt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:Capabilities */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 525; } /* = unique id SOAP_TYPE__tds__GetCapabilitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetCapabilitiesResponse(): Capabilities(NULL), soap(NULL) { _tds__GetCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetCapabilitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (526)
/* tds:GetHostname */
class SOAP_CMAC _tds__GetHostname
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 526; } /* = unique id SOAP_TYPE__tds__GetHostname */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetHostname(): soap(NULL) { _tds__GetHostname::soap_default(NULL); }
	virtual ~_tds__GetHostname() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (527)
/* tds:GetHostnameResponse */
class SOAP_CMAC _tds__GetHostnameResponse
{
public:
	tt__HostnameInformation *HostnameInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:HostnameInformation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 527; } /* = unique id SOAP_TYPE__tds__GetHostnameResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetHostnameResponse(): HostnameInformation(NULL), soap(NULL) { _tds__GetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__GetHostnameResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (528)
/* tds:SetHostname */
class SOAP_CMAC _tds__SetHostname
{
public:
	std::string Name;	/* required element of type xsd:token */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 528; } /* = unique id SOAP_TYPE__tds__SetHostname */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetHostname(): soap(NULL) { _tds__SetHostname::soap_default(NULL); }
	virtual ~_tds__SetHostname() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (529)
/* tds:SetHostnameResponse */
class SOAP_CMAC _tds__SetHostnameResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 529; } /* = unique id SOAP_TYPE__tds__SetHostnameResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetHostnameResponse(): soap(NULL) { _tds__SetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (530)
/* tds:GetDNS */
class SOAP_CMAC _tds__GetDNS
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 530; } /* = unique id SOAP_TYPE__tds__GetDNS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDNS(): soap(NULL) { _tds__GetDNS::soap_default(NULL); }
	virtual ~_tds__GetDNS() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (531)
/* tds:GetDNSResponse */
class SOAP_CMAC _tds__GetDNSResponse
{
public:
	tt__DNSInformation *DNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:DNSInformation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 531; } /* = unique id SOAP_TYPE__tds__GetDNSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDNSResponse(): DNSInformation(NULL), soap(NULL) { _tds__GetDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDNSResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (532)
/* tds:SetDNS */
class SOAP_CMAC _tds__SetDNS
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<std::string >SearchDomain;	/* optional element of type xsd:token */
	std::vector<tt__IPAddress * >DNSManual;	/* optional element of type tt:IPAddress */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 532; } /* = unique id SOAP_TYPE__tds__SetDNS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDNS(): soap(NULL) { _tds__SetDNS::soap_default(NULL); }
	virtual ~_tds__SetDNS() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (533)
/* tds:SetDNSResponse */
class SOAP_CMAC _tds__SetDNSResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 533; } /* = unique id SOAP_TYPE__tds__SetDNSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDNSResponse(): soap(NULL) { _tds__SetDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDNSResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (534)
/* tds:GetNTP */
class SOAP_CMAC _tds__GetNTP
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 534; } /* = unique id SOAP_TYPE__tds__GetNTP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNTP(): soap(NULL) { _tds__GetNTP::soap_default(NULL); }
	virtual ~_tds__GetNTP() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (535)
/* tds:GetNTPResponse */
class SOAP_CMAC _tds__GetNTPResponse
{
public:
	tt__NTPInformation *NTPInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:NTPInformation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 535; } /* = unique id SOAP_TYPE__tds__GetNTPResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNTPResponse(): NTPInformation(NULL), soap(NULL) { _tds__GetNTPResponse::soap_default(NULL); }
	virtual ~_tds__GetNTPResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (536)
/* tds:SetNTP */
class SOAP_CMAC _tds__SetNTP
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<tt__NetworkHost * >NTPManual;	/* optional element of type tt:NetworkHost */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 536; } /* = unique id SOAP_TYPE__tds__SetNTP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNTP(): soap(NULL) { _tds__SetNTP::soap_default(NULL); }
	virtual ~_tds__SetNTP() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (537)
/* tds:SetNTPResponse */
class SOAP_CMAC _tds__SetNTPResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 537; } /* = unique id SOAP_TYPE__tds__SetNTPResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNTPResponse(): soap(NULL) { _tds__SetNTPResponse::soap_default(NULL); }
	virtual ~_tds__SetNTPResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (538)
/* tds:GetDynamicDNS */
class SOAP_CMAC _tds__GetDynamicDNS
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 538; } /* = unique id SOAP_TYPE__tds__GetDynamicDNS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDynamicDNS(): soap(NULL) { _tds__GetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNS() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (539)
/* tds:GetDynamicDNSResponse */
class SOAP_CMAC _tds__GetDynamicDNSResponse
{
public:
	tt__DynamicDNSInformation *DynamicDNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:DynamicDNSInformation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 539; } /* = unique id SOAP_TYPE__tds__GetDynamicDNSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetDynamicDNSResponse(): DynamicDNSInformation(NULL), soap(NULL) { _tds__GetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNSResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (540)
/* tds:SetDynamicDNS */
class SOAP_CMAC _tds__SetDynamicDNS
{
public:
	enum tt__DynamicDNSType Type;	/* required element of type tt:DynamicDNSType */
	std::string *Name;	/* optional element of type tt:DNSName */
	LONG64 *TTL;	/* optional element of type xsd:duration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 540; } /* = unique id SOAP_TYPE__tds__SetDynamicDNS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDynamicDNS(): Name(NULL), TTL(NULL), soap(NULL) { _tds__SetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNS() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (541)
/* tds:SetDynamicDNSResponse */
class SOAP_CMAC _tds__SetDynamicDNSResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 541; } /* = unique id SOAP_TYPE__tds__SetDynamicDNSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetDynamicDNSResponse(): soap(NULL) { _tds__SetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNSResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (542)
/* tds:GetNetworkInterfaces */
class SOAP_CMAC _tds__GetNetworkInterfaces
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 542; } /* = unique id SOAP_TYPE__tds__GetNetworkInterfaces */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNetworkInterfaces(): soap(NULL) { _tds__GetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfaces() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (543)
/* tds:GetNetworkInterfacesResponse */
class SOAP_CMAC _tds__GetNetworkInterfacesResponse
{
public:
	std::vector<class tt__NetworkInterface * >NetworkInterfaces;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:NetworkInterface */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 543; } /* = unique id SOAP_TYPE__tds__GetNetworkInterfacesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNetworkInterfacesResponse(): soap(NULL) { _tds__GetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfacesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (544)
/* tds:SetNetworkInterfaces */
class SOAP_CMAC _tds__SetNetworkInterfaces
{
public:
	std::string InterfaceToken;	/* required element of type tt:ReferenceToken */
	tt__NetworkInterfaceSetConfiguration *NetworkInterface;	/* required element of type tt:NetworkInterfaceSetConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 544; } /* = unique id SOAP_TYPE__tds__SetNetworkInterfaces */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNetworkInterfaces(): NetworkInterface(NULL), soap(NULL) { _tds__SetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfaces() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (545)
/* tds:SetNetworkInterfacesResponse */
class SOAP_CMAC _tds__SetNetworkInterfacesResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 545; } /* = unique id SOAP_TYPE__tds__SetNetworkInterfacesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNetworkInterfacesResponse(): soap(NULL) { _tds__SetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfacesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (546)
/* tds:GetNetworkProtocols */
class SOAP_CMAC _tds__GetNetworkProtocols
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 546; } /* = unique id SOAP_TYPE__tds__GetNetworkProtocols */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNetworkProtocols(): soap(NULL) { _tds__GetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocols() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (547)
/* tds:GetNetworkProtocolsResponse */
class SOAP_CMAC _tds__GetNetworkProtocolsResponse
{
public:
	std::vector<tt__NetworkProtocol * >NetworkProtocols;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:NetworkProtocol */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 547; } /* = unique id SOAP_TYPE__tds__GetNetworkProtocolsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNetworkProtocolsResponse(): soap(NULL) { _tds__GetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocolsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (548)
/* tds:SetNetworkProtocols */
class SOAP_CMAC _tds__SetNetworkProtocols
{
public:
	std::vector<tt__NetworkProtocol * >NetworkProtocols;	/* required element of type tt:NetworkProtocol */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 548; } /* = unique id SOAP_TYPE__tds__SetNetworkProtocols */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNetworkProtocols(): soap(NULL) { _tds__SetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocols() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (549)
/* tds:SetNetworkProtocolsResponse */
class SOAP_CMAC _tds__SetNetworkProtocolsResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 549; } /* = unique id SOAP_TYPE__tds__SetNetworkProtocolsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNetworkProtocolsResponse(): soap(NULL) { _tds__SetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocolsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (550)
/* tds:GetNetworkDefaultGateway */
class SOAP_CMAC _tds__GetNetworkDefaultGateway
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 550; } /* = unique id SOAP_TYPE__tds__GetNetworkDefaultGateway */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNetworkDefaultGateway(): soap(NULL) { _tds__GetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGateway() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (551)
/* tds:GetNetworkDefaultGatewayResponse */
class SOAP_CMAC _tds__GetNetworkDefaultGatewayResponse
{
public:
	tt__NetworkGateway *NetworkGateway;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:NetworkGateway */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 551; } /* = unique id SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetNetworkDefaultGatewayResponse(): NetworkGateway(NULL), soap(NULL) { _tds__GetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGatewayResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (552)
/* tds:SetNetworkDefaultGateway */
class SOAP_CMAC _tds__SetNetworkDefaultGateway
{
public:
	std::vector<std::string >IPv4Address;	/* optional element of type tt:IPv4Address */
	std::vector<std::string >IPv6Address;	/* optional element of type tt:IPv6Address */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 552; } /* = unique id SOAP_TYPE__tds__SetNetworkDefaultGateway */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNetworkDefaultGateway(): soap(NULL) { _tds__SetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGateway() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (553)
/* tds:SetNetworkDefaultGatewayResponse */
class SOAP_CMAC _tds__SetNetworkDefaultGatewayResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 553; } /* = unique id SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetNetworkDefaultGatewayResponse(): soap(NULL) { _tds__SetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGatewayResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (554)
/* tds:GetZeroConfiguration */
class SOAP_CMAC _tds__GetZeroConfiguration
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 554; } /* = unique id SOAP_TYPE__tds__GetZeroConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetZeroConfiguration(): soap(NULL) { _tds__GetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__GetZeroConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (555)
/* tds:GetZeroConfigurationResponse */
class SOAP_CMAC _tds__GetZeroConfigurationResponse
{
public:
	tt__NetworkZeroConfiguration *ZeroConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:NetworkZeroConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 555; } /* = unique id SOAP_TYPE__tds__GetZeroConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetZeroConfigurationResponse(): ZeroConfiguration(NULL), soap(NULL) { _tds__GetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetZeroConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (556)
/* tds:SetZeroConfiguration */
class SOAP_CMAC _tds__SetZeroConfiguration
{
public:
	std::string InterfaceToken;	/* required element of type tt:ReferenceToken */
	bool Enabled;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 556; } /* = unique id SOAP_TYPE__tds__SetZeroConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetZeroConfiguration(): soap(NULL) { _tds__SetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__SetZeroConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (557)
/* tds:SetZeroConfigurationResponse */
class SOAP_CMAC _tds__SetZeroConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 557; } /* = unique id SOAP_TYPE__tds__SetZeroConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetZeroConfigurationResponse(): soap(NULL) { _tds__SetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetZeroConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (558)
/* tds:GetIPAddressFilter */
class SOAP_CMAC _tds__GetIPAddressFilter
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 558; } /* = unique id SOAP_TYPE__tds__GetIPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetIPAddressFilter(): soap(NULL) { _tds__GetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (559)
/* tds:GetIPAddressFilterResponse */
class SOAP_CMAC _tds__GetIPAddressFilterResponse
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:IPAddressFilter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 559; } /* = unique id SOAP_TYPE__tds__GetIPAddressFilterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetIPAddressFilterResponse(): IPAddressFilter(NULL), soap(NULL) { _tds__GetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilterResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (560)
/* tds:SetIPAddressFilter */
class SOAP_CMAC _tds__SetIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of type tt:IPAddressFilter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 560; } /* = unique id SOAP_TYPE__tds__SetIPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetIPAddressFilter(): IPAddressFilter(NULL), soap(NULL) { _tds__SetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (561)
/* tds:SetIPAddressFilterResponse */
class SOAP_CMAC _tds__SetIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 561; } /* = unique id SOAP_TYPE__tds__SetIPAddressFilterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetIPAddressFilterResponse(): soap(NULL) { _tds__SetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilterResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (562)
/* tds:AddIPAddressFilter */
class SOAP_CMAC _tds__AddIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of type tt:IPAddressFilter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 562; } /* = unique id SOAP_TYPE__tds__AddIPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__AddIPAddressFilter(): IPAddressFilter(NULL), soap(NULL) { _tds__AddIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (563)
/* tds:AddIPAddressFilterResponse */
class SOAP_CMAC _tds__AddIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 563; } /* = unique id SOAP_TYPE__tds__AddIPAddressFilterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__AddIPAddressFilterResponse(): soap(NULL) { _tds__AddIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilterResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (564)
/* tds:RemoveIPAddressFilter */
class SOAP_CMAC _tds__RemoveIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of type tt:IPAddressFilter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 564; } /* = unique id SOAP_TYPE__tds__RemoveIPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__RemoveIPAddressFilter(): IPAddressFilter(NULL), soap(NULL) { _tds__RemoveIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (565)
/* tds:RemoveIPAddressFilterResponse */
class SOAP_CMAC _tds__RemoveIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 565; } /* = unique id SOAP_TYPE__tds__RemoveIPAddressFilterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__RemoveIPAddressFilterResponse(): soap(NULL) { _tds__RemoveIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilterResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (566)
/* tds:GetAccessPolicy */
class SOAP_CMAC _tds__GetAccessPolicy
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 566; } /* = unique id SOAP_TYPE__tds__GetAccessPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetAccessPolicy(): soap(NULL) { _tds__GetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicy() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (567)
/* tds:GetAccessPolicyResponse */
class SOAP_CMAC _tds__GetAccessPolicyResponse
{
public:
	tt__BinaryData *PolicyFile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:BinaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 567; } /* = unique id SOAP_TYPE__tds__GetAccessPolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetAccessPolicyResponse(): PolicyFile(NULL), soap(NULL) { _tds__GetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (568)
/* tds:SetAccessPolicy */
class SOAP_CMAC _tds__SetAccessPolicy
{
public:
	tt__BinaryData *PolicyFile;	/* required element of type tt:BinaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 568; } /* = unique id SOAP_TYPE__tds__SetAccessPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetAccessPolicy(): PolicyFile(NULL), soap(NULL) { _tds__SetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicy() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (569)
/* tds:SetAccessPolicyResponse */
class SOAP_CMAC _tds__SetAccessPolicyResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 569; } /* = unique id SOAP_TYPE__tds__SetAccessPolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetAccessPolicyResponse(): soap(NULL) { _tds__SetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (570)
/* tds:CreateCertificate */
class SOAP_CMAC _tds__CreateCertificate
{
public:
	std::string *CertificateID;	/* optional element of type xsd:token */
	std::string *Subject;	/* optional element of type xsd:string */
	time_t *ValidNotBefore;	/* optional element of type xsd:dateTime */
	time_t *ValidNotAfter;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 570; } /* = unique id SOAP_TYPE__tds__CreateCertificate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__CreateCertificate(): CertificateID(NULL), Subject(NULL), ValidNotBefore(NULL), ValidNotAfter(NULL), soap(NULL) { _tds__CreateCertificate::soap_default(NULL); }
	virtual ~_tds__CreateCertificate() { }
};
#endif

#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (571)
/* tds:CreateCertificateResponse */
class SOAP_CMAC _tds__CreateCertificateResponse
{
public:
	tt__Certificate *NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:Certificate */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 571; } /* = unique id SOAP_TYPE__tds__CreateCertificateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__CreateCertificateResponse(): NvtCertificate(NULL), soap(NULL) { _tds__CreateCertificateResponse::soap_default(NULL); }
	virtual ~_tds__CreateCertificateResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (572)
/* tds:GetCertificates */
class SOAP_CMAC _tds__GetCertificates
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 572; } /* = unique id SOAP_TYPE__tds__GetCertificates */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetCertificates(): soap(NULL) { _tds__GetCertificates::soap_default(NULL); }
	virtual ~_tds__GetCertificates() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (573)
/* tds:GetCertificatesResponse */
class SOAP_CMAC _tds__GetCertificatesResponse
{
public:
	std::vector<tt__Certificate * >NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:Certificate */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 573; } /* = unique id SOAP_TYPE__tds__GetCertificatesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetCertificatesResponse(): soap(NULL) { _tds__GetCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (574)
/* tds:GetCertificatesStatus */
class SOAP_CMAC _tds__GetCertificatesStatus
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 574; } /* = unique id SOAP_TYPE__tds__GetCertificatesStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetCertificatesStatus(): soap(NULL) { _tds__GetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatus() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (575)
/* tds:GetCertificatesStatusResponse */
class SOAP_CMAC _tds__GetCertificatesStatusResponse
{
public:
	std::vector<tt__CertificateStatus * >CertificateStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:CertificateStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 575; } /* = unique id SOAP_TYPE__tds__GetCertificatesStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetCertificatesStatusResponse(): soap(NULL) { _tds__GetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (576)
/* tds:SetCertificatesStatus */
class SOAP_CMAC _tds__SetCertificatesStatus
{
public:
	std::vector<tt__CertificateStatus * >CertificateStatus;	/* optional element of type tt:CertificateStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 576; } /* = unique id SOAP_TYPE__tds__SetCertificatesStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetCertificatesStatus(): soap(NULL) { _tds__SetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatus() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (577)
/* tds:SetCertificatesStatusResponse */
class SOAP_CMAC _tds__SetCertificatesStatusResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 577; } /* = unique id SOAP_TYPE__tds__SetCertificatesStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetCertificatesStatusResponse(): soap(NULL) { _tds__SetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (578)
/* tds:DeleteCertificates */
class SOAP_CMAC _tds__DeleteCertificates
{
public:
	std::vector<std::string >CertificateID;	/* required element of type xsd:token */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 578; } /* = unique id SOAP_TYPE__tds__DeleteCertificates */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__DeleteCertificates(): soap(NULL) { _tds__DeleteCertificates::soap_default(NULL); }
	virtual ~_tds__DeleteCertificates() { }
};
#endif

#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (579)
/* tds:DeleteCertificatesResponse */
class SOAP_CMAC _tds__DeleteCertificatesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 579; } /* = unique id SOAP_TYPE__tds__DeleteCertificatesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__DeleteCertificatesResponse(): soap(NULL) { _tds__DeleteCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__DeleteCertificatesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (580)
/* tds:GetPkcs10Request */
class SOAP_CMAC _tds__GetPkcs10Request
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	std::string *Subject;	/* optional element of type xsd:string */
	tt__BinaryData *Attributes;	/* optional element of type tt:BinaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 580; } /* = unique id SOAP_TYPE__tds__GetPkcs10Request */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetPkcs10Request(): Subject(NULL), Attributes(NULL), soap(NULL) { _tds__GetPkcs10Request::soap_default(NULL); }
	virtual ~_tds__GetPkcs10Request() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (581)
/* tds:GetPkcs10RequestResponse */
class SOAP_CMAC _tds__GetPkcs10RequestResponse
{
public:
	tt__BinaryData *Pkcs10Request;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:BinaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 581; } /* = unique id SOAP_TYPE__tds__GetPkcs10RequestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetPkcs10RequestResponse(): Pkcs10Request(NULL), soap(NULL) { _tds__GetPkcs10RequestResponse::soap_default(NULL); }
	virtual ~_tds__GetPkcs10RequestResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (582)
/* tds:LoadCertificates */
class SOAP_CMAC _tds__LoadCertificates
{
public:
	std::vector<tt__Certificate * >NVTCertificate;	/* required element of type tt:Certificate */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 582; } /* = unique id SOAP_TYPE__tds__LoadCertificates */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__LoadCertificates(): soap(NULL) { _tds__LoadCertificates::soap_default(NULL); }
	virtual ~_tds__LoadCertificates() { }
};
#endif

#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (583)
/* tds:LoadCertificatesResponse */
class SOAP_CMAC _tds__LoadCertificatesResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 583; } /* = unique id SOAP_TYPE__tds__LoadCertificatesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__LoadCertificatesResponse(): soap(NULL) { _tds__LoadCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificatesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (584)
/* tds:GetClientCertificateMode */
class SOAP_CMAC _tds__GetClientCertificateMode
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 584; } /* = unique id SOAP_TYPE__tds__GetClientCertificateMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetClientCertificateMode(): soap(NULL) { _tds__GetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateMode() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (585)
/* tds:GetClientCertificateModeResponse */
class SOAP_CMAC _tds__GetClientCertificateModeResponse
{
public:
	bool Enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 585; } /* = unique id SOAP_TYPE__tds__GetClientCertificateModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetClientCertificateModeResponse(): soap(NULL) { _tds__GetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (586)
/* tds:SetClientCertificateMode */
class SOAP_CMAC _tds__SetClientCertificateMode
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 586; } /* = unique id SOAP_TYPE__tds__SetClientCertificateMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetClientCertificateMode(): soap(NULL) { _tds__SetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateMode() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (587)
/* tds:SetClientCertificateModeResponse */
class SOAP_CMAC _tds__SetClientCertificateModeResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 587; } /* = unique id SOAP_TYPE__tds__SetClientCertificateModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetClientCertificateModeResponse(): soap(NULL) { _tds__SetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (588)
/* tds:GetRelayOutputs */
class SOAP_CMAC _tds__GetRelayOutputs
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 588; } /* = unique id SOAP_TYPE__tds__GetRelayOutputs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetRelayOutputs(): soap(NULL) { _tds__GetRelayOutputs::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputs() { }
};
#endif

#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (589)
/* tds:GetRelayOutputsResponse */
class SOAP_CMAC _tds__GetRelayOutputsResponse
{
public:
	std::vector<class tt__RelayOutput * >RelayOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:RelayOutput */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 589; } /* = unique id SOAP_TYPE__tds__GetRelayOutputsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__GetRelayOutputsResponse(): soap(NULL) { _tds__GetRelayOutputsResponse::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (590)
/* tds:SetRelayOutputSettings */
class SOAP_CMAC _tds__SetRelayOutputSettings
{
public:
	std::string RelayOutputToken;	/* required element of type tt:ReferenceToken */
	tt__RelayOutputSettings *Properties;	/* required element of type tt:RelayOutputSettings */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 590; } /* = unique id SOAP_TYPE__tds__SetRelayOutputSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetRelayOutputSettings(): Properties(NULL), soap(NULL) { _tds__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettings() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (591)
/* tds:SetRelayOutputSettingsResponse */
class SOAP_CMAC _tds__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 591; } /* = unique id SOAP_TYPE__tds__SetRelayOutputSettingsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetRelayOutputSettingsResponse(): soap(NULL) { _tds__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettingsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (592)
/* tds:SetRelayOutputState */
class SOAP_CMAC _tds__SetRelayOutputState
{
public:
	std::string RelayOutputToken;	/* required element of type tt:ReferenceToken */
	enum tt__RelayLogicalState LogicalState;	/* required element of type tt:RelayLogicalState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 592; } /* = unique id SOAP_TYPE__tds__SetRelayOutputState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetRelayOutputState(): soap(NULL) { _tds__SetRelayOutputState::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputState() { }
};
#endif

#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (593)
/* tds:SetRelayOutputStateResponse */
class SOAP_CMAC _tds__SetRelayOutputStateResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 593; } /* = unique id SOAP_TYPE__tds__SetRelayOutputStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tds__SetRelayOutputStateResponse(): soap(NULL) { _tds__SetRelayOutputStateResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputStateResponse() { }
};
#endif

#ifndef SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (1183)
/* tev:CreatePullPointSubscription-SubscriptionPolicy */
class SOAP_CMAC _tev__CreatePullPointSubscription_SubscriptionPolicy
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1183; } /* = unique id SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__CreatePullPointSubscription_SubscriptionPolicy() { _tev__CreatePullPointSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscription_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE__tev__CreatePullPointSubscription
#define SOAP_TYPE__tev__CreatePullPointSubscription (594)
/* tev:CreatePullPointSubscription */
class SOAP_CMAC _tev__CreatePullPointSubscription
{
public:
	ns1__FilterType *Filter;	/* optional element of type ns1:FilterType */
	std::string *InitialTerminationTime;	/* optional element of type ns1:AbsoluteOrRelativeTimeType */
	_tev__CreatePullPointSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type tev:CreatePullPointSubscription-SubscriptionPolicy */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 594; } /* = unique id SOAP_TYPE__tev__CreatePullPointSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__CreatePullPointSubscription(): Filter(NULL), InitialTerminationTime(NULL), SubscriptionPolicy(NULL), soap(NULL) { _tev__CreatePullPointSubscription::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscription() { }
};
#endif

#ifndef SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
#define SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (595)
/* tev:CreatePullPointSubscriptionResponse */
class SOAP_CMAC _tev__CreatePullPointSubscriptionResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type wsa5:EndpointReferenceType */
	time_t ns1__CurrentTime;	/* required element of type xsd:dateTime */
	time_t ns1__TerminationTime;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 595; } /* = unique id SOAP_TYPE__tev__CreatePullPointSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__CreatePullPointSubscriptionResponse(): soap(NULL) { _tev__CreatePullPointSubscriptionResponse::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE__tev__PullMessages
#define SOAP_TYPE__tev__PullMessages (596)
/* tev:PullMessages */
class SOAP_CMAC _tev__PullMessages
{
public:
	LONG64 Timeout;	/* external */
	int MessageLimit;	/* required element of type xsd:int */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 596; } /* = unique id SOAP_TYPE__tev__PullMessages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__PullMessages(): soap(NULL) { _tev__PullMessages::soap_default(NULL); }
	virtual ~_tev__PullMessages() { }
};
#endif

#ifndef SOAP_TYPE__tev__PullMessagesResponse
#define SOAP_TYPE__tev__PullMessagesResponse (597)
/* tev:PullMessagesResponse */
class SOAP_CMAC _tev__PullMessagesResponse
{
public:
	time_t CurrentTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:dateTime */
	time_t TerminationTime;	/* required element of type xsd:dateTime */
	std::vector<ns1__NotificationMessageHolderType * >ns1__NotificationMessage;	/* optional element of type ns1:NotificationMessageHolderType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 597; } /* = unique id SOAP_TYPE__tev__PullMessagesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__PullMessagesResponse(): soap(NULL) { _tev__PullMessagesResponse::soap_default(NULL); }
	virtual ~_tev__PullMessagesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tev__PullMessagesFaultResponse
#define SOAP_TYPE__tev__PullMessagesFaultResponse (598)
/* tev:PullMessagesFaultResponse */
class SOAP_CMAC _tev__PullMessagesFaultResponse
{
public:
	LONG64 MaxTimeout;	/* external */
	int MaxMessageLimit;	/* required element of type xsd:int */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 598; } /* = unique id SOAP_TYPE__tev__PullMessagesFaultResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__PullMessagesFaultResponse(): soap(NULL) { _tev__PullMessagesFaultResponse::soap_default(NULL); }
	virtual ~_tev__PullMessagesFaultResponse() { }
};
#endif

#ifndef SOAP_TYPE__tev__SetSynchronizationPoint
#define SOAP_TYPE__tev__SetSynchronizationPoint (599)
/* tev:SetSynchronizationPoint */
class SOAP_CMAC _tev__SetSynchronizationPoint
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 599; } /* = unique id SOAP_TYPE__tev__SetSynchronizationPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__SetSynchronizationPoint(): soap(NULL) { _tev__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_tev__SetSynchronizationPoint() { }
};
#endif

#ifndef SOAP_TYPE__tev__SetSynchronizationPointResponse
#define SOAP_TYPE__tev__SetSynchronizationPointResponse (600)
/* tev:SetSynchronizationPointResponse */
class SOAP_CMAC _tev__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 600; } /* = unique id SOAP_TYPE__tev__SetSynchronizationPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__SetSynchronizationPointResponse(): soap(NULL) { _tev__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_tev__SetSynchronizationPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__tev__GetEventProperties
#define SOAP_TYPE__tev__GetEventProperties (601)
/* tev:GetEventProperties */
class SOAP_CMAC _tev__GetEventProperties
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 601; } /* = unique id SOAP_TYPE__tev__GetEventProperties */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__GetEventProperties(): soap(NULL) { _tev__GetEventProperties::soap_default(NULL); }
	virtual ~_tev__GetEventProperties() { }
};
#endif

#ifndef SOAP_TYPE__tev__GetEventPropertiesResponse
#define SOAP_TYPE__tev__GetEventPropertiesResponse (602)
/* tev:GetEventPropertiesResponse */
class SOAP_CMAC _tev__GetEventPropertiesResponse
{
public:
	std::vector<std::string >TopicNamespaceLocation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:anyURI */
	bool ns1__FixedTopicSet;	/* required element of type xsd:boolean */
	ns3__TopicSetType *ns3__TopicSet;	/* required element of type ns3:TopicSetType */
	std::vector<std::string >ns1__TopicExpressionDialect;	/* required element of type xsd:anyURI */
	std::vector<std::string >MessageContentFilterDialect;	/* required element of type xsd:anyURI */
	std::vector<std::string >ProducerPropertiesFilterDialect;	/* optional element of type xsd:anyURI */
	std::vector<std::string >MessageContentSchemaLocation;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 602; } /* = unique id SOAP_TYPE__tev__GetEventPropertiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tev__GetEventPropertiesResponse(): ns3__TopicSet(NULL), soap(NULL) { _tev__GetEventPropertiesResponse::soap_default(NULL); }
	virtual ~_tev__GetEventPropertiesResponse() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetImagingSettings
#define SOAP_TYPE__timg__GetImagingSettings (605)
/* timg:GetImagingSettings */
class SOAP_CMAC _timg__GetImagingSettings
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 605; } /* = unique id SOAP_TYPE__timg__GetImagingSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetImagingSettings(): soap(NULL) { _timg__GetImagingSettings::soap_default(NULL); }
	virtual ~_timg__GetImagingSettings() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse
#define SOAP_TYPE__timg__GetImagingSettingsResponse (606)
/* timg:GetImagingSettingsResponse */
class SOAP_CMAC _timg__GetImagingSettingsResponse
{
public:
	tt__ImagingSettings20 *ImagingSettings;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ImagingSettings20 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 606; } /* = unique id SOAP_TYPE__timg__GetImagingSettingsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetImagingSettingsResponse(): ImagingSettings(NULL), soap(NULL) { _timg__GetImagingSettingsResponse::soap_default(NULL); }
	virtual ~_timg__GetImagingSettingsResponse() { }
};
#endif

#ifndef SOAP_TYPE__timg__SetImagingSettings
#define SOAP_TYPE__timg__SetImagingSettings (607)
/* timg:SetImagingSettings */
class SOAP_CMAC _timg__SetImagingSettings
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	tt__ImagingSettings20 *ImagingSettings;	/* required element of type tt:ImagingSettings20 */
	bool *ForcePersistence_x0020;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 607; } /* = unique id SOAP_TYPE__timg__SetImagingSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__SetImagingSettings(): ImagingSettings(NULL), ForcePersistence_x0020(NULL), soap(NULL) { _timg__SetImagingSettings::soap_default(NULL); }
	virtual ~_timg__SetImagingSettings() { }
};
#endif

#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse
#define SOAP_TYPE__timg__SetImagingSettingsResponse (608)
/* timg:SetImagingSettingsResponse */
class SOAP_CMAC _timg__SetImagingSettingsResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 608; } /* = unique id SOAP_TYPE__timg__SetImagingSettingsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__SetImagingSettingsResponse(): soap(NULL) { _timg__SetImagingSettingsResponse::soap_default(NULL); }
	virtual ~_timg__SetImagingSettingsResponse() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetOptions
#define SOAP_TYPE__timg__GetOptions (609)
/* timg:GetOptions */
class SOAP_CMAC _timg__GetOptions
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 609; } /* = unique id SOAP_TYPE__timg__GetOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetOptions(): soap(NULL) { _timg__GetOptions::soap_default(NULL); }
	virtual ~_timg__GetOptions() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetOptionsResponse
#define SOAP_TYPE__timg__GetOptionsResponse (610)
/* timg:GetOptionsResponse */
class SOAP_CMAC _timg__GetOptionsResponse
{
public:
	tt__ImagingOptions20 *ImagingOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ImagingOptions20 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 610; } /* = unique id SOAP_TYPE__timg__GetOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetOptionsResponse(): ImagingOptions(NULL), soap(NULL) { _timg__GetOptionsResponse::soap_default(NULL); }
	virtual ~_timg__GetOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__timg__Move
#define SOAP_TYPE__timg__Move (611)
/* timg:Move */
class SOAP_CMAC _timg__Move
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	tt__FocusMove *Focus;	/* required element of type tt:FocusMove */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 611; } /* = unique id SOAP_TYPE__timg__Move */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__Move(): Focus(NULL), soap(NULL) { _timg__Move::soap_default(NULL); }
	virtual ~_timg__Move() { }
};
#endif

#ifndef SOAP_TYPE__timg__MoveResponse
#define SOAP_TYPE__timg__MoveResponse (612)
/* timg:MoveResponse */
class SOAP_CMAC _timg__MoveResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 612; } /* = unique id SOAP_TYPE__timg__MoveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__MoveResponse(): soap(NULL) { _timg__MoveResponse::soap_default(NULL); }
	virtual ~_timg__MoveResponse() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetMoveOptions
#define SOAP_TYPE__timg__GetMoveOptions (613)
/* timg:GetMoveOptions */
class SOAP_CMAC _timg__GetMoveOptions
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 613; } /* = unique id SOAP_TYPE__timg__GetMoveOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetMoveOptions(): soap(NULL) { _timg__GetMoveOptions::soap_default(NULL); }
	virtual ~_timg__GetMoveOptions() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse
#define SOAP_TYPE__timg__GetMoveOptionsResponse (614)
/* timg:GetMoveOptionsResponse */
class SOAP_CMAC _timg__GetMoveOptionsResponse
{
public:
	tt__MoveOptions20 *MoveOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:MoveOptions20 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 614; } /* = unique id SOAP_TYPE__timg__GetMoveOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetMoveOptionsResponse(): MoveOptions(NULL), soap(NULL) { _timg__GetMoveOptionsResponse::soap_default(NULL); }
	virtual ~_timg__GetMoveOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__timg__Stop
#define SOAP_TYPE__timg__Stop (615)
/* timg:Stop */
class SOAP_CMAC _timg__Stop
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 615; } /* = unique id SOAP_TYPE__timg__Stop */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__Stop(): soap(NULL) { _timg__Stop::soap_default(NULL); }
	virtual ~_timg__Stop() { }
};
#endif

#ifndef SOAP_TYPE__timg__StopResponse
#define SOAP_TYPE__timg__StopResponse (616)
/* timg:StopResponse */
class SOAP_CMAC _timg__StopResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 616; } /* = unique id SOAP_TYPE__timg__StopResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__StopResponse(): soap(NULL) { _timg__StopResponse::soap_default(NULL); }
	virtual ~_timg__StopResponse() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetStatus
#define SOAP_TYPE__timg__GetStatus (617)
/* timg:GetStatus */
class SOAP_CMAC _timg__GetStatus
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 617; } /* = unique id SOAP_TYPE__timg__GetStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetStatus(): soap(NULL) { _timg__GetStatus::soap_default(NULL); }
	virtual ~_timg__GetStatus() { }
};
#endif

#ifndef SOAP_TYPE__timg__GetStatusResponse
#define SOAP_TYPE__timg__GetStatusResponse (618)
/* timg:GetStatusResponse */
class SOAP_CMAC _timg__GetStatusResponse
{
public:
	tt__ImagingStatus20 *Status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ImagingStatus20 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 618; } /* = unique id SOAP_TYPE__timg__GetStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _timg__GetStatusResponse(): Status(NULL), soap(NULL) { _timg__GetStatusResponse::soap_default(NULL); }
	virtual ~_timg__GetStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSources
#define SOAP_TYPE__trt__GetVideoSources (619)
/* trt:GetVideoSources */
class SOAP_CMAC _trt__GetVideoSources
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 619; } /* = unique id SOAP_TYPE__trt__GetVideoSources */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSources(): soap(NULL) { _trt__GetVideoSources::soap_default(NULL); }
	virtual ~_trt__GetVideoSources() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSourcesResponse
#define SOAP_TYPE__trt__GetVideoSourcesResponse (620)
/* trt:GetVideoSourcesResponse */
class SOAP_CMAC _trt__GetVideoSourcesResponse
{
public:
	std::vector<class tt__VideoSource * >VideoSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoSource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 620; } /* = unique id SOAP_TYPE__trt__GetVideoSourcesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSourcesResponse(): soap(NULL) { _trt__GetVideoSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourcesResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSources
#define SOAP_TYPE__trt__GetAudioSources (621)
/* trt:GetAudioSources */
class SOAP_CMAC _trt__GetAudioSources
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 621; } /* = unique id SOAP_TYPE__trt__GetAudioSources */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSources(): soap(NULL) { _trt__GetAudioSources::soap_default(NULL); }
	virtual ~_trt__GetAudioSources() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSourcesResponse
#define SOAP_TYPE__trt__GetAudioSourcesResponse (622)
/* trt:GetAudioSourcesResponse */
class SOAP_CMAC _trt__GetAudioSourcesResponse
{
public:
	std::vector<class tt__AudioSource * >AudioSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioSource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 622; } /* = unique id SOAP_TYPE__trt__GetAudioSourcesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSourcesResponse(): soap(NULL) { _trt__GetAudioSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourcesResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__CreateProfile
#define SOAP_TYPE__trt__CreateProfile (623)
/* trt:CreateProfile */
class SOAP_CMAC _trt__CreateProfile
{
public:
	std::string Name;	/* required element of type tt:Name */
	std::string *Token;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 623; } /* = unique id SOAP_TYPE__trt__CreateProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__CreateProfile(): Token(NULL), soap(NULL) { _trt__CreateProfile::soap_default(NULL); }
	virtual ~_trt__CreateProfile() { }
};
#endif

#ifndef SOAP_TYPE__trt__CreateProfileResponse
#define SOAP_TYPE__trt__CreateProfileResponse (624)
/* trt:CreateProfileResponse */
class SOAP_CMAC _trt__CreateProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 624; } /* = unique id SOAP_TYPE__trt__CreateProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__CreateProfileResponse(): Profile(NULL), soap(NULL) { _trt__CreateProfileResponse::soap_default(NULL); }
	virtual ~_trt__CreateProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetProfile
#define SOAP_TYPE__trt__GetProfile (625)
/* trt:GetProfile */
class SOAP_CMAC _trt__GetProfile
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 625; } /* = unique id SOAP_TYPE__trt__GetProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetProfile(): soap(NULL) { _trt__GetProfile::soap_default(NULL); }
	virtual ~_trt__GetProfile() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetProfileResponse
#define SOAP_TYPE__trt__GetProfileResponse (626)
/* trt:GetProfileResponse */
class SOAP_CMAC _trt__GetProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 626; } /* = unique id SOAP_TYPE__trt__GetProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetProfileResponse(): Profile(NULL), soap(NULL) { _trt__GetProfileResponse::soap_default(NULL); }
	virtual ~_trt__GetProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetProfiles
#define SOAP_TYPE__trt__GetProfiles (627)
/* trt:GetProfiles */
class SOAP_CMAC _trt__GetProfiles
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 627; } /* = unique id SOAP_TYPE__trt__GetProfiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetProfiles(): soap(NULL) { _trt__GetProfiles::soap_default(NULL); }
	virtual ~_trt__GetProfiles() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetProfilesResponse
#define SOAP_TYPE__trt__GetProfilesResponse (628)
/* trt:GetProfilesResponse */
class SOAP_CMAC _trt__GetProfilesResponse
{
public:
	std::vector<tt__Profile * >Profiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 628; } /* = unique id SOAP_TYPE__trt__GetProfilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetProfilesResponse(): soap(NULL) { _trt__GetProfilesResponse::soap_default(NULL); }
	virtual ~_trt__GetProfilesResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddVideoEncoderConfiguration
#define SOAP_TYPE__trt__AddVideoEncoderConfiguration (629)
/* trt:AddVideoEncoderConfiguration */
class SOAP_CMAC _trt__AddVideoEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 629; } /* = unique id SOAP_TYPE__trt__AddVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddVideoEncoderConfiguration(): soap(NULL) { _trt__AddVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (630)
/* trt:AddVideoEncoderConfigurationResponse */
class SOAP_CMAC _trt__AddVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 630; } /* = unique id SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddVideoEncoderConfigurationResponse(): soap(NULL) { _trt__AddVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (631)
/* trt:RemoveVideoEncoderConfiguration */
class SOAP_CMAC _trt__RemoveVideoEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 631; } /* = unique id SOAP_TYPE__trt__RemoveVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveVideoEncoderConfiguration(): soap(NULL) { _trt__RemoveVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (632)
/* trt:RemoveVideoEncoderConfigurationResponse */
class SOAP_CMAC _trt__RemoveVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 632; } /* = unique id SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveVideoEncoderConfigurationResponse(): soap(NULL) { _trt__RemoveVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddVideoSourceConfiguration
#define SOAP_TYPE__trt__AddVideoSourceConfiguration (633)
/* trt:AddVideoSourceConfiguration */
class SOAP_CMAC _trt__AddVideoSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 633; } /* = unique id SOAP_TYPE__trt__AddVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddVideoSourceConfiguration(): soap(NULL) { _trt__AddVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (634)
/* trt:AddVideoSourceConfigurationResponse */
class SOAP_CMAC _trt__AddVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 634; } /* = unique id SOAP_TYPE__trt__AddVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddVideoSourceConfigurationResponse(): soap(NULL) { _trt__AddVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE__trt__RemoveVideoSourceConfiguration (635)
/* trt:RemoveVideoSourceConfiguration */
class SOAP_CMAC _trt__RemoveVideoSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 635; } /* = unique id SOAP_TYPE__trt__RemoveVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveVideoSourceConfiguration(): soap(NULL) { _trt__RemoveVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (636)
/* trt:RemoveVideoSourceConfigurationResponse */
class SOAP_CMAC _trt__RemoveVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 636; } /* = unique id SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveVideoSourceConfigurationResponse(): soap(NULL) { _trt__RemoveVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddAudioEncoderConfiguration
#define SOAP_TYPE__trt__AddAudioEncoderConfiguration (637)
/* trt:AddAudioEncoderConfiguration */
class SOAP_CMAC _trt__AddAudioEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 637; } /* = unique id SOAP_TYPE__trt__AddAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddAudioEncoderConfiguration(): soap(NULL) { _trt__AddAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (638)
/* trt:AddAudioEncoderConfigurationResponse */
class SOAP_CMAC _trt__AddAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 638; } /* = unique id SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddAudioEncoderConfigurationResponse(): soap(NULL) { _trt__AddAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (639)
/* trt:RemoveAudioEncoderConfiguration */
class SOAP_CMAC _trt__RemoveAudioEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 639; } /* = unique id SOAP_TYPE__trt__RemoveAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveAudioEncoderConfiguration(): soap(NULL) { _trt__RemoveAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (640)
/* trt:RemoveAudioEncoderConfigurationResponse */
class SOAP_CMAC _trt__RemoveAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 640; } /* = unique id SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveAudioEncoderConfigurationResponse(): soap(NULL) { _trt__RemoveAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddAudioSourceConfiguration
#define SOAP_TYPE__trt__AddAudioSourceConfiguration (641)
/* trt:AddAudioSourceConfiguration */
class SOAP_CMAC _trt__AddAudioSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 641; } /* = unique id SOAP_TYPE__trt__AddAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddAudioSourceConfiguration(): soap(NULL) { _trt__AddAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (642)
/* trt:AddAudioSourceConfigurationResponse */
class SOAP_CMAC _trt__AddAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 642; } /* = unique id SOAP_TYPE__trt__AddAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddAudioSourceConfigurationResponse(): soap(NULL) { _trt__AddAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE__trt__RemoveAudioSourceConfiguration (643)
/* trt:RemoveAudioSourceConfiguration */
class SOAP_CMAC _trt__RemoveAudioSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 643; } /* = unique id SOAP_TYPE__trt__RemoveAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveAudioSourceConfiguration(): soap(NULL) { _trt__RemoveAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (644)
/* trt:RemoveAudioSourceConfigurationResponse */
class SOAP_CMAC _trt__RemoveAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 644; } /* = unique id SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveAudioSourceConfigurationResponse(): soap(NULL) { _trt__RemoveAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddPTZConfiguration
#define SOAP_TYPE__trt__AddPTZConfiguration (645)
/* trt:AddPTZConfiguration */
class SOAP_CMAC _trt__AddPTZConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 645; } /* = unique id SOAP_TYPE__trt__AddPTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddPTZConfiguration(): soap(NULL) { _trt__AddPTZConfiguration::soap_default(NULL); }
	virtual ~_trt__AddPTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddPTZConfigurationResponse
#define SOAP_TYPE__trt__AddPTZConfigurationResponse (646)
/* trt:AddPTZConfigurationResponse */
class SOAP_CMAC _trt__AddPTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 646; } /* = unique id SOAP_TYPE__trt__AddPTZConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddPTZConfigurationResponse(): soap(NULL) { _trt__AddPTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddPTZConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemovePTZConfiguration
#define SOAP_TYPE__trt__RemovePTZConfiguration (647)
/* trt:RemovePTZConfiguration */
class SOAP_CMAC _trt__RemovePTZConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 647; } /* = unique id SOAP_TYPE__trt__RemovePTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemovePTZConfiguration(): soap(NULL) { _trt__RemovePTZConfiguration::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemovePTZConfigurationResponse
#define SOAP_TYPE__trt__RemovePTZConfigurationResponse (648)
/* trt:RemovePTZConfigurationResponse */
class SOAP_CMAC _trt__RemovePTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 648; } /* = unique id SOAP_TYPE__trt__RemovePTZConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemovePTZConfigurationResponse(): soap(NULL) { _trt__RemovePTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (649)
/* trt:AddVideoAnalyticsConfiguration */
class SOAP_CMAC _trt__AddVideoAnalyticsConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 649; } /* = unique id SOAP_TYPE__trt__AddVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddVideoAnalyticsConfiguration(): soap(NULL) { _trt__AddVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (650)
/* trt:AddVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _trt__AddVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 650; } /* = unique id SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddVideoAnalyticsConfigurationResponse(): soap(NULL) { _trt__AddVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (651)
/* trt:RemoveVideoAnalyticsConfiguration */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 651; } /* = unique id SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveVideoAnalyticsConfiguration(): soap(NULL) { _trt__RemoveVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (652)
/* trt:RemoveVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 652; } /* = unique id SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveVideoAnalyticsConfigurationResponse(): soap(NULL) { _trt__RemoveVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddMetadataConfiguration
#define SOAP_TYPE__trt__AddMetadataConfiguration (653)
/* trt:AddMetadataConfiguration */
class SOAP_CMAC _trt__AddMetadataConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 653; } /* = unique id SOAP_TYPE__trt__AddMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddMetadataConfiguration(): soap(NULL) { _trt__AddMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__AddMetadataConfigurationResponse
#define SOAP_TYPE__trt__AddMetadataConfigurationResponse (654)
/* trt:AddMetadataConfigurationResponse */
class SOAP_CMAC _trt__AddMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 654; } /* = unique id SOAP_TYPE__trt__AddMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__AddMetadataConfigurationResponse(): soap(NULL) { _trt__AddMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveMetadataConfiguration
#define SOAP_TYPE__trt__RemoveMetadataConfiguration (655)
/* trt:RemoveMetadataConfiguration */
class SOAP_CMAC _trt__RemoveMetadataConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 655; } /* = unique id SOAP_TYPE__trt__RemoveMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveMetadataConfiguration(): soap(NULL) { _trt__RemoveMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (656)
/* trt:RemoveMetadataConfigurationResponse */
class SOAP_CMAC _trt__RemoveMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 656; } /* = unique id SOAP_TYPE__trt__RemoveMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__RemoveMetadataConfigurationResponse(): soap(NULL) { _trt__RemoveMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__DeleteProfile
#define SOAP_TYPE__trt__DeleteProfile (657)
/* trt:DeleteProfile */
class SOAP_CMAC _trt__DeleteProfile
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 657; } /* = unique id SOAP_TYPE__trt__DeleteProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__DeleteProfile(): soap(NULL) { _trt__DeleteProfile::soap_default(NULL); }
	virtual ~_trt__DeleteProfile() { }
};
#endif

#ifndef SOAP_TYPE__trt__DeleteProfileResponse
#define SOAP_TYPE__trt__DeleteProfileResponse (658)
/* trt:DeleteProfileResponse */
class SOAP_CMAC _trt__DeleteProfileResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 658; } /* = unique id SOAP_TYPE__trt__DeleteProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__DeleteProfileResponse(): soap(NULL) { _trt__DeleteProfileResponse::soap_default(NULL); }
	virtual ~_trt__DeleteProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetVideoEncoderConfigurations (659)
/* trt:GetVideoEncoderConfigurations */
class SOAP_CMAC _trt__GetVideoEncoderConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 659; } /* = unique id SOAP_TYPE__trt__GetVideoEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoEncoderConfigurations(): soap(NULL) { _trt__GetVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (660)
/* trt:GetVideoEncoderConfigurationsResponse */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationsResponse
{
public:
	std::vector<tt__VideoEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 660; } /* = unique id SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoEncoderConfigurationsResponse(): soap(NULL) { _trt__GetVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurations
#define SOAP_TYPE__trt__GetVideoSourceConfigurations (661)
/* trt:GetVideoSourceConfigurations */
class SOAP_CMAC _trt__GetVideoSourceConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 661; } /* = unique id SOAP_TYPE__trt__GetVideoSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSourceConfigurations(): soap(NULL) { _trt__GetVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (662)
/* trt:GetVideoSourceConfigurationsResponse */
class SOAP_CMAC _trt__GetVideoSourceConfigurationsResponse
{
public:
	std::vector<tt__VideoSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 662; } /* = unique id SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSourceConfigurationsResponse(): soap(NULL) { _trt__GetVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetAudioEncoderConfigurations (663)
/* trt:GetAudioEncoderConfigurations */
class SOAP_CMAC _trt__GetAudioEncoderConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 663; } /* = unique id SOAP_TYPE__trt__GetAudioEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioEncoderConfigurations(): soap(NULL) { _trt__GetAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (664)
/* trt:GetAudioEncoderConfigurationsResponse */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationsResponse
{
public:
	std::vector<tt__AudioEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 664; } /* = unique id SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioEncoderConfigurationsResponse(): soap(NULL) { _trt__GetAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurations
#define SOAP_TYPE__trt__GetAudioSourceConfigurations (665)
/* trt:GetAudioSourceConfigurations */
class SOAP_CMAC _trt__GetAudioSourceConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 665; } /* = unique id SOAP_TYPE__trt__GetAudioSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSourceConfigurations(): soap(NULL) { _trt__GetAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (666)
/* trt:GetAudioSourceConfigurationsResponse */
class SOAP_CMAC _trt__GetAudioSourceConfigurationsResponse
{
public:
	std::vector<tt__AudioSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 666; } /* = unique id SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSourceConfigurationsResponse(): soap(NULL) { _trt__GetAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (667)
/* trt:GetVideoAnalyticsConfigurations */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 667; } /* = unique id SOAP_TYPE__trt__GetVideoAnalyticsConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoAnalyticsConfigurations(): soap(NULL) { _trt__GetVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (668)
/* trt:GetVideoAnalyticsConfigurationsResponse */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationsResponse
{
public:
	std::vector<tt__VideoAnalyticsConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 668; } /* = unique id SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoAnalyticsConfigurationsResponse(): soap(NULL) { _trt__GetVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetMetadataConfigurations
#define SOAP_TYPE__trt__GetMetadataConfigurations (669)
/* trt:GetMetadataConfigurations */
class SOAP_CMAC _trt__GetMetadataConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 669; } /* = unique id SOAP_TYPE__trt__GetMetadataConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetMetadataConfigurations(): soap(NULL) { _trt__GetMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationsResponse (670)
/* trt:GetMetadataConfigurationsResponse */
class SOAP_CMAC _trt__GetMetadataConfigurationsResponse
{
public:
	std::vector<tt__MetadataConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 670; } /* = unique id SOAP_TYPE__trt__GetMetadataConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetMetadataConfigurationsResponse(): soap(NULL) { _trt__GetMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSourceConfiguration
#define SOAP_TYPE__trt__GetVideoSourceConfiguration (671)
/* trt:GetVideoSourceConfiguration */
class SOAP_CMAC _trt__GetVideoSourceConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 671; } /* = unique id SOAP_TYPE__trt__GetVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSourceConfiguration(): soap(NULL) { _trt__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (672)
/* trt:GetVideoSourceConfigurationResponse */
class SOAP_CMAC _trt__GetVideoSourceConfigurationResponse
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 672; } /* = unique id SOAP_TYPE__trt__GetVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSourceConfigurationResponse(): Configuration(NULL), soap(NULL) { _trt__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoEncoderConfiguration
#define SOAP_TYPE__trt__GetVideoEncoderConfiguration (673)
/* trt:GetVideoEncoderConfiguration */
class SOAP_CMAC _trt__GetVideoEncoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 673; } /* = unique id SOAP_TYPE__trt__GetVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoEncoderConfiguration(): soap(NULL) { _trt__GetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (674)
/* trt:GetVideoEncoderConfigurationResponse */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationResponse
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 674; } /* = unique id SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoEncoderConfigurationResponse(): Configuration(NULL), soap(NULL) { _trt__GetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSourceConfiguration
#define SOAP_TYPE__trt__GetAudioSourceConfiguration (675)
/* trt:GetAudioSourceConfiguration */
class SOAP_CMAC _trt__GetAudioSourceConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 675; } /* = unique id SOAP_TYPE__trt__GetAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSourceConfiguration(): soap(NULL) { _trt__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (676)
/* trt:GetAudioSourceConfigurationResponse */
class SOAP_CMAC _trt__GetAudioSourceConfigurationResponse
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 676; } /* = unique id SOAP_TYPE__trt__GetAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSourceConfigurationResponse(): Configuration(NULL), soap(NULL) { _trt__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioEncoderConfiguration
#define SOAP_TYPE__trt__GetAudioEncoderConfiguration (677)
/* trt:GetAudioEncoderConfiguration */
class SOAP_CMAC _trt__GetAudioEncoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 677; } /* = unique id SOAP_TYPE__trt__GetAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioEncoderConfiguration(): soap(NULL) { _trt__GetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (678)
/* trt:GetAudioEncoderConfigurationResponse */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationResponse
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 678; } /* = unique id SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioEncoderConfigurationResponse(): Configuration(NULL), soap(NULL) { _trt__GetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (679)
/* trt:GetVideoAnalyticsConfiguration */
class SOAP_CMAC _trt__GetVideoAnalyticsConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 679; } /* = unique id SOAP_TYPE__trt__GetVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoAnalyticsConfiguration(): soap(NULL) { _trt__GetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (680)
/* trt:GetVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationResponse
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 680; } /* = unique id SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoAnalyticsConfigurationResponse(): Configuration(NULL), soap(NULL) { _trt__GetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetMetadataConfiguration
#define SOAP_TYPE__trt__GetMetadataConfiguration (681)
/* trt:GetMetadataConfiguration */
class SOAP_CMAC _trt__GetMetadataConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 681; } /* = unique id SOAP_TYPE__trt__GetMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetMetadataConfiguration(): soap(NULL) { _trt__GetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetMetadataConfigurationResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationResponse (682)
/* trt:GetMetadataConfigurationResponse */
class SOAP_CMAC _trt__GetMetadataConfigurationResponse
{
public:
	tt__MetadataConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 682; } /* = unique id SOAP_TYPE__trt__GetMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetMetadataConfigurationResponse(): Configuration(NULL), soap(NULL) { _trt__GetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (683)
/* trt:GetCompatibleVideoEncoderConfigurations */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 683; } /* = unique id SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleVideoEncoderConfigurations(): soap(NULL) { _trt__GetCompatibleVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (684)
/* trt:GetCompatibleVideoEncoderConfigurationsResponse */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurationsResponse
{
public:
	std::vector<tt__VideoEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 684; } /* = unique id SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleVideoEncoderConfigurationsResponse(): soap(NULL) { _trt__GetCompatibleVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (685)
/* trt:GetCompatibleVideoSourceConfigurations */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurations
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 685; } /* = unique id SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleVideoSourceConfigurations(): soap(NULL) { _trt__GetCompatibleVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (686)
/* trt:GetCompatibleVideoSourceConfigurationsResponse */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurationsResponse
{
public:
	std::vector<tt__VideoSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 686; } /* = unique id SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleVideoSourceConfigurationsResponse(): soap(NULL) { _trt__GetCompatibleVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (687)
/* trt:GetCompatibleAudioEncoderConfigurations */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 687; } /* = unique id SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleAudioEncoderConfigurations(): soap(NULL) { _trt__GetCompatibleAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (688)
/* trt:GetCompatibleAudioEncoderConfigurationsResponse */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurationsResponse
{
public:
	std::vector<tt__AudioEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 688; } /* = unique id SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleAudioEncoderConfigurationsResponse(): soap(NULL) { _trt__GetCompatibleAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (689)
/* trt:GetCompatibleAudioSourceConfigurations */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurations
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 689; } /* = unique id SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleAudioSourceConfigurations(): soap(NULL) { _trt__GetCompatibleAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (690)
/* trt:GetCompatibleAudioSourceConfigurationsResponse */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurationsResponse
{
public:
	std::vector<tt__AudioSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 690; } /* = unique id SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleAudioSourceConfigurationsResponse(): soap(NULL) { _trt__GetCompatibleAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (691)
/* trt:GetCompatibleVideoAnalyticsConfigurations */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 691; } /* = unique id SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleVideoAnalyticsConfigurations(): soap(NULL) { _trt__GetCompatibleVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (692)
/* trt:GetCompatibleVideoAnalyticsConfigurationsResponse */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurationsResponse
{
public:
	std::vector<tt__VideoAnalyticsConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 692; } /* = unique id SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleVideoAnalyticsConfigurationsResponse(): soap(NULL) { _trt__GetCompatibleVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (693)
/* trt:GetCompatibleMetadataConfigurations */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurations
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 693; } /* = unique id SOAP_TYPE__trt__GetCompatibleMetadataConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleMetadataConfigurations(): soap(NULL) { _trt__GetCompatibleMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (694)
/* trt:GetCompatibleMetadataConfigurationsResponse */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurationsResponse
{
public:
	std::vector<tt__MetadataConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 694; } /* = unique id SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetCompatibleMetadataConfigurationsResponse(): soap(NULL) { _trt__GetCompatibleMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetVideoEncoderConfiguration
#define SOAP_TYPE__trt__SetVideoEncoderConfiguration (695)
/* trt:SetVideoEncoderConfiguration */
class SOAP_CMAC _trt__SetVideoEncoderConfiguration
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* required element of type tt:VideoEncoderConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 695; } /* = unique id SOAP_TYPE__trt__SetVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetVideoEncoderConfiguration(): Configuration(NULL), soap(NULL) { _trt__SetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (696)
/* trt:SetVideoEncoderConfigurationResponse */
class SOAP_CMAC _trt__SetVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 696; } /* = unique id SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetVideoEncoderConfigurationResponse(): soap(NULL) { _trt__SetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetVideoSourceConfiguration
#define SOAP_TYPE__trt__SetVideoSourceConfiguration (697)
/* trt:SetVideoSourceConfiguration */
class SOAP_CMAC _trt__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of type tt:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 697; } /* = unique id SOAP_TYPE__trt__SetVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetVideoSourceConfiguration(): Configuration(NULL), soap(NULL) { _trt__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (698)
/* trt:SetVideoSourceConfigurationResponse */
class SOAP_CMAC _trt__SetVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 698; } /* = unique id SOAP_TYPE__trt__SetVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetVideoSourceConfigurationResponse(): soap(NULL) { _trt__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetAudioEncoderConfiguration
#define SOAP_TYPE__trt__SetAudioEncoderConfiguration (699)
/* trt:SetAudioEncoderConfiguration */
class SOAP_CMAC _trt__SetAudioEncoderConfiguration
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* required element of type tt:AudioEncoderConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 699; } /* = unique id SOAP_TYPE__trt__SetAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetAudioEncoderConfiguration(): Configuration(NULL), soap(NULL) { _trt__SetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (700)
/* trt:SetAudioEncoderConfigurationResponse */
class SOAP_CMAC _trt__SetAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 700; } /* = unique id SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetAudioEncoderConfigurationResponse(): soap(NULL) { _trt__SetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetAudioSourceConfiguration
#define SOAP_TYPE__trt__SetAudioSourceConfiguration (701)
/* trt:SetAudioSourceConfiguration */
class SOAP_CMAC _trt__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of type tt:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 701; } /* = unique id SOAP_TYPE__trt__SetAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetAudioSourceConfiguration(): Configuration(NULL), soap(NULL) { _trt__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (702)
/* trt:SetAudioSourceConfigurationResponse */
class SOAP_CMAC _trt__SetAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 702; } /* = unique id SOAP_TYPE__trt__SetAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetAudioSourceConfigurationResponse(): soap(NULL) { _trt__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (703)
/* trt:SetVideoAnalyticsConfiguration */
class SOAP_CMAC _trt__SetVideoAnalyticsConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* required element of type tt:VideoAnalyticsConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 703; } /* = unique id SOAP_TYPE__trt__SetVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetVideoAnalyticsConfiguration(): Configuration(NULL), soap(NULL) { _trt__SetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (704)
/* trt:SetVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _trt__SetVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 704; } /* = unique id SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetVideoAnalyticsConfigurationResponse(): soap(NULL) { _trt__SetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetMetadataConfiguration
#define SOAP_TYPE__trt__SetMetadataConfiguration (705)
/* trt:SetMetadataConfiguration */
class SOAP_CMAC _trt__SetMetadataConfiguration
{
public:
	tt__MetadataConfiguration *Configuration;	/* required element of type tt:MetadataConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 705; } /* = unique id SOAP_TYPE__trt__SetMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetMetadataConfiguration(): Configuration(NULL), soap(NULL) { _trt__SetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetMetadataConfigurationResponse
#define SOAP_TYPE__trt__SetMetadataConfigurationResponse (706)
/* trt:SetMetadataConfigurationResponse */
class SOAP_CMAC _trt__SetMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 706; } /* = unique id SOAP_TYPE__trt__SetMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetMetadataConfigurationResponse(): soap(NULL) { _trt__SetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (707)
/* trt:GetVideoSourceConfigurationOptions */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 707; } /* = unique id SOAP_TYPE__trt__GetVideoSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSourceConfigurationOptions(): ConfigurationToken(NULL), ProfileToken(NULL), soap(NULL) { _trt__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (708)
/* trt:GetVideoSourceConfigurationOptionsResponse */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:VideoSourceConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 708; } /* = unique id SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoSourceConfigurationOptionsResponse(): Options(NULL), soap(NULL) { _trt__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (709)
/* trt:GetVideoEncoderConfigurationOptions */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 709; } /* = unique id SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoEncoderConfigurationOptions(): ConfigurationToken(NULL), ProfileToken(NULL), soap(NULL) { _trt__GetVideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (710)
/* trt:GetVideoEncoderConfigurationOptionsResponse */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptionsResponse
{
public:
	tt__VideoEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:VideoEncoderConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 710; } /* = unique id SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetVideoEncoderConfigurationOptionsResponse(): Options(NULL), soap(NULL) { _trt__GetVideoEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (711)
/* trt:GetAudioSourceConfigurationOptions */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 711; } /* = unique id SOAP_TYPE__trt__GetAudioSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSourceConfigurationOptions(): ConfigurationToken(NULL), ProfileToken(NULL), soap(NULL) { _trt__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (712)
/* trt:GetAudioSourceConfigurationOptionsResponse */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioSourceConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 712; } /* = unique id SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioSourceConfigurationOptionsResponse(): Options(NULL), soap(NULL) { _trt__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (713)
/* trt:GetAudioEncoderConfigurationOptions */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 713; } /* = unique id SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioEncoderConfigurationOptions(): ConfigurationToken(NULL), ProfileToken(NULL), soap(NULL) { _trt__GetAudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (714)
/* trt:GetAudioEncoderConfigurationOptionsResponse */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptionsResponse
{
public:
	tt__AudioEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioEncoderConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 714; } /* = unique id SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetAudioEncoderConfigurationOptionsResponse(): Options(NULL), soap(NULL) { _trt__GetAudioEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptions
#define SOAP_TYPE__trt__GetMetadataConfigurationOptions (715)
/* trt:GetMetadataConfigurationOptions */
class SOAP_CMAC _trt__GetMetadataConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 715; } /* = unique id SOAP_TYPE__trt__GetMetadataConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetMetadataConfigurationOptions(): ConfigurationToken(NULL), ProfileToken(NULL), soap(NULL) { _trt__GetMetadataConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (716)
/* trt:GetMetadataConfigurationOptionsResponse */
class SOAP_CMAC _trt__GetMetadataConfigurationOptionsResponse
{
public:
	tt__MetadataConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:MetadataConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 716; } /* = unique id SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetMetadataConfigurationOptionsResponse(): Options(NULL), soap(NULL) { _trt__GetMetadataConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (717)
/* trt:GetGuaranteedNumberOfVideoEncoderInstances */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 717; } /* = unique id SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetGuaranteedNumberOfVideoEncoderInstances(): soap(NULL) { _trt__GetGuaranteedNumberOfVideoEncoderInstances::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstances() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (718)
/* trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
{
public:
	int TotalNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	int *JPEG;	/* optional element of type xsd:int */
	int *H264;	/* optional element of type xsd:int */
	int *MPEG4;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 718; } /* = unique id SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(): JPEG(NULL), H264(NULL), MPEG4(NULL), soap(NULL) { _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetStreamUri
#define SOAP_TYPE__trt__GetStreamUri (719)
/* trt:GetStreamUri */
class SOAP_CMAC _trt__GetStreamUri
{
public:
	tt__StreamSetup *StreamSetup;	/* required element of type tt:StreamSetup */
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 719; } /* = unique id SOAP_TYPE__trt__GetStreamUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetStreamUri(): StreamSetup(NULL), soap(NULL) { _trt__GetStreamUri::soap_default(NULL); }
	virtual ~_trt__GetStreamUri() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetStreamUriResponse
#define SOAP_TYPE__trt__GetStreamUriResponse (720)
/* trt:GetStreamUriResponse */
class SOAP_CMAC _trt__GetStreamUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:MediaUri */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 720; } /* = unique id SOAP_TYPE__trt__GetStreamUriResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetStreamUriResponse(): MediaUri(NULL), soap(NULL) { _trt__GetStreamUriResponse::soap_default(NULL); }
	virtual ~_trt__GetStreamUriResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__StartMulticastStreaming
#define SOAP_TYPE__trt__StartMulticastStreaming (721)
/* trt:StartMulticastStreaming */
class SOAP_CMAC _trt__StartMulticastStreaming
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 721; } /* = unique id SOAP_TYPE__trt__StartMulticastStreaming */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__StartMulticastStreaming(): soap(NULL) { _trt__StartMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreaming() { }
};
#endif

#ifndef SOAP_TYPE__trt__StartMulticastStreamingResponse
#define SOAP_TYPE__trt__StartMulticastStreamingResponse (722)
/* trt:StartMulticastStreamingResponse */
class SOAP_CMAC _trt__StartMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 722; } /* = unique id SOAP_TYPE__trt__StartMulticastStreamingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__StartMulticastStreamingResponse(): soap(NULL) { _trt__StartMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreamingResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__StopMulticastStreaming
#define SOAP_TYPE__trt__StopMulticastStreaming (723)
/* trt:StopMulticastStreaming */
class SOAP_CMAC _trt__StopMulticastStreaming
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 723; } /* = unique id SOAP_TYPE__trt__StopMulticastStreaming */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__StopMulticastStreaming(): soap(NULL) { _trt__StopMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreaming() { }
};
#endif

#ifndef SOAP_TYPE__trt__StopMulticastStreamingResponse
#define SOAP_TYPE__trt__StopMulticastStreamingResponse (724)
/* trt:StopMulticastStreamingResponse */
class SOAP_CMAC _trt__StopMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 724; } /* = unique id SOAP_TYPE__trt__StopMulticastStreamingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__StopMulticastStreamingResponse(): soap(NULL) { _trt__StopMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreamingResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetSynchronizationPoint
#define SOAP_TYPE__trt__SetSynchronizationPoint (725)
/* trt:SetSynchronizationPoint */
class SOAP_CMAC _trt__SetSynchronizationPoint
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 725; } /* = unique id SOAP_TYPE__trt__SetSynchronizationPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetSynchronizationPoint(): soap(NULL) { _trt__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPoint() { }
};
#endif

#ifndef SOAP_TYPE__trt__SetSynchronizationPointResponse
#define SOAP_TYPE__trt__SetSynchronizationPointResponse (726)
/* trt:SetSynchronizationPointResponse */
class SOAP_CMAC _trt__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 726; } /* = unique id SOAP_TYPE__trt__SetSynchronizationPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__SetSynchronizationPointResponse(): soap(NULL) { _trt__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetSnapshotUri
#define SOAP_TYPE__trt__GetSnapshotUri (727)
/* trt:GetSnapshotUri */
class SOAP_CMAC _trt__GetSnapshotUri
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 727; } /* = unique id SOAP_TYPE__trt__GetSnapshotUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetSnapshotUri(): soap(NULL) { _trt__GetSnapshotUri::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUri() { }
};
#endif

#ifndef SOAP_TYPE__trt__GetSnapshotUriResponse
#define SOAP_TYPE__trt__GetSnapshotUriResponse (728)
/* trt:GetSnapshotUriResponse */
class SOAP_CMAC _trt__GetSnapshotUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:MediaUri */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 728; } /* = unique id SOAP_TYPE__trt__GetSnapshotUriResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _trt__GetSnapshotUriResponse(): MediaUri(NULL), soap(NULL) { _trt__GetSnapshotUriResponse::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUriResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNodes
#define SOAP_TYPE__tptz__GetNodes (729)
/* tptz:GetNodes */
class SOAP_CMAC _tptz__GetNodes
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 729; } /* = unique id SOAP_TYPE__tptz__GetNodes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNodes(): soap(NULL) { _tptz__GetNodes::soap_default(NULL); }
	virtual ~_tptz__GetNodes() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNodesResponse
#define SOAP_TYPE__tptz__GetNodesResponse (730)
/* tptz:GetNodesResponse */
class SOAP_CMAC _tptz__GetNodesResponse
{
public:
	std::vector<class tt__PTZNode * >PTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:PTZNode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 730; } /* = unique id SOAP_TYPE__tptz__GetNodesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNodesResponse(): soap(NULL) { _tptz__GetNodesResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNode
#define SOAP_TYPE__tptz__GetNode (731)
/* tptz:GetNode */
class SOAP_CMAC _tptz__GetNode
{
public:
	std::string NodeToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 731; } /* = unique id SOAP_TYPE__tptz__GetNode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNode(): soap(NULL) { _tptz__GetNode::soap_default(NULL); }
	virtual ~_tptz__GetNode() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNodeResponse
#define SOAP_TYPE__tptz__GetNodeResponse (732)
/* tptz:GetNodeResponse */
class SOAP_CMAC _tptz__GetNodeResponse
{
public:
	tt__PTZNode *PTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZNode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 732; } /* = unique id SOAP_TYPE__tptz__GetNodeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNodeResponse(): PTZNode(NULL), soap(NULL) { _tptz__GetNodeResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurations
#define SOAP_TYPE__tptz__GetConfigurations (733)
/* tptz:GetConfigurations */
class SOAP_CMAC _tptz__GetConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 733; } /* = unique id SOAP_TYPE__tptz__GetConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurations(): soap(NULL) { _tptz__GetConfigurations::soap_default(NULL); }
	virtual ~_tptz__GetConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationsResponse
#define SOAP_TYPE__tptz__GetConfigurationsResponse (734)
/* tptz:GetConfigurationsResponse */
class SOAP_CMAC _tptz__GetConfigurationsResponse
{
public:
	std::vector<tt__PTZConfiguration * >PTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:PTZConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 734; } /* = unique id SOAP_TYPE__tptz__GetConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationsResponse(): soap(NULL) { _tptz__GetConfigurationsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfiguration
#define SOAP_TYPE__tptz__GetConfiguration (735)
/* tptz:GetConfiguration */
class SOAP_CMAC _tptz__GetConfiguration
{
public:
	std::string PTZConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 735; } /* = unique id SOAP_TYPE__tptz__GetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfiguration(): soap(NULL) { _tptz__GetConfiguration::soap_default(NULL); }
	virtual ~_tptz__GetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationResponse
#define SOAP_TYPE__tptz__GetConfigurationResponse (736)
/* tptz:GetConfigurationResponse */
class SOAP_CMAC _tptz__GetConfigurationResponse
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 736; } /* = unique id SOAP_TYPE__tptz__GetConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationResponse(): PTZConfiguration(NULL), soap(NULL) { _tptz__GetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetConfiguration
#define SOAP_TYPE__tptz__SetConfiguration (737)
/* tptz:SetConfiguration */
class SOAP_CMAC _tptz__SetConfiguration
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* required element of type tt:PTZConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 737; } /* = unique id SOAP_TYPE__tptz__SetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetConfiguration(): PTZConfiguration(NULL), soap(NULL) { _tptz__SetConfiguration::soap_default(NULL); }
	virtual ~_tptz__SetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE___tptz__SetConfigurationResponse_sequence
#define SOAP_TYPE___tptz__SetConfigurationResponse_sequence (1212)
/* Operation wrapper: */
class SOAP_CMAC __tptz__SetConfigurationResponse_sequence
{
public:
	virtual int soap_type() const { return 1212; } /* = unique id SOAP_TYPE___tptz__SetConfigurationResponse_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tptz__SetConfigurationResponse_sequence() { __tptz__SetConfigurationResponse_sequence::soap_default(NULL); }
	virtual ~__tptz__SetConfigurationResponse_sequence() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetConfigurationResponse
#define SOAP_TYPE__tptz__SetConfigurationResponse (738)
/* tptz:SetConfigurationResponse */
class SOAP_CMAC _tptz__SetConfigurationResponse
{
public:
	int __size_SetConfigurationResponse_sequence;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-SetConfigurationResponse-sequence> */
	__tptz__SetConfigurationResponse_sequence *__SetConfigurationResponse_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 738; } /* = unique id SOAP_TYPE__tptz__SetConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetConfigurationResponse(): __SetConfigurationResponse_sequence(NULL), soap(NULL) { _tptz__SetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__SetConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationOptions
#define SOAP_TYPE__tptz__GetConfigurationOptions (739)
/* tptz:GetConfigurationOptions */
class SOAP_CMAC _tptz__GetConfigurationOptions
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 739; } /* = unique id SOAP_TYPE__tptz__GetConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationOptions(): soap(NULL) { _tptz__GetConfigurationOptions::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationOptionsResponse
#define SOAP_TYPE__tptz__GetConfigurationOptionsResponse (740)
/* tptz:GetConfigurationOptionsResponse */
class SOAP_CMAC _tptz__GetConfigurationOptionsResponse
{
public:
	tt__PTZConfigurationOptions *PTZConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 740; } /* = unique id SOAP_TYPE__tptz__GetConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationOptionsResponse(): PTZConfigurationOptions(NULL), soap(NULL) { _tptz__GetConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommand
#define SOAP_TYPE__tptz__SendAuxiliaryCommand (741)
/* tptz:SendAuxiliaryCommand */
class SOAP_CMAC _tptz__SendAuxiliaryCommand
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string AuxiliaryData;	/* required element of type tt:AuxiliaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 741; } /* = unique id SOAP_TYPE__tptz__SendAuxiliaryCommand */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SendAuxiliaryCommand(): soap(NULL) { _tptz__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommand() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (742)
/* tptz:SendAuxiliaryCommandResponse */
class SOAP_CMAC _tptz__SendAuxiliaryCommandResponse
{
public:
	std::string AuxiliaryResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AuxiliaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 742; } /* = unique id SOAP_TYPE__tptz__SendAuxiliaryCommandResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SendAuxiliaryCommandResponse(): soap(NULL) { _tptz__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommandResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresets
#define SOAP_TYPE__tptz__GetPresets (743)
/* tptz:GetPresets */
class SOAP_CMAC _tptz__GetPresets
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 743; } /* = unique id SOAP_TYPE__tptz__GetPresets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresets(): soap(NULL) { _tptz__GetPresets::soap_default(NULL); }
	virtual ~_tptz__GetPresets() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetsResponse
#define SOAP_TYPE__tptz__GetPresetsResponse (744)
/* tptz:GetPresetsResponse */
class SOAP_CMAC _tptz__GetPresetsResponse
{
public:
	std::vector<tt__PTZPreset * >Preset;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:PTZPreset */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 744; } /* = unique id SOAP_TYPE__tptz__GetPresetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetsResponse(): soap(NULL) { _tptz__GetPresetsResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetPreset
#define SOAP_TYPE__tptz__SetPreset (745)
/* tptz:SetPreset */
class SOAP_CMAC _tptz__SetPreset
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string *PresetName;	/* optional element of type xsd:string */
	std::string *PresetToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 745; } /* = unique id SOAP_TYPE__tptz__SetPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetPreset(): PresetName(NULL), PresetToken(NULL), soap(NULL) { _tptz__SetPreset::soap_default(NULL); }
	virtual ~_tptz__SetPreset() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetPresetResponse
#define SOAP_TYPE__tptz__SetPresetResponse (746)
/* tptz:SetPresetResponse */
class SOAP_CMAC _tptz__SetPresetResponse
{
public:
	std::string PresetToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 746; } /* = unique id SOAP_TYPE__tptz__SetPresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetPresetResponse(): soap(NULL) { _tptz__SetPresetResponse::soap_default(NULL); }
	virtual ~_tptz__SetPresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RemovePreset
#define SOAP_TYPE__tptz__RemovePreset (747)
/* tptz:RemovePreset */
class SOAP_CMAC _tptz__RemovePreset
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string PresetToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 747; } /* = unique id SOAP_TYPE__tptz__RemovePreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RemovePreset(): soap(NULL) { _tptz__RemovePreset::soap_default(NULL); }
	virtual ~_tptz__RemovePreset() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RemovePresetResponse
#define SOAP_TYPE__tptz__RemovePresetResponse (748)
/* tptz:RemovePresetResponse */
class SOAP_CMAC _tptz__RemovePresetResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 748; } /* = unique id SOAP_TYPE__tptz__RemovePresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RemovePresetResponse(): soap(NULL) { _tptz__RemovePresetResponse::soap_default(NULL); }
	virtual ~_tptz__RemovePresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoPreset
#define SOAP_TYPE__tptz__GotoPreset (749)
/* tptz:GotoPreset */
class SOAP_CMAC _tptz__GotoPreset
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string PresetToken;	/* required element of type tt:ReferenceToken */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 749; } /* = unique id SOAP_TYPE__tptz__GotoPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoPreset(): Speed(NULL), soap(NULL) { _tptz__GotoPreset::soap_default(NULL); }
	virtual ~_tptz__GotoPreset() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoPresetResponse
#define SOAP_TYPE__tptz__GotoPresetResponse (750)
/* tptz:GotoPresetResponse */
class SOAP_CMAC _tptz__GotoPresetResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 750; } /* = unique id SOAP_TYPE__tptz__GotoPresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoPresetResponse(): soap(NULL) { _tptz__GotoPresetResponse::soap_default(NULL); }
	virtual ~_tptz__GotoPresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetStatus
#define SOAP_TYPE__tptz__GetStatus (751)
/* tptz:GetStatus */
class SOAP_CMAC _tptz__GetStatus
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 751; } /* = unique id SOAP_TYPE__tptz__GetStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetStatus(): soap(NULL) { _tptz__GetStatus::soap_default(NULL); }
	virtual ~_tptz__GetStatus() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetStatusResponse
#define SOAP_TYPE__tptz__GetStatusResponse (752)
/* tptz:GetStatusResponse */
class SOAP_CMAC _tptz__GetStatusResponse
{
public:
	tt__PTZStatus *PTZStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 752; } /* = unique id SOAP_TYPE__tptz__GetStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetStatusResponse(): PTZStatus(NULL), soap(NULL) { _tptz__GetStatusResponse::soap_default(NULL); }
	virtual ~_tptz__GetStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoHomePosition
#define SOAP_TYPE__tptz__GotoHomePosition (753)
/* tptz:GotoHomePosition */
class SOAP_CMAC _tptz__GotoHomePosition
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 753; } /* = unique id SOAP_TYPE__tptz__GotoHomePosition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoHomePosition(): Speed(NULL), soap(NULL) { _tptz__GotoHomePosition::soap_default(NULL); }
	virtual ~_tptz__GotoHomePosition() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoHomePositionResponse
#define SOAP_TYPE__tptz__GotoHomePositionResponse (754)
/* tptz:GotoHomePositionResponse */
class SOAP_CMAC _tptz__GotoHomePositionResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 754; } /* = unique id SOAP_TYPE__tptz__GotoHomePositionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoHomePositionResponse(): soap(NULL) { _tptz__GotoHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__GotoHomePositionResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetHomePosition
#define SOAP_TYPE__tptz__SetHomePosition (755)
/* tptz:SetHomePosition */
class SOAP_CMAC _tptz__SetHomePosition
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 755; } /* = unique id SOAP_TYPE__tptz__SetHomePosition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetHomePosition(): soap(NULL) { _tptz__SetHomePosition::soap_default(NULL); }
	virtual ~_tptz__SetHomePosition() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetHomePositionResponse
#define SOAP_TYPE__tptz__SetHomePositionResponse (756)
/* tptz:SetHomePositionResponse */
class SOAP_CMAC _tptz__SetHomePositionResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 756; } /* = unique id SOAP_TYPE__tptz__SetHomePositionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetHomePositionResponse(): soap(NULL) { _tptz__SetHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__SetHomePositionResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__ContinuousMove
#define SOAP_TYPE__tptz__ContinuousMove (757)
/* tptz:ContinuousMove */
class SOAP_CMAC _tptz__ContinuousMove
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PTZSpeed *Velocity;	/* required element of type tt:PTZSpeed */
	LONG64 *Timeout;	/* optional element of type xsd:duration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 757; } /* = unique id SOAP_TYPE__tptz__ContinuousMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__ContinuousMove(): Velocity(NULL), Timeout(NULL), soap(NULL) { _tptz__ContinuousMove::soap_default(NULL); }
	virtual ~_tptz__ContinuousMove() { }
};
#endif

#ifndef SOAP_TYPE__tptz__ContinuousMoveResponse
#define SOAP_TYPE__tptz__ContinuousMoveResponse (758)
/* tptz:ContinuousMoveResponse */
class SOAP_CMAC _tptz__ContinuousMoveResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 758; } /* = unique id SOAP_TYPE__tptz__ContinuousMoveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__ContinuousMoveResponse(): soap(NULL) { _tptz__ContinuousMoveResponse::soap_default(NULL); }
	virtual ~_tptz__ContinuousMoveResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RelativeMove
#define SOAP_TYPE__tptz__RelativeMove (759)
/* tptz:RelativeMove */
class SOAP_CMAC _tptz__RelativeMove
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PTZVector *Translation;	/* required element of type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 759; } /* = unique id SOAP_TYPE__tptz__RelativeMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RelativeMove(): Translation(NULL), Speed(NULL), soap(NULL) { _tptz__RelativeMove::soap_default(NULL); }
	virtual ~_tptz__RelativeMove() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RelativeMoveResponse
#define SOAP_TYPE__tptz__RelativeMoveResponse (760)
/* tptz:RelativeMoveResponse */
class SOAP_CMAC _tptz__RelativeMoveResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 760; } /* = unique id SOAP_TYPE__tptz__RelativeMoveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RelativeMoveResponse(): soap(NULL) { _tptz__RelativeMoveResponse::soap_default(NULL); }
	virtual ~_tptz__RelativeMoveResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__AbsoluteMove
#define SOAP_TYPE__tptz__AbsoluteMove (761)
/* tptz:AbsoluteMove */
class SOAP_CMAC _tptz__AbsoluteMove
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PTZVector *Position;	/* required element of type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 761; } /* = unique id SOAP_TYPE__tptz__AbsoluteMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__AbsoluteMove(): Position(NULL), Speed(NULL), soap(NULL) { _tptz__AbsoluteMove::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMove() { }
};
#endif

#ifndef SOAP_TYPE__tptz__AbsoluteMoveResponse
#define SOAP_TYPE__tptz__AbsoluteMoveResponse (762)
/* tptz:AbsoluteMoveResponse */
class SOAP_CMAC _tptz__AbsoluteMoveResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 762; } /* = unique id SOAP_TYPE__tptz__AbsoluteMoveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__AbsoluteMoveResponse(): soap(NULL) { _tptz__AbsoluteMoveResponse::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMoveResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__Stop
#define SOAP_TYPE__tptz__Stop (763)
/* tptz:Stop */
class SOAP_CMAC _tptz__Stop
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	bool *PanTilt;	/* optional element of type xsd:boolean */
	bool *Zoom;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 763; } /* = unique id SOAP_TYPE__tptz__Stop */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__Stop(): PanTilt(NULL), Zoom(NULL), soap(NULL) { _tptz__Stop::soap_default(NULL); }
	virtual ~_tptz__Stop() { }
};
#endif

#ifndef SOAP_TYPE__tptz__StopResponse
#define SOAP_TYPE__tptz__StopResponse (764)
/* tptz:StopResponse */
class SOAP_CMAC _tptz__StopResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 764; } /* = unique id SOAP_TYPE__tptz__StopResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__StopResponse(): soap(NULL) { _tptz__StopResponse::soap_default(NULL); }
	virtual ~_tptz__StopResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns6__HelloType
#define SOAP_TYPE_ns6__HelloType (765)
/* ns6:HelloType */
class SOAP_CMAC ns6__HelloType : public xsd__anyType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of type wsa:EndpointReference */
	std::string *Types;	/* optional element of type ns6:QNameListType */
	class ns6__ScopesType *Scopes;	/* optional element of type ns6:ScopesType */
	std::string *XAddrs;	/* optional element of type ns6:UriListType */
	unsigned int MetadataVersion;	/* required element of type xsd:unsignedInt */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 765; } /* = unique id SOAP_TYPE_ns6__HelloType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__HelloType(): Types(NULL), Scopes(NULL), XAddrs(NULL), __anyAttribute(NULL) { ns6__HelloType::soap_default(NULL); }
	virtual ~ns6__HelloType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ByeType
#define SOAP_TYPE_ns6__ByeType (766)
/* ns6:ByeType */
class SOAP_CMAC ns6__ByeType : public xsd__anyType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of type wsa:EndpointReference */
	std::string *Types;	/* optional element of type ns6:QNameListType */
	ns6__ScopesType *Scopes;	/* optional element of type ns6:ScopesType */
	std::string *XAddrs;	/* optional element of type ns6:UriListType */
	unsigned int *MetadataVersion;	/* optional element of type xsd:unsignedInt */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 766; } /* = unique id SOAP_TYPE_ns6__ByeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ByeType(): Types(NULL), Scopes(NULL), XAddrs(NULL), MetadataVersion(NULL), __anyAttribute(NULL) { ns6__ByeType::soap_default(NULL); }
	virtual ~ns6__ByeType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ProbeType
#define SOAP_TYPE_ns6__ProbeType (767)
/* ns6:ProbeType */
class SOAP_CMAC ns6__ProbeType : public xsd__anyType
{
public:
	std::string *Types;	/* optional element of type ns6:QNameListType */
	ns6__ScopesType *Scopes;	/* optional element of type ns6:ScopesType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 767; } /* = unique id SOAP_TYPE_ns6__ProbeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ProbeType(): Types(NULL), Scopes(NULL), __anyAttribute(NULL) { ns6__ProbeType::soap_default(NULL); }
	virtual ~ns6__ProbeType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ProbeMatchesType
#define SOAP_TYPE_ns6__ProbeMatchesType (768)
/* ns6:ProbeMatchesType */
class SOAP_CMAC ns6__ProbeMatchesType : public xsd__anyType
{
public:
	std::vector<class ns6__ProbeMatchType * >ProbeMatch;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ProbeMatchType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 768; } /* = unique id SOAP_TYPE_ns6__ProbeMatchesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ProbeMatchesType(): __anyAttribute(NULL) { ns6__ProbeMatchesType::soap_default(NULL); }
	virtual ~ns6__ProbeMatchesType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ProbeMatchType
#define SOAP_TYPE_ns6__ProbeMatchType (769)
/* ns6:ProbeMatchType */
class SOAP_CMAC ns6__ProbeMatchType : public xsd__anyType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of type wsa:EndpointReference */
	std::string *Types;	/* optional element of type ns6:QNameListType */
	ns6__ScopesType *Scopes;	/* optional element of type ns6:ScopesType */
	std::string *XAddrs;	/* optional element of type ns6:UriListType */
	unsigned int MetadataVersion;	/* required element of type xsd:unsignedInt */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 769; } /* = unique id SOAP_TYPE_ns6__ProbeMatchType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ProbeMatchType(): Types(NULL), Scopes(NULL), XAddrs(NULL), __anyAttribute(NULL) { ns6__ProbeMatchType::soap_default(NULL); }
	virtual ~ns6__ProbeMatchType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ResolveType
#define SOAP_TYPE_ns6__ResolveType (770)
/* ns6:ResolveType */
class SOAP_CMAC ns6__ResolveType : public xsd__anyType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type wsa:EndpointReference */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 770; } /* = unique id SOAP_TYPE_ns6__ResolveType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ResolveType(): __anyAttribute(NULL) { ns6__ResolveType::soap_default(NULL); }
	virtual ~ns6__ResolveType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ResolveMatchesType
#define SOAP_TYPE_ns6__ResolveMatchesType (771)
/* ns6:ResolveMatchesType */
class SOAP_CMAC ns6__ResolveMatchesType : public xsd__anyType
{
public:
	class ns6__ResolveMatchType *ResolveMatch;	/* optional element of type ns6:ResolveMatchType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 771; } /* = unique id SOAP_TYPE_ns6__ResolveMatchesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ResolveMatchesType(): ResolveMatch(NULL), __anyAttribute(NULL) { ns6__ResolveMatchesType::soap_default(NULL); }
	virtual ~ns6__ResolveMatchesType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ResolveMatchType
#define SOAP_TYPE_ns6__ResolveMatchType (772)
/* ns6:ResolveMatchType */
class SOAP_CMAC ns6__ResolveMatchType : public xsd__anyType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of type wsa:EndpointReference */
	std::string *Types;	/* optional element of type ns6:QNameListType */
	ns6__ScopesType *Scopes;	/* optional element of type ns6:ScopesType */
	std::string XAddrs;	/* required element of type ns6:UriListType */
	unsigned int MetadataVersion;	/* required element of type xsd:unsignedInt */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 772; } /* = unique id SOAP_TYPE_ns6__ResolveMatchType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ResolveMatchType(): Types(NULL), Scopes(NULL), __anyAttribute(NULL) { ns6__ResolveMatchType::soap_default(NULL); }
	virtual ~ns6__ResolveMatchType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__SecurityType
#define SOAP_TYPE_ns6__SecurityType (774)
/* ns6:SecurityType */
class SOAP_CMAC ns6__SecurityType : public xsd__anyType
{
public:
	class ns6__SigType *Sig;	/* optional element of type ns6:SigType */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 774; } /* = unique id SOAP_TYPE_ns6__SecurityType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__SecurityType(): Sig(NULL), __anyAttribute(NULL) { ns6__SecurityType::soap_default(NULL); }
	virtual ~ns6__SecurityType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__SigType
#define SOAP_TYPE_ns6__SigType (775)
/* ns6:SigType */
class SOAP_CMAC ns6__SigType : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::string Scheme;	/* required attribute */
	xsd__base64Binary *KeyId;	/* optional attribute */
	std::string Refs;	/* required attribute */
	xsd__base64Binary Sig;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 775; } /* = unique id SOAP_TYPE_ns6__SigType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__SigType(): KeyId(NULL), __anyAttribute(NULL) { ns6__SigType::soap_default(NULL); }
	virtual ~ns6__SigType() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (188)
/* tt:VideoSource */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity
{
public:
	float Framerate;	/* required element of type xsd:float */
	tt__VideoResolution *Resolution;	/* required element of type tt:VideoResolution */
	tt__ImagingSettings *Imaging;	/* optional element of type tt:ImagingSettings */
	tt__VideoSourceExtension *Extension;	/* optional element of type tt:VideoSourceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 188; } /* = unique id SOAP_TYPE_tt__VideoSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSource(): Resolution(NULL), Imaging(NULL), Extension(NULL), __anyAttribute(NULL) { tt__VideoSource::soap_default(NULL); }
	virtual ~tt__VideoSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (190)
/* tt:AudioSource */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity
{
public:
	int Channels;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 190; } /* = unique id SOAP_TYPE_tt__AudioSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSource(): __anyAttribute(NULL) { tt__AudioSource::soap_default(NULL); }
	virtual ~tt__AudioSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (194)
/* tt:VideoSourceConfiguration */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of type tt:ReferenceToken */
	tt__IntRectangle *Bounds;	/* required element of type tt:IntRectangle */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 194; } /* = unique id SOAP_TYPE_tt__VideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfiguration(): Bounds(NULL), __anyAttribute(NULL) { tt__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~tt__VideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (197)
/* tt:VideoEncoderConfiguration */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__VideoEncoding Encoding;	/* required element of type tt:VideoEncoding */
	tt__VideoResolution *Resolution;	/* required element of type tt:VideoResolution */
	float Quality;	/* required element of type xsd:float */
	tt__VideoRateControl *RateControl;	/* optional element of type tt:VideoRateControl */
	tt__Mpeg4Configuration *MPEG4;	/* optional element of type tt:Mpeg4Configuration */
	tt__H264Configuration *H264;	/* optional element of type tt:H264Configuration */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 197; } /* = unique id SOAP_TYPE_tt__VideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderConfiguration(): Resolution(NULL), RateControl(NULL), MPEG4(NULL), H264(NULL), Multicast(NULL), __anyAttribute(NULL) { tt__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (207)
/* tt:AudioSourceConfiguration */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of type tt:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 207; } /* = unique id SOAP_TYPE_tt__AudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceConfiguration(): __anyAttribute(NULL) { tt__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~tt__AudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (210)
/* tt:AudioEncoderConfiguration */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of type tt:AudioEncoding */
	int Bitrate;	/* required element of type xsd:int */
	int SampleRate;	/* required element of type xsd:int */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 210; } /* = unique id SOAP_TYPE_tt__AudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfiguration(): Multicast(NULL), __anyAttribute(NULL) { tt__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (213)
/* tt:VideoAnalyticsConfiguration */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of type tt:AnalyticsEngineConfiguration */
	tt__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of type tt:RuleEngineConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 213; } /* = unique id SOAP_TYPE_tt__VideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAnalyticsConfiguration(): AnalyticsEngineConfiguration(NULL), RuleEngineConfiguration(NULL), __anyAttribute(NULL) { tt__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (214)
/* tt:MetadataConfiguration */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity
{
public:
	tt__PTZFilter *PTZStatus;	/* optional element of type tt:PTZFilter */
	tt__EventSubscription *Events;	/* optional element of type tt:EventSubscription */
	bool *Analytics;	/* optional element of type xsd:boolean */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 214; } /* = unique id SOAP_TYPE_tt__MetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfiguration(): PTZStatus(NULL), Events(NULL), Analytics(NULL), Multicast(NULL), __anyAttribute(NULL) { tt__MetadataConfiguration::soap_default(NULL); }
	virtual ~tt__MetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (224)
/* tt:NetworkInterface */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	tt__NetworkInterfaceInfo *Info;	/* optional element of type tt:NetworkInterfaceInfo */
	tt__NetworkInterfaceLink *Link;	/* optional element of type tt:NetworkInterfaceLink */
	tt__IPv4NetworkInterface *IPv4;	/* optional element of type tt:IPv4NetworkInterface */
	tt__IPv6NetworkInterface *IPv6;	/* optional element of type tt:IPv6NetworkInterface */
	tt__NetworkInterfaceExtension *Extension;	/* optional element of type tt:NetworkInterfaceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 224; } /* = unique id SOAP_TYPE_tt__NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterface(): Info(NULL), Link(NULL), IPv4(NULL), IPv6(NULL), Extension(NULL), __anyAttribute(NULL) { tt__NetworkInterface::soap_default(NULL); }
	virtual ~tt__NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (299)
/* tt:RelayOutput */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity
{
public:
	tt__RelayOutputSettings *Properties;	/* required element of type tt:RelayOutputSettings */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 299; } /* = unique id SOAP_TYPE_tt__RelayOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayOutput(): Properties(NULL), __anyAttribute(NULL) { tt__RelayOutput::soap_default(NULL); }
	virtual ~tt__RelayOutput() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (300)
/* tt:PTZNode */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity
{
public:
	std::string *Name;	/* optional element of type tt:Name */
	tt__PTZSpaces *SupportedPTZSpaces;	/* required element of type tt:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of type xsd:int */
	bool HomeSupported;	/* required element of type xsd:boolean */
	std::vector<std::string >AuxiliaryCommands;	/* optional element of type tt:AuxiliaryData */
	tt__PTZNodeExtension *Extension;	/* optional element of type tt:PTZNodeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 300; } /* = unique id SOAP_TYPE_tt__PTZNode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNode(): Name(NULL), SupportedPTZSpaces(NULL), Extension(NULL), __anyAttribute(NULL) { tt__PTZNode::soap_default(NULL); }
	virtual ~tt__PTZNode() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (302)
/* tt:PTZConfiguration */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity
{
public:
	std::string NodeToken;	/* required element of type tt:ReferenceToken */
	std::string *DefaultAbsolutePantTiltPositionSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultAbsoluteZoomPositionSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultRelativePanTiltTranslationSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultRelativeZoomTranslationSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultContinuousPanTiltVelocitySpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultContinuousZoomVelocitySpace;	/* optional element of type xsd:anyURI */
	tt__PTZSpeed *DefaultPTZSpeed;	/* optional element of type tt:PTZSpeed */
	LONG64 *DefaultPTZTimeout;	/* optional element of type xsd:duration */
	tt__PanTiltLimits *PanTiltLimits;	/* optional element of type tt:PanTiltLimits */
	tt__ZoomLimits *ZoomLimits;	/* optional element of type tt:ZoomLimits */
	tt__PTZConfigurationExtension *Extension;	/* optional element of type tt:PTZConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 302; } /* = unique id SOAP_TYPE_tt__PTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfiguration(): DefaultAbsolutePantTiltPositionSpace(NULL), DefaultAbsoluteZoomPositionSpace(NULL), DefaultRelativePanTiltTranslationSpace(NULL), DefaultRelativeZoomTranslationSpace(NULL), DefaultContinuousPanTiltVelocitySpace(NULL), DefaultContinuousZoomVelocitySpace(NULL), DefaultPTZSpeed(NULL), DefaultPTZTimeout(NULL), PanTiltLimits(NULL), ZoomLimits(NULL), Extension(NULL), __anyAttribute(NULL) { tt__PTZConfiguration::soap_default(NULL); }
	virtual ~tt__PTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Object
#define SOAP_TYPE_tt__Object (386)
/* tt:Object */
class SOAP_CMAC tt__Object : public tt__ObjectId
{
public:
	tt__Appearance *Appearance;	/* optional element of type tt:Appearance */
	tt__Behaviour *Behaviour;	/* optional element of type tt:Behaviour */
	tt__ObjectExtension *Extension;	/* optional element of type tt:ObjectExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 386; } /* = unique id SOAP_TYPE_tt__Object */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Object(): Appearance(NULL), Behaviour(NULL), Extension(NULL), __anyAttribute(NULL) { tt__Object::soap_default(NULL); }
	virtual ~tt__Object() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubscribeCreationFailedFaultType
#define SOAP_TYPE_ns1__SubscribeCreationFailedFaultType (425)
/* ns1:SubscribeCreationFailedFaultType */
class SOAP_CMAC ns1__SubscribeCreationFailedFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 425; } /* = unique id SOAP_TYPE_ns1__SubscribeCreationFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubscribeCreationFailedFaultType() { ns1__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~ns1__SubscribeCreationFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InvalidFilterFaultType
#define SOAP_TYPE_ns1__InvalidFilterFaultType (426)
/* ns1:InvalidFilterFaultType */
class SOAP_CMAC ns1__InvalidFilterFaultType : public ns2__BaseFaultType
{
public:
	std::vector<xsd__QName >UnknownFilter;	/* required element of type xsd:QName */
public:
	virtual int soap_type() const { return 426; } /* = unique id SOAP_TYPE_ns1__InvalidFilterFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InvalidFilterFaultType() { ns1__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~ns1__InvalidFilterFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_ns1__TopicExpressionDialectUnknownFaultType (427)
/* ns1:TopicExpressionDialectUnknownFaultType */
class SOAP_CMAC ns1__TopicExpressionDialectUnknownFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 427; } /* = unique id SOAP_TYPE_ns1__TopicExpressionDialectUnknownFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TopicExpressionDialectUnknownFaultType() { ns1__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~ns1__TopicExpressionDialectUnknownFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InvalidTopicExpressionFaultType
#define SOAP_TYPE_ns1__InvalidTopicExpressionFaultType (428)
/* ns1:InvalidTopicExpressionFaultType */
class SOAP_CMAC ns1__InvalidTopicExpressionFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 428; } /* = unique id SOAP_TYPE_ns1__InvalidTopicExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InvalidTopicExpressionFaultType() { ns1__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~ns1__InvalidTopicExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TopicNotSupportedFaultType
#define SOAP_TYPE_ns1__TopicNotSupportedFaultType (429)
/* ns1:TopicNotSupportedFaultType */
class SOAP_CMAC ns1__TopicNotSupportedFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 429; } /* = unique id SOAP_TYPE_ns1__TopicNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TopicNotSupportedFaultType() { ns1__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~ns1__TopicNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_ns1__MultipleTopicsSpecifiedFaultType (430)
/* ns1:MultipleTopicsSpecifiedFaultType */
class SOAP_CMAC ns1__MultipleTopicsSpecifiedFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 430; } /* = unique id SOAP_TYPE_ns1__MultipleTopicsSpecifiedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MultipleTopicsSpecifiedFaultType() { ns1__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~ns1__MultipleTopicsSpecifiedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_ns1__InvalidProducerPropertiesExpressionFaultType (431)
/* ns1:InvalidProducerPropertiesExpressionFaultType */
class SOAP_CMAC ns1__InvalidProducerPropertiesExpressionFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 431; } /* = unique id SOAP_TYPE_ns1__InvalidProducerPropertiesExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InvalidProducerPropertiesExpressionFaultType() { ns1__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~ns1__InvalidProducerPropertiesExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_ns1__InvalidMessageContentExpressionFaultType (432)
/* ns1:InvalidMessageContentExpressionFaultType */
class SOAP_CMAC ns1__InvalidMessageContentExpressionFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 432; } /* = unique id SOAP_TYPE_ns1__InvalidMessageContentExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InvalidMessageContentExpressionFaultType() { ns1__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~ns1__InvalidMessageContentExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_ns1__UnrecognizedPolicyRequestFaultType (433)
/* ns1:UnrecognizedPolicyRequestFaultType */
class SOAP_CMAC ns1__UnrecognizedPolicyRequestFaultType : public ns2__BaseFaultType
{
public:
	std::vector<xsd__QName >UnrecognizedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 433; } /* = unique id SOAP_TYPE_ns1__UnrecognizedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnrecognizedPolicyRequestFaultType() { ns1__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~ns1__UnrecognizedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_ns1__UnsupportedPolicyRequestFaultType (434)
/* ns1:UnsupportedPolicyRequestFaultType */
class SOAP_CMAC ns1__UnsupportedPolicyRequestFaultType : public ns2__BaseFaultType
{
public:
	std::vector<xsd__QName >UnsupportedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 434; } /* = unique id SOAP_TYPE_ns1__UnsupportedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnsupportedPolicyRequestFaultType() { ns1__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~ns1__UnsupportedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_ns1__NotifyMessageNotSupportedFaultType (435)
/* ns1:NotifyMessageNotSupportedFaultType */
class SOAP_CMAC ns1__NotifyMessageNotSupportedFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 435; } /* = unique id SOAP_TYPE_ns1__NotifyMessageNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NotifyMessageNotSupportedFaultType() { ns1__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~ns1__NotifyMessageNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_ns1__UnacceptableInitialTerminationTimeFaultType (436)
/* ns1:UnacceptableInitialTerminationTimeFaultType */
class SOAP_CMAC ns1__UnacceptableInitialTerminationTimeFaultType : public ns2__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 436; } /* = unique id SOAP_TYPE_ns1__UnacceptableInitialTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnacceptableInitialTerminationTimeFaultType(): MaximumTime(NULL) { ns1__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~ns1__UnacceptableInitialTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_ns1__NoCurrentMessageOnTopicFaultType (437)
/* ns1:NoCurrentMessageOnTopicFaultType */
class SOAP_CMAC ns1__NoCurrentMessageOnTopicFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 437; } /* = unique id SOAP_TYPE_ns1__NoCurrentMessageOnTopicFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NoCurrentMessageOnTopicFaultType() { ns1__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~ns1__NoCurrentMessageOnTopicFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnableToGetMessagesFaultType
#define SOAP_TYPE_ns1__UnableToGetMessagesFaultType (438)
/* ns1:UnableToGetMessagesFaultType */
class SOAP_CMAC ns1__UnableToGetMessagesFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 438; } /* = unique id SOAP_TYPE_ns1__UnableToGetMessagesFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnableToGetMessagesFaultType() { ns1__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~ns1__UnableToGetMessagesFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_ns1__UnableToDestroyPullPointFaultType (439)
/* ns1:UnableToDestroyPullPointFaultType */
class SOAP_CMAC ns1__UnableToDestroyPullPointFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 439; } /* = unique id SOAP_TYPE_ns1__UnableToDestroyPullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnableToDestroyPullPointFaultType() { ns1__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~ns1__UnableToDestroyPullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnableToCreatePullPointFaultType
#define SOAP_TYPE_ns1__UnableToCreatePullPointFaultType (440)
/* ns1:UnableToCreatePullPointFaultType */
class SOAP_CMAC ns1__UnableToCreatePullPointFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 440; } /* = unique id SOAP_TYPE_ns1__UnableToCreatePullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnableToCreatePullPointFaultType() { ns1__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~ns1__UnableToCreatePullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_ns1__UnacceptableTerminationTimeFaultType (441)
/* ns1:UnacceptableTerminationTimeFaultType */
class SOAP_CMAC ns1__UnacceptableTerminationTimeFaultType : public ns2__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 441; } /* = unique id SOAP_TYPE_ns1__UnacceptableTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnacceptableTerminationTimeFaultType(): MaximumTime(NULL) { ns1__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~ns1__UnacceptableTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_ns1__UnableToDestroySubscriptionFaultType (442)
/* ns1:UnableToDestroySubscriptionFaultType */
class SOAP_CMAC ns1__UnableToDestroySubscriptionFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 442; } /* = unique id SOAP_TYPE_ns1__UnableToDestroySubscriptionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UnableToDestroySubscriptionFaultType() { ns1__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~ns1__UnableToDestroySubscriptionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PauseFailedFaultType
#define SOAP_TYPE_ns1__PauseFailedFaultType (443)
/* ns1:PauseFailedFaultType */
class SOAP_CMAC ns1__PauseFailedFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 443; } /* = unique id SOAP_TYPE_ns1__PauseFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PauseFailedFaultType() { ns1__PauseFailedFaultType::soap_default(NULL); }
	virtual ~ns1__PauseFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ResumeFailedFaultType
#define SOAP_TYPE_ns1__ResumeFailedFaultType (444)
/* ns1:ResumeFailedFaultType */
class SOAP_CMAC ns1__ResumeFailedFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 444; } /* = unique id SOAP_TYPE_ns1__ResumeFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ResumeFailedFaultType() { ns1__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~ns1__ResumeFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__TopicNamespaceType_Topic
#define SOAP_TYPE__ns3__TopicNamespaceType_Topic (1252)
/* ns3:TopicNamespaceType-Topic */
class SOAP_CMAC _ns3__TopicNamespaceType_Topic
{
public:
	ns3__Documentation *documentation;	/* optional element of type ns3:Documentation */
	char *__anyAttribute;	/* optional attribute */
	ns3__QueryExpressionType *MessagePattern;	/* optional element of type ns3:QueryExpressionType */
	std::vector<class ns3__TopicType * >Topic;	/* optional element of type ns3:TopicType */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	std::string *messageTypes;	/* optional attribute */
	bool final;	/* optional attribute */
	std::string *parent;	/* optional attribute */
public:
	virtual int soap_type() const { return 1252; } /* = unique id SOAP_TYPE__ns3__TopicNamespaceType_Topic */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__TopicNamespaceType_Topic(): documentation(NULL), __anyAttribute(NULL), MessagePattern(NULL), messageTypes(NULL), parent(NULL) { _ns3__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_ns3__TopicNamespaceType_Topic() { }
};
#endif

#ifndef SOAP_TYPE_ns3__TopicNamespaceType
#define SOAP_TYPE_ns3__TopicNamespaceType (471)
/* ns3:TopicNamespaceType */
class SOAP_CMAC ns3__TopicNamespaceType : public ns3__ExtensibleDocumented
{
public:
	int __sizeTopic;	/* sequence of elements <Topic> */
	_ns3__TopicNamespaceType_Topic *Topic;	/* optional element of type ns3:TopicNamespaceType-Topic */
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	std::string targetNamespace;	/* required attribute */
	bool final;	/* optional attribute */
public:
	virtual int soap_type() const { return 471; } /* = unique id SOAP_TYPE_ns3__TopicNamespaceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__TopicNamespaceType(): Topic(NULL), name(NULL) { ns3__TopicNamespaceType::soap_default(NULL); }
	virtual ~ns3__TopicNamespaceType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__TopicType
#define SOAP_TYPE_ns3__TopicType (472)
/* ns3:TopicType */
class SOAP_CMAC ns3__TopicType : public ns3__ExtensibleDocumented
{
public:
	ns3__QueryExpressionType *MessagePattern;	/* optional element of type ns3:QueryExpressionType */
	std::vector<ns3__TopicType * >Topic;	/* optional element of type ns3:TopicType */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	std::string *messageTypes;	/* optional attribute */
	bool final;	/* optional attribute */
public:
	virtual int soap_type() const { return 472; } /* = unique id SOAP_TYPE_ns3__TopicType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__TopicType(): MessagePattern(NULL), messageTypes(NULL) { ns3__TopicType::soap_default(NULL); }
	virtual ~ns3__TopicType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__TopicSetType
#define SOAP_TYPE_ns3__TopicSetType (473)
/* ns3:TopicSetType */
class SOAP_CMAC ns3__TopicSetType : public ns3__ExtensibleDocumented
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 473; } /* = unique id SOAP_TYPE_ns3__TopicSetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__TopicSetType() { ns3__TopicSetType::soap_default(NULL); }
	virtual ~ns3__TopicSetType() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ResourceUnknownFaultType
#define SOAP_TYPE_ns5__ResourceUnknownFaultType (603)
/* ns5:ResourceUnknownFaultType */
class SOAP_CMAC ns5__ResourceUnknownFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 603; } /* = unique id SOAP_TYPE_ns5__ResourceUnknownFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ResourceUnknownFaultType() { ns5__ResourceUnknownFaultType::soap_default(NULL); }
	virtual ~ns5__ResourceUnknownFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ResourceUnavailableFaultType
#define SOAP_TYPE_ns5__ResourceUnavailableFaultType (604)
/* ns5:ResourceUnavailableFaultType */
class SOAP_CMAC ns5__ResourceUnavailableFaultType : public ns2__BaseFaultType
{
public:
	virtual int soap_type() const { return 604; } /* = unique id SOAP_TYPE_ns5__ResourceUnavailableFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ResourceUnavailableFaultType() { ns5__ResourceUnavailableFaultType::soap_default(NULL); }
	virtual ~ns5__ResourceUnavailableFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ScopesType
#define SOAP_TYPE_ns6__ScopesType (773)
/* Primitive ns6:ScopesType schema type: */
class SOAP_CMAC ns6__ScopesType : public xsd__anyType
{
public:
	std::string __item;
	std::string *MatchBy;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 773; } /* = unique id SOAP_TYPE_ns6__ScopesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ScopesType(): MatchBy(NULL), __anyAttribute(NULL) { ns6__ScopesType::soap_default(NULL); }
	virtual ~ns6__ScopesType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__AppSequenceType
#define SOAP_TYPE_ns6__AppSequenceType (776)
/* Primitive ns6:AppSequenceType schema type: */
class SOAP_CMAC ns6__AppSequenceType : public xsd__anyType
{
public:
	unsigned int InstanceId;	/* required attribute */
	std::string *SequenceId;	/* optional attribute */
	unsigned int MessageNumber;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 776; } /* = unique id SOAP_TYPE_ns6__AppSequenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__AppSequenceType(): SequenceId(NULL), __anyAttribute(NULL) { ns6__AppSequenceType::soap_default(NULL); }
	virtual ~ns6__AppSequenceType() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1259)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	_tev__PullMessagesFaultResponse *tev__PullMessagesFaultResponse;	/* optional element of type tev:PullMessagesFaultResponse */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns10__PullMessages
#define SOAP_TYPE___ns10__PullMessages (1266)
/* Operation wrapper: */
struct __ns10__PullMessages
{
public:
	_tev__PullMessages *tev__PullMessages;	/* optional element of type tev:PullMessages */
};
#endif

#ifndef SOAP_TYPE___ns10__SetSynchronizationPoint
#define SOAP_TYPE___ns10__SetSynchronizationPoint (1270)
/* Operation wrapper: */
struct __ns10__SetSynchronizationPoint
{
public:
	_tev__SetSynchronizationPoint *tev__SetSynchronizationPoint;	/* optional element of type tev:SetSynchronizationPoint */
};
#endif

#ifndef SOAP_TYPE___ns11__CreatePullPointSubscription
#define SOAP_TYPE___ns11__CreatePullPointSubscription (1274)
/* Operation wrapper: */
struct __ns11__CreatePullPointSubscription
{
public:
	_tev__CreatePullPointSubscription *tev__CreatePullPointSubscription;	/* optional element of type tev:CreatePullPointSubscription */
};
#endif

#ifndef SOAP_TYPE___ns11__GetEventProperties
#define SOAP_TYPE___ns11__GetEventProperties (1278)
/* Operation wrapper: */
struct __ns11__GetEventProperties
{
public:
	_tev__GetEventProperties *tev__GetEventProperties;	/* optional element of type tev:GetEventProperties */
};
#endif

#ifndef SOAP_TYPE___ns12__Renew
#define SOAP_TYPE___ns12__Renew (1282)
/* Operation wrapper: */
struct __ns12__Renew
{
public:
	_ns1__Renew *ns1__Renew;	/* optional element of type ns1:Renew */
};
#endif

#ifndef SOAP_TYPE___ns12__Unsubscribe
#define SOAP_TYPE___ns12__Unsubscribe (1286)
/* Operation wrapper: */
struct __ns12__Unsubscribe
{
public:
	_ns1__Unsubscribe *ns1__Unsubscribe;	/* optional element of type ns1:Unsubscribe */
};
#endif

#ifndef SOAP_TYPE___ns13__Subscribe
#define SOAP_TYPE___ns13__Subscribe (1290)
/* Operation wrapper: */
struct __ns13__Subscribe
{
public:
	_ns1__Subscribe *ns1__Subscribe;	/* optional element of type ns1:Subscribe */
};
#endif

#ifndef SOAP_TYPE___ns13__GetCurrentMessage
#define SOAP_TYPE___ns13__GetCurrentMessage (1294)
/* Operation wrapper: */
struct __ns13__GetCurrentMessage
{
public:
	_ns1__GetCurrentMessage *ns1__GetCurrentMessage;	/* optional element of type ns1:GetCurrentMessage */
};
#endif

#ifndef SOAP_TYPE___ns14__Notify
#define SOAP_TYPE___ns14__Notify (1297)
/* Operation wrapper: */
struct __ns14__Notify
{
public:
	_ns1__Notify *ns1__Notify;	/* optional element of type ns1:Notify */
};
#endif

#ifndef SOAP_TYPE___ns15__GetMessages
#define SOAP_TYPE___ns15__GetMessages (1301)
/* Operation wrapper: */
struct __ns15__GetMessages
{
public:
	_ns1__GetMessages *ns1__GetMessages;	/* optional element of type ns1:GetMessages */
};
#endif

#ifndef SOAP_TYPE___ns15__DestroyPullPoint
#define SOAP_TYPE___ns15__DestroyPullPoint (1305)
/* Operation wrapper: */
struct __ns15__DestroyPullPoint
{
public:
	_ns1__DestroyPullPoint *ns1__DestroyPullPoint;	/* optional element of type ns1:DestroyPullPoint */
};
#endif

#ifndef SOAP_TYPE___ns15__Notify
#define SOAP_TYPE___ns15__Notify (1307)
/* Operation wrapper: */
struct __ns15__Notify
{
public:
	_ns1__Notify *ns1__Notify;	/* optional element of type ns1:Notify */
};
#endif

#ifndef SOAP_TYPE___ns16__CreatePullPoint
#define SOAP_TYPE___ns16__CreatePullPoint (1311)
/* Operation wrapper: */
struct __ns16__CreatePullPoint
{
public:
	_ns1__CreatePullPoint *ns1__CreatePullPoint;	/* optional element of type ns1:CreatePullPoint */
};
#endif

#ifndef SOAP_TYPE___ns17__Renew
#define SOAP_TYPE___ns17__Renew (1313)
/* Operation wrapper: */
struct __ns17__Renew
{
public:
	_ns1__Renew *ns1__Renew;	/* optional element of type ns1:Renew */
};
#endif

#ifndef SOAP_TYPE___ns17__Unsubscribe
#define SOAP_TYPE___ns17__Unsubscribe (1315)
/* Operation wrapper: */
struct __ns17__Unsubscribe
{
public:
	_ns1__Unsubscribe *ns1__Unsubscribe;	/* optional element of type ns1:Unsubscribe */
};
#endif

#ifndef SOAP_TYPE___ns17__PauseSubscription
#define SOAP_TYPE___ns17__PauseSubscription (1319)
/* Operation wrapper: */
struct __ns17__PauseSubscription
{
public:
	_ns1__PauseSubscription *ns1__PauseSubscription;	/* optional element of type ns1:PauseSubscription */
};
#endif

#ifndef SOAP_TYPE___ns17__ResumeSubscription
#define SOAP_TYPE___ns17__ResumeSubscription (1323)
/* Operation wrapper: */
struct __ns17__ResumeSubscription
{
public:
	_ns1__ResumeSubscription *ns1__ResumeSubscription;	/* optional element of type ns1:ResumeSubscription */
};
#endif

#ifndef SOAP_TYPE___ns18__Hello
#define SOAP_TYPE___ns18__Hello (1327)
/* Operation wrapper: */
struct __ns18__Hello
{
public:
	ns6__HelloType *dn__Hello;	/* optional element of type ns6:HelloType */
};
#endif

#ifndef SOAP_TYPE___ns18__Bye
#define SOAP_TYPE___ns18__Bye (1330)
/* Operation wrapper: */
struct __ns18__Bye
{
public:
	ns6__ByeType *dn__Bye;	/* optional element of type ns6:ByeType */
};
#endif

#ifndef SOAP_TYPE___ns19__Probe
#define SOAP_TYPE___ns19__Probe (1334)
/* Operation wrapper: */
struct __ns19__Probe
{
public:
	ns6__ProbeType *dn__Probe;	/* optional element of type ns6:ProbeType */
};
#endif

#ifndef SOAP_TYPE___ns8__GetSupportedRules
#define SOAP_TYPE___ns8__GetSupportedRules (1338)
/* Operation wrapper: */
struct __ns8__GetSupportedRules
{
public:
	_tan__GetSupportedRules *tan__GetSupportedRules;	/* optional element of type tan:GetSupportedRules */
};
#endif

#ifndef SOAP_TYPE___ns8__CreateRules
#define SOAP_TYPE___ns8__CreateRules (1342)
/* Operation wrapper: */
struct __ns8__CreateRules
{
public:
	_tan__CreateRules *tan__CreateRules;	/* optional element of type tan:CreateRules */
};
#endif

#ifndef SOAP_TYPE___ns8__DeleteRules
#define SOAP_TYPE___ns8__DeleteRules (1346)
/* Operation wrapper: */
struct __ns8__DeleteRules
{
public:
	_tan__DeleteRules *tan__DeleteRules;	/* optional element of type tan:DeleteRules */
};
#endif

#ifndef SOAP_TYPE___ns8__GetRules
#define SOAP_TYPE___ns8__GetRules (1350)
/* Operation wrapper: */
struct __ns8__GetRules
{
public:
	_tan__GetRules *tan__GetRules;	/* optional element of type tan:GetRules */
};
#endif

#ifndef SOAP_TYPE___ns8__ModifyRules
#define SOAP_TYPE___ns8__ModifyRules (1354)
/* Operation wrapper: */
struct __ns8__ModifyRules
{
public:
	_tan__ModifyRules *tan__ModifyRules;	/* optional element of type tan:ModifyRules */
};
#endif

#ifndef SOAP_TYPE___ns9__GetSupportedAnalyticsModules
#define SOAP_TYPE___ns9__GetSupportedAnalyticsModules (1358)
/* Operation wrapper: */
struct __ns9__GetSupportedAnalyticsModules
{
public:
	_tan__GetSupportedAnalyticsModules *tan__GetSupportedAnalyticsModules;	/* optional element of type tan:GetSupportedAnalyticsModules */
};
#endif

#ifndef SOAP_TYPE___ns9__CreateAnalyticsModules
#define SOAP_TYPE___ns9__CreateAnalyticsModules (1362)
/* Operation wrapper: */
struct __ns9__CreateAnalyticsModules
{
public:
	_tan__CreateAnalyticsModules *tan__CreateAnalyticsModules;	/* optional element of type tan:CreateAnalyticsModules */
};
#endif

#ifndef SOAP_TYPE___ns9__DeleteAnalyticsModules
#define SOAP_TYPE___ns9__DeleteAnalyticsModules (1366)
/* Operation wrapper: */
struct __ns9__DeleteAnalyticsModules
{
public:
	_tan__DeleteAnalyticsModules *tan__DeleteAnalyticsModules;	/* optional element of type tan:DeleteAnalyticsModules */
};
#endif

#ifndef SOAP_TYPE___ns9__GetAnalyticsModules
#define SOAP_TYPE___ns9__GetAnalyticsModules (1370)
/* Operation wrapper: */
struct __ns9__GetAnalyticsModules
{
public:
	_tan__GetAnalyticsModules *tan__GetAnalyticsModules;	/* optional element of type tan:GetAnalyticsModules */
};
#endif

#ifndef SOAP_TYPE___ns9__ModifyAnalyticsModules
#define SOAP_TYPE___ns9__ModifyAnalyticsModules (1374)
/* Operation wrapper: */
struct __ns9__ModifyAnalyticsModules
{
public:
	_tan__ModifyAnalyticsModules *tan__ModifyAnalyticsModules;	/* optional element of type tan:ModifyAnalyticsModules */
};
#endif

#ifndef SOAP_TYPE___tds__GetDeviceInformation
#define SOAP_TYPE___tds__GetDeviceInformation (1378)
/* Operation wrapper: */
struct __tds__GetDeviceInformation
{
public:
	_tds__GetDeviceInformation *tds__GetDeviceInformation;	/* optional element of type tds:GetDeviceInformation */
};
#endif

#ifndef SOAP_TYPE___tds__SetSystemDateAndTime
#define SOAP_TYPE___tds__SetSystemDateAndTime (1382)
/* Operation wrapper: */
struct __tds__SetSystemDateAndTime
{
public:
	_tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;	/* optional element of type tds:SetSystemDateAndTime */
};
#endif

#ifndef SOAP_TYPE___tds__GetSystemDateAndTime
#define SOAP_TYPE___tds__GetSystemDateAndTime (1386)
/* Operation wrapper: */
struct __tds__GetSystemDateAndTime
{
public:
	_tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;	/* optional element of type tds:GetSystemDateAndTime */
};
#endif

#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault
#define SOAP_TYPE___tds__SetSystemFactoryDefault (1390)
/* Operation wrapper: */
struct __tds__SetSystemFactoryDefault
{
public:
	_tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;	/* optional element of type tds:SetSystemFactoryDefault */
};
#endif

#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware
#define SOAP_TYPE___tds__UpgradeSystemFirmware (1394)
/* Operation wrapper: */
struct __tds__UpgradeSystemFirmware
{
public:
	_tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;	/* optional element of type tds:UpgradeSystemFirmware */
};
#endif

#ifndef SOAP_TYPE___tds__SystemReboot
#define SOAP_TYPE___tds__SystemReboot (1398)
/* Operation wrapper: */
struct __tds__SystemReboot
{
public:
	_tds__SystemReboot *tds__SystemReboot;	/* optional element of type tds:SystemReboot */
};
#endif

#ifndef SOAP_TYPE___tds__RestoreSystem
#define SOAP_TYPE___tds__RestoreSystem (1402)
/* Operation wrapper: */
struct __tds__RestoreSystem
{
public:
	_tds__RestoreSystem *tds__RestoreSystem;	/* optional element of type tds:RestoreSystem */
};
#endif

#ifndef SOAP_TYPE___tds__GetSystemBackup
#define SOAP_TYPE___tds__GetSystemBackup (1406)
/* Operation wrapper: */
struct __tds__GetSystemBackup
{
public:
	_tds__GetSystemBackup *tds__GetSystemBackup;	/* optional element of type tds:GetSystemBackup */
};
#endif

#ifndef SOAP_TYPE___tds__GetSystemLog
#define SOAP_TYPE___tds__GetSystemLog (1410)
/* Operation wrapper: */
struct __tds__GetSystemLog
{
public:
	_tds__GetSystemLog *tds__GetSystemLog;	/* optional element of type tds:GetSystemLog */
};
#endif

#ifndef SOAP_TYPE___tds__GetSystemSupportInformation
#define SOAP_TYPE___tds__GetSystemSupportInformation (1414)
/* Operation wrapper: */
struct __tds__GetSystemSupportInformation
{
public:
	_tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;	/* optional element of type tds:GetSystemSupportInformation */
};
#endif

#ifndef SOAP_TYPE___tds__GetScopes
#define SOAP_TYPE___tds__GetScopes (1418)
/* Operation wrapper: */
struct __tds__GetScopes
{
public:
	_tds__GetScopes *tds__GetScopes;	/* optional element of type tds:GetScopes */
};
#endif

#ifndef SOAP_TYPE___tds__SetScopes
#define SOAP_TYPE___tds__SetScopes (1422)
/* Operation wrapper: */
struct __tds__SetScopes
{
public:
	_tds__SetScopes *tds__SetScopes;	/* optional element of type tds:SetScopes */
};
#endif

#ifndef SOAP_TYPE___tds__AddScopes
#define SOAP_TYPE___tds__AddScopes (1426)
/* Operation wrapper: */
struct __tds__AddScopes
{
public:
	_tds__AddScopes *tds__AddScopes;	/* optional element of type tds:AddScopes */
};
#endif

#ifndef SOAP_TYPE___tds__RemoveScopes
#define SOAP_TYPE___tds__RemoveScopes (1430)
/* Operation wrapper: */
struct __tds__RemoveScopes
{
public:
	_tds__RemoveScopes *tds__RemoveScopes;	/* optional element of type tds:RemoveScopes */
};
#endif

#ifndef SOAP_TYPE___tds__GetDiscoveryMode
#define SOAP_TYPE___tds__GetDiscoveryMode (1434)
/* Operation wrapper: */
struct __tds__GetDiscoveryMode
{
public:
	_tds__GetDiscoveryMode *tds__GetDiscoveryMode;	/* optional element of type tds:GetDiscoveryMode */
};
#endif

#ifndef SOAP_TYPE___tds__SetDiscoveryMode
#define SOAP_TYPE___tds__SetDiscoveryMode (1438)
/* Operation wrapper: */
struct __tds__SetDiscoveryMode
{
public:
	_tds__SetDiscoveryMode *tds__SetDiscoveryMode;	/* optional element of type tds:SetDiscoveryMode */
};
#endif

#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode (1442)
/* Operation wrapper: */
struct __tds__GetRemoteDiscoveryMode
{
public:
	_tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;	/* optional element of type tds:GetRemoteDiscoveryMode */
};
#endif

#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode (1446)
/* Operation wrapper: */
struct __tds__SetRemoteDiscoveryMode
{
public:
	_tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;	/* optional element of type tds:SetRemoteDiscoveryMode */
};
#endif

#ifndef SOAP_TYPE___tds__GetDPAddresses
#define SOAP_TYPE___tds__GetDPAddresses (1450)
/* Operation wrapper: */
struct __tds__GetDPAddresses
{
public:
	_tds__GetDPAddresses *tds__GetDPAddresses;	/* optional element of type tds:GetDPAddresses */
};
#endif

#ifndef SOAP_TYPE___tds__GetUsers
#define SOAP_TYPE___tds__GetUsers (1454)
/* Operation wrapper: */
struct __tds__GetUsers
{
public:
	_tds__GetUsers *tds__GetUsers;	/* optional element of type tds:GetUsers */
};
#endif

#ifndef SOAP_TYPE___tds__CreateUsers
#define SOAP_TYPE___tds__CreateUsers (1458)
/* Operation wrapper: */
struct __tds__CreateUsers
{
public:
	_tds__CreateUsers *tds__CreateUsers;	/* optional element of type tds:CreateUsers */
};
#endif

#ifndef SOAP_TYPE___tds__DeleteUsers
#define SOAP_TYPE___tds__DeleteUsers (1462)
/* Operation wrapper: */
struct __tds__DeleteUsers
{
public:
	_tds__DeleteUsers *tds__DeleteUsers;	/* optional element of type tds:DeleteUsers */
};
#endif

#ifndef SOAP_TYPE___tds__SetUser
#define SOAP_TYPE___tds__SetUser (1466)
/* Operation wrapper: */
struct __tds__SetUser
{
public:
	_tds__SetUser *tds__SetUser;	/* optional element of type tds:SetUser */
};
#endif

#ifndef SOAP_TYPE___tds__GetWsdlUrl
#define SOAP_TYPE___tds__GetWsdlUrl (1470)
/* Operation wrapper: */
struct __tds__GetWsdlUrl
{
public:
	_tds__GetWsdlUrl *tds__GetWsdlUrl;	/* optional element of type tds:GetWsdlUrl */
};
#endif

#ifndef SOAP_TYPE___tds__GetCapabilities
#define SOAP_TYPE___tds__GetCapabilities (1474)
/* Operation wrapper: */
struct __tds__GetCapabilities
{
public:
	_tds__GetCapabilities *tds__GetCapabilities;	/* optional element of type tds:GetCapabilities */
};
#endif

#ifndef SOAP_TYPE___tds__SetDPAddresses
#define SOAP_TYPE___tds__SetDPAddresses (1478)
/* Operation wrapper: */
struct __tds__SetDPAddresses
{
public:
	_tds__SetDPAddresses *tds__SetDPAddresses;	/* optional element of type tds:SetDPAddresses */
};
#endif

#ifndef SOAP_TYPE___tds__GetHostname
#define SOAP_TYPE___tds__GetHostname (1482)
/* Operation wrapper: */
struct __tds__GetHostname
{
public:
	_tds__GetHostname *tds__GetHostname;	/* optional element of type tds:GetHostname */
};
#endif

#ifndef SOAP_TYPE___tds__SetHostname
#define SOAP_TYPE___tds__SetHostname (1486)
/* Operation wrapper: */
struct __tds__SetHostname
{
public:
	_tds__SetHostname *tds__SetHostname;	/* optional element of type tds:SetHostname */
};
#endif

#ifndef SOAP_TYPE___tds__GetDNS
#define SOAP_TYPE___tds__GetDNS (1490)
/* Operation wrapper: */
struct __tds__GetDNS
{
public:
	_tds__GetDNS *tds__GetDNS;	/* optional element of type tds:GetDNS */
};
#endif

#ifndef SOAP_TYPE___tds__SetDNS
#define SOAP_TYPE___tds__SetDNS (1494)
/* Operation wrapper: */
struct __tds__SetDNS
{
public:
	_tds__SetDNS *tds__SetDNS;	/* optional element of type tds:SetDNS */
};
#endif

#ifndef SOAP_TYPE___tds__GetNTP
#define SOAP_TYPE___tds__GetNTP (1498)
/* Operation wrapper: */
struct __tds__GetNTP
{
public:
	_tds__GetNTP *tds__GetNTP;	/* optional element of type tds:GetNTP */
};
#endif

#ifndef SOAP_TYPE___tds__SetNTP
#define SOAP_TYPE___tds__SetNTP (1502)
/* Operation wrapper: */
struct __tds__SetNTP
{
public:
	_tds__SetNTP *tds__SetNTP;	/* optional element of type tds:SetNTP */
};
#endif

#ifndef SOAP_TYPE___tds__GetDynamicDNS
#define SOAP_TYPE___tds__GetDynamicDNS (1506)
/* Operation wrapper: */
struct __tds__GetDynamicDNS
{
public:
	_tds__GetDynamicDNS *tds__GetDynamicDNS;	/* optional element of type tds:GetDynamicDNS */
};
#endif

#ifndef SOAP_TYPE___tds__SetDynamicDNS
#define SOAP_TYPE___tds__SetDynamicDNS (1510)
/* Operation wrapper: */
struct __tds__SetDynamicDNS
{
public:
	_tds__SetDynamicDNS *tds__SetDynamicDNS;	/* optional element of type tds:SetDynamicDNS */
};
#endif

#ifndef SOAP_TYPE___tds__GetNetworkInterfaces
#define SOAP_TYPE___tds__GetNetworkInterfaces (1514)
/* Operation wrapper: */
struct __tds__GetNetworkInterfaces
{
public:
	_tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;	/* optional element of type tds:GetNetworkInterfaces */
};
#endif

#ifndef SOAP_TYPE___tds__SetNetworkInterfaces
#define SOAP_TYPE___tds__SetNetworkInterfaces (1518)
/* Operation wrapper: */
struct __tds__SetNetworkInterfaces
{
public:
	_tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;	/* optional element of type tds:SetNetworkInterfaces */
};
#endif

#ifndef SOAP_TYPE___tds__GetNetworkProtocols
#define SOAP_TYPE___tds__GetNetworkProtocols (1522)
/* Operation wrapper: */
struct __tds__GetNetworkProtocols
{
public:
	_tds__GetNetworkProtocols *tds__GetNetworkProtocols;	/* optional element of type tds:GetNetworkProtocols */
};
#endif

#ifndef SOAP_TYPE___tds__SetNetworkProtocols
#define SOAP_TYPE___tds__SetNetworkProtocols (1526)
/* Operation wrapper: */
struct __tds__SetNetworkProtocols
{
public:
	_tds__SetNetworkProtocols *tds__SetNetworkProtocols;	/* optional element of type tds:SetNetworkProtocols */
};
#endif

#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway
#define SOAP_TYPE___tds__GetNetworkDefaultGateway (1530)
/* Operation wrapper: */
struct __tds__GetNetworkDefaultGateway
{
public:
	_tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;	/* optional element of type tds:GetNetworkDefaultGateway */
};
#endif

#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway
#define SOAP_TYPE___tds__SetNetworkDefaultGateway (1534)
/* Operation wrapper: */
struct __tds__SetNetworkDefaultGateway
{
public:
	_tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;	/* optional element of type tds:SetNetworkDefaultGateway */
};
#endif

#ifndef SOAP_TYPE___tds__GetZeroConfiguration
#define SOAP_TYPE___tds__GetZeroConfiguration (1538)
/* Operation wrapper: */
struct __tds__GetZeroConfiguration
{
public:
	_tds__GetZeroConfiguration *tds__GetZeroConfiguration;	/* optional element of type tds:GetZeroConfiguration */
};
#endif

#ifndef SOAP_TYPE___tds__SetZeroConfiguration
#define SOAP_TYPE___tds__SetZeroConfiguration (1542)
/* Operation wrapper: */
struct __tds__SetZeroConfiguration
{
public:
	_tds__SetZeroConfiguration *tds__SetZeroConfiguration;	/* optional element of type tds:SetZeroConfiguration */
};
#endif

#ifndef SOAP_TYPE___tds__GetIPAddressFilter
#define SOAP_TYPE___tds__GetIPAddressFilter (1546)
/* Operation wrapper: */
struct __tds__GetIPAddressFilter
{
public:
	_tds__GetIPAddressFilter *tds__GetIPAddressFilter;	/* optional element of type tds:GetIPAddressFilter */
};
#endif

#ifndef SOAP_TYPE___tds__SetIPAddressFilter
#define SOAP_TYPE___tds__SetIPAddressFilter (1550)
/* Operation wrapper: */
struct __tds__SetIPAddressFilter
{
public:
	_tds__SetIPAddressFilter *tds__SetIPAddressFilter;	/* optional element of type tds:SetIPAddressFilter */
};
#endif

#ifndef SOAP_TYPE___tds__AddIPAddressFilter
#define SOAP_TYPE___tds__AddIPAddressFilter (1554)
/* Operation wrapper: */
struct __tds__AddIPAddressFilter
{
public:
	_tds__AddIPAddressFilter *tds__AddIPAddressFilter;	/* optional element of type tds:AddIPAddressFilter */
};
#endif

#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter
#define SOAP_TYPE___tds__RemoveIPAddressFilter (1558)
/* Operation wrapper: */
struct __tds__RemoveIPAddressFilter
{
public:
	_tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;	/* optional element of type tds:RemoveIPAddressFilter */
};
#endif

#ifndef SOAP_TYPE___tds__GetAccessPolicy
#define SOAP_TYPE___tds__GetAccessPolicy (1562)
/* Operation wrapper: */
struct __tds__GetAccessPolicy
{
public:
	_tds__GetAccessPolicy *tds__GetAccessPolicy;	/* optional element of type tds:GetAccessPolicy */
};
#endif

#ifndef SOAP_TYPE___tds__SetAccessPolicy
#define SOAP_TYPE___tds__SetAccessPolicy (1566)
/* Operation wrapper: */
struct __tds__SetAccessPolicy
{
public:
	_tds__SetAccessPolicy *tds__SetAccessPolicy;	/* optional element of type tds:SetAccessPolicy */
};
#endif

#ifndef SOAP_TYPE___tds__CreateCertificate
#define SOAP_TYPE___tds__CreateCertificate (1570)
/* Operation wrapper: */
struct __tds__CreateCertificate
{
public:
	_tds__CreateCertificate *tds__CreateCertificate;	/* optional element of type tds:CreateCertificate */
};
#endif

#ifndef SOAP_TYPE___tds__GetCertificates
#define SOAP_TYPE___tds__GetCertificates (1574)
/* Operation wrapper: */
struct __tds__GetCertificates
{
public:
	_tds__GetCertificates *tds__GetCertificates;	/* optional element of type tds:GetCertificates */
};
#endif

#ifndef SOAP_TYPE___tds__GetCertificatesStatus
#define SOAP_TYPE___tds__GetCertificatesStatus (1578)
/* Operation wrapper: */
struct __tds__GetCertificatesStatus
{
public:
	_tds__GetCertificatesStatus *tds__GetCertificatesStatus;	/* optional element of type tds:GetCertificatesStatus */
};
#endif

#ifndef SOAP_TYPE___tds__SetCertificatesStatus
#define SOAP_TYPE___tds__SetCertificatesStatus (1582)
/* Operation wrapper: */
struct __tds__SetCertificatesStatus
{
public:
	_tds__SetCertificatesStatus *tds__SetCertificatesStatus;	/* optional element of type tds:SetCertificatesStatus */
};
#endif

#ifndef SOAP_TYPE___tds__DeleteCertificates
#define SOAP_TYPE___tds__DeleteCertificates (1586)
/* Operation wrapper: */
struct __tds__DeleteCertificates
{
public:
	_tds__DeleteCertificates *tds__DeleteCertificates;	/* optional element of type tds:DeleteCertificates */
};
#endif

#ifndef SOAP_TYPE___tds__GetPkcs10Request
#define SOAP_TYPE___tds__GetPkcs10Request (1590)
/* Operation wrapper: */
struct __tds__GetPkcs10Request
{
public:
	_tds__GetPkcs10Request *tds__GetPkcs10Request;	/* optional element of type tds:GetPkcs10Request */
};
#endif

#ifndef SOAP_TYPE___tds__LoadCertificates
#define SOAP_TYPE___tds__LoadCertificates (1594)
/* Operation wrapper: */
struct __tds__LoadCertificates
{
public:
	_tds__LoadCertificates *tds__LoadCertificates;	/* optional element of type tds:LoadCertificates */
};
#endif

#ifndef SOAP_TYPE___tds__GetClientCertificateMode
#define SOAP_TYPE___tds__GetClientCertificateMode (1598)
/* Operation wrapper: */
struct __tds__GetClientCertificateMode
{
public:
	_tds__GetClientCertificateMode *tds__GetClientCertificateMode;	/* optional element of type tds:GetClientCertificateMode */
};
#endif

#ifndef SOAP_TYPE___tds__SetClientCertificateMode
#define SOAP_TYPE___tds__SetClientCertificateMode (1602)
/* Operation wrapper: */
struct __tds__SetClientCertificateMode
{
public:
	_tds__SetClientCertificateMode *tds__SetClientCertificateMode;	/* optional element of type tds:SetClientCertificateMode */
};
#endif

#ifndef SOAP_TYPE___tds__GetRelayOutputs
#define SOAP_TYPE___tds__GetRelayOutputs (1606)
/* Operation wrapper: */
struct __tds__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of type tds:GetRelayOutputs */
};
#endif

#ifndef SOAP_TYPE___tds__SetRelayOutputSettings
#define SOAP_TYPE___tds__SetRelayOutputSettings (1610)
/* Operation wrapper: */
struct __tds__SetRelayOutputSettings
{
public:
	_tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;	/* optional element of type tds:SetRelayOutputSettings */
};
#endif

#ifndef SOAP_TYPE___tds__SetRelayOutputState
#define SOAP_TYPE___tds__SetRelayOutputState (1614)
/* Operation wrapper: */
struct __tds__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of type tds:SetRelayOutputState */
};
#endif

#ifndef SOAP_TYPE___timg__GetImagingSettings
#define SOAP_TYPE___timg__GetImagingSettings (1618)
/* Operation wrapper: */
struct __timg__GetImagingSettings
{
public:
	_timg__GetImagingSettings *timg__GetImagingSettings;	/* optional element of type timg:GetImagingSettings */
};
#endif

#ifndef SOAP_TYPE___timg__SetImagingSettings
#define SOAP_TYPE___timg__SetImagingSettings (1622)
/* Operation wrapper: */
struct __timg__SetImagingSettings
{
public:
	_timg__SetImagingSettings *timg__SetImagingSettings;	/* optional element of type timg:SetImagingSettings */
};
#endif

#ifndef SOAP_TYPE___timg__GetOptions
#define SOAP_TYPE___timg__GetOptions (1626)
/* Operation wrapper: */
struct __timg__GetOptions
{
public:
	_timg__GetOptions *timg__GetOptions;	/* optional element of type timg:GetOptions */
};
#endif

#ifndef SOAP_TYPE___timg__Move
#define SOAP_TYPE___timg__Move (1630)
/* Operation wrapper: */
struct __timg__Move
{
public:
	_timg__Move *timg__Move;	/* optional element of type timg:Move */
};
#endif

#ifndef SOAP_TYPE___timg__Stop
#define SOAP_TYPE___timg__Stop (1634)
/* Operation wrapper: */
struct __timg__Stop
{
public:
	_timg__Stop *timg__Stop;	/* optional element of type timg:Stop */
};
#endif

#ifndef SOAP_TYPE___timg__GetStatus
#define SOAP_TYPE___timg__GetStatus (1638)
/* Operation wrapper: */
struct __timg__GetStatus
{
public:
	_timg__GetStatus *timg__GetStatus;	/* optional element of type timg:GetStatus */
};
#endif

#ifndef SOAP_TYPE___timg__GetMoveOptions
#define SOAP_TYPE___timg__GetMoveOptions (1642)
/* Operation wrapper: */
struct __timg__GetMoveOptions
{
public:
	_timg__GetMoveOptions *timg__GetMoveOptions;	/* optional element of type timg:GetMoveOptions */
};
#endif

#ifndef SOAP_TYPE___tptz__GetConfigurations
#define SOAP_TYPE___tptz__GetConfigurations (1646)
/* Operation wrapper: */
struct __tptz__GetConfigurations
{
public:
	_tptz__GetConfigurations *tptz__GetConfigurations;	/* optional element of type tptz:GetConfigurations */
};
#endif

#ifndef SOAP_TYPE___tptz__GetPresets
#define SOAP_TYPE___tptz__GetPresets (1650)
/* Operation wrapper: */
struct __tptz__GetPresets
{
public:
	_tptz__GetPresets *tptz__GetPresets;	/* optional element of type tptz:GetPresets */
};
#endif

#ifndef SOAP_TYPE___tptz__SetPreset
#define SOAP_TYPE___tptz__SetPreset (1654)
/* Operation wrapper: */
struct __tptz__SetPreset
{
public:
	_tptz__SetPreset *tptz__SetPreset;	/* optional element of type tptz:SetPreset */
};
#endif

#ifndef SOAP_TYPE___tptz__RemovePreset
#define SOAP_TYPE___tptz__RemovePreset (1658)
/* Operation wrapper: */
struct __tptz__RemovePreset
{
public:
	_tptz__RemovePreset *tptz__RemovePreset;	/* optional element of type tptz:RemovePreset */
};
#endif

#ifndef SOAP_TYPE___tptz__GotoPreset
#define SOAP_TYPE___tptz__GotoPreset (1662)
/* Operation wrapper: */
struct __tptz__GotoPreset
{
public:
	_tptz__GotoPreset *tptz__GotoPreset;	/* optional element of type tptz:GotoPreset */
};
#endif

#ifndef SOAP_TYPE___tptz__GetStatus
#define SOAP_TYPE___tptz__GetStatus (1666)
/* Operation wrapper: */
struct __tptz__GetStatus
{
public:
	_tptz__GetStatus *tptz__GetStatus;	/* optional element of type tptz:GetStatus */
};
#endif

#ifndef SOAP_TYPE___tptz__GetConfiguration
#define SOAP_TYPE___tptz__GetConfiguration (1670)
/* Operation wrapper: */
struct __tptz__GetConfiguration
{
public:
	_tptz__GetConfiguration *tptz__GetConfiguration;	/* optional element of type tptz:GetConfiguration */
};
#endif

#ifndef SOAP_TYPE___tptz__GetNodes
#define SOAP_TYPE___tptz__GetNodes (1674)
/* Operation wrapper: */
struct __tptz__GetNodes
{
public:
	_tptz__GetNodes *tptz__GetNodes;	/* optional element of type tptz:GetNodes */
};
#endif

#ifndef SOAP_TYPE___tptz__GetNode
#define SOAP_TYPE___tptz__GetNode (1678)
/* Operation wrapper: */
struct __tptz__GetNode
{
public:
	_tptz__GetNode *tptz__GetNode;	/* optional element of type tptz:GetNode */
};
#endif

#ifndef SOAP_TYPE___tptz__SetConfiguration
#define SOAP_TYPE___tptz__SetConfiguration (1682)
/* Operation wrapper: */
struct __tptz__SetConfiguration
{
public:
	_tptz__SetConfiguration *tptz__SetConfiguration;	/* optional element of type tptz:SetConfiguration */
};
#endif

#ifndef SOAP_TYPE___tptz__GetConfigurationOptions
#define SOAP_TYPE___tptz__GetConfigurationOptions (1686)
/* Operation wrapper: */
struct __tptz__GetConfigurationOptions
{
public:
	_tptz__GetConfigurationOptions *tptz__GetConfigurationOptions;	/* optional element of type tptz:GetConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___tptz__GotoHomePosition
#define SOAP_TYPE___tptz__GotoHomePosition (1690)
/* Operation wrapper: */
struct __tptz__GotoHomePosition
{
public:
	_tptz__GotoHomePosition *tptz__GotoHomePosition;	/* optional element of type tptz:GotoHomePosition */
};
#endif

#ifndef SOAP_TYPE___tptz__SetHomePosition
#define SOAP_TYPE___tptz__SetHomePosition (1694)
/* Operation wrapper: */
struct __tptz__SetHomePosition
{
public:
	_tptz__SetHomePosition *tptz__SetHomePosition;	/* optional element of type tptz:SetHomePosition */
};
#endif

#ifndef SOAP_TYPE___tptz__ContinuousMove
#define SOAP_TYPE___tptz__ContinuousMove (1698)
/* Operation wrapper: */
struct __tptz__ContinuousMove
{
public:
	_tptz__ContinuousMove *tptz__ContinuousMove;	/* optional element of type tptz:ContinuousMove */
};
#endif

#ifndef SOAP_TYPE___tptz__RelativeMove
#define SOAP_TYPE___tptz__RelativeMove (1702)
/* Operation wrapper: */
struct __tptz__RelativeMove
{
public:
	_tptz__RelativeMove *tptz__RelativeMove;	/* optional element of type tptz:RelativeMove */
};
#endif

#ifndef SOAP_TYPE___tptz__SendAuxiliaryCommand
#define SOAP_TYPE___tptz__SendAuxiliaryCommand (1706)
/* Operation wrapper: */
struct __tptz__SendAuxiliaryCommand
{
public:
	_tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand;	/* optional element of type tptz:SendAuxiliaryCommand */
};
#endif

#ifndef SOAP_TYPE___tptz__AbsoluteMove
#define SOAP_TYPE___tptz__AbsoluteMove (1710)
/* Operation wrapper: */
struct __tptz__AbsoluteMove
{
public:
	_tptz__AbsoluteMove *tptz__AbsoluteMove;	/* optional element of type tptz:AbsoluteMove */
};
#endif

#ifndef SOAP_TYPE___tptz__Stop
#define SOAP_TYPE___tptz__Stop (1714)
/* Operation wrapper: */
struct __tptz__Stop
{
public:
	_tptz__Stop *tptz__Stop;	/* optional element of type tptz:Stop */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoSources
#define SOAP_TYPE___trt__GetVideoSources (1718)
/* Operation wrapper: */
struct __trt__GetVideoSources
{
public:
	_trt__GetVideoSources *trt__GetVideoSources;	/* optional element of type trt:GetVideoSources */
};
#endif

#ifndef SOAP_TYPE___trt__GetAudioSources
#define SOAP_TYPE___trt__GetAudioSources (1722)
/* Operation wrapper: */
struct __trt__GetAudioSources
{
public:
	_trt__GetAudioSources *trt__GetAudioSources;	/* optional element of type trt:GetAudioSources */
};
#endif

#ifndef SOAP_TYPE___trt__CreateProfile
#define SOAP_TYPE___trt__CreateProfile (1726)
/* Operation wrapper: */
struct __trt__CreateProfile
{
public:
	_trt__CreateProfile *trt__CreateProfile;	/* optional element of type trt:CreateProfile */
};
#endif

#ifndef SOAP_TYPE___trt__GetProfile
#define SOAP_TYPE___trt__GetProfile (1730)
/* Operation wrapper: */
struct __trt__GetProfile
{
public:
	_trt__GetProfile *trt__GetProfile;	/* optional element of type trt:GetProfile */
};
#endif

#ifndef SOAP_TYPE___trt__GetProfiles
#define SOAP_TYPE___trt__GetProfiles (1734)
/* Operation wrapper: */
struct __trt__GetProfiles
{
public:
	_trt__GetProfiles *trt__GetProfiles;	/* optional element of type trt:GetProfiles */
};
#endif

#ifndef SOAP_TYPE___trt__AddVideoEncoderConfiguration
#define SOAP_TYPE___trt__AddVideoEncoderConfiguration (1738)
/* Operation wrapper: */
struct __trt__AddVideoEncoderConfiguration
{
public:
	_trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration;	/* optional element of type trt:AddVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__AddVideoSourceConfiguration
#define SOAP_TYPE___trt__AddVideoSourceConfiguration (1742)
/* Operation wrapper: */
struct __trt__AddVideoSourceConfiguration
{
public:
	_trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration;	/* optional element of type trt:AddVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__AddAudioEncoderConfiguration
#define SOAP_TYPE___trt__AddAudioEncoderConfiguration (1746)
/* Operation wrapper: */
struct __trt__AddAudioEncoderConfiguration
{
public:
	_trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration;	/* optional element of type trt:AddAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__AddAudioSourceConfiguration
#define SOAP_TYPE___trt__AddAudioSourceConfiguration (1750)
/* Operation wrapper: */
struct __trt__AddAudioSourceConfiguration
{
public:
	_trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration;	/* optional element of type trt:AddAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__AddPTZConfiguration
#define SOAP_TYPE___trt__AddPTZConfiguration (1754)
/* Operation wrapper: */
struct __trt__AddPTZConfiguration
{
public:
	_trt__AddPTZConfiguration *trt__AddPTZConfiguration;	/* optional element of type trt:AddPTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__AddVideoAnalyticsConfiguration (1758)
/* Operation wrapper: */
struct __trt__AddVideoAnalyticsConfiguration
{
public:
	_trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration;	/* optional element of type trt:AddVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__AddMetadataConfiguration
#define SOAP_TYPE___trt__AddMetadataConfiguration (1762)
/* Operation wrapper: */
struct __trt__AddMetadataConfiguration
{
public:
	_trt__AddMetadataConfiguration *trt__AddMetadataConfiguration;	/* optional element of type trt:AddMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE___trt__RemoveVideoEncoderConfiguration (1766)
/* Operation wrapper: */
struct __trt__RemoveVideoEncoderConfiguration
{
public:
	_trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration;	/* optional element of type trt:RemoveVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE___trt__RemoveVideoSourceConfiguration (1770)
/* Operation wrapper: */
struct __trt__RemoveVideoSourceConfiguration
{
public:
	_trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration;	/* optional element of type trt:RemoveVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioEncoderConfiguration (1774)
/* Operation wrapper: */
struct __trt__RemoveAudioEncoderConfiguration
{
public:
	_trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration;	/* optional element of type trt:RemoveAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE___trt__RemoveAudioSourceConfiguration (1778)
/* Operation wrapper: */
struct __trt__RemoveAudioSourceConfiguration
{
public:
	_trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration;	/* optional element of type trt:RemoveAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__RemovePTZConfiguration
#define SOAP_TYPE___trt__RemovePTZConfiguration (1782)
/* Operation wrapper: */
struct __trt__RemovePTZConfiguration
{
public:
	_trt__RemovePTZConfiguration *trt__RemovePTZConfiguration;	/* optional element of type trt:RemovePTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration (1786)
/* Operation wrapper: */
struct __trt__RemoveVideoAnalyticsConfiguration
{
public:
	_trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration;	/* optional element of type trt:RemoveVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__RemoveMetadataConfiguration
#define SOAP_TYPE___trt__RemoveMetadataConfiguration (1790)
/* Operation wrapper: */
struct __trt__RemoveMetadataConfiguration
{
public:
	_trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration;	/* optional element of type trt:RemoveMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__DeleteProfile
#define SOAP_TYPE___trt__DeleteProfile (1794)
/* Operation wrapper: */
struct __trt__DeleteProfile
{
public:
	_trt__DeleteProfile *trt__DeleteProfile;	/* optional element of type trt:DeleteProfile */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurations
#define SOAP_TYPE___trt__GetVideoSourceConfigurations (1798)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurations
{
public:
	_trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations;	/* optional element of type trt:GetVideoSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetVideoEncoderConfigurations (1802)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurations
{
public:
	_trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations;	/* optional element of type trt:GetVideoEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurations
#define SOAP_TYPE___trt__GetAudioSourceConfigurations (1806)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurations
{
public:
	_trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations;	/* optional element of type trt:GetAudioSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetAudioEncoderConfigurations (1810)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurations
{
public:
	_trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations;	/* optional element of type trt:GetAudioEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetVideoAnalyticsConfigurations (1814)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfigurations
{
public:
	_trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations;	/* optional element of type trt:GetVideoAnalyticsConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetMetadataConfigurations
#define SOAP_TYPE___trt__GetMetadataConfigurations (1818)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurations
{
public:
	_trt__GetMetadataConfigurations *trt__GetMetadataConfigurations;	/* optional element of type trt:GetMetadataConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoSourceConfiguration
#define SOAP_TYPE___trt__GetVideoSourceConfiguration (1822)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfiguration
{
public:
	_trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration;	/* optional element of type trt:GetVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoEncoderConfiguration
#define SOAP_TYPE___trt__GetVideoEncoderConfiguration (1826)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfiguration
{
public:
	_trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration;	/* optional element of type trt:GetVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__GetAudioSourceConfiguration
#define SOAP_TYPE___trt__GetAudioSourceConfiguration (1830)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfiguration
{
public:
	_trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration;	/* optional element of type trt:GetAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__GetAudioEncoderConfiguration
#define SOAP_TYPE___trt__GetAudioEncoderConfiguration (1834)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfiguration
{
public:
	_trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration;	/* optional element of type trt:GetAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__GetVideoAnalyticsConfiguration (1838)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfiguration
{
public:
	_trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration;	/* optional element of type trt:GetVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__GetMetadataConfiguration
#define SOAP_TYPE___trt__GetMetadataConfiguration (1842)
/* Operation wrapper: */
struct __trt__GetMetadataConfiguration
{
public:
	_trt__GetMetadataConfiguration *trt__GetMetadataConfiguration;	/* optional element of type trt:GetMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations (1846)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoEncoderConfigurations
{
public:
	_trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations;	/* optional element of type trt:GetCompatibleVideoEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations (1850)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoSourceConfigurations
{
public:
	_trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations;	/* optional element of type trt:GetCompatibleVideoSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations (1854)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioEncoderConfigurations
{
public:
	_trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations;	/* optional element of type trt:GetCompatibleAudioEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations (1858)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioSourceConfigurations
{
public:
	_trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations;	/* optional element of type trt:GetCompatibleAudioSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations (1862)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	_trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations;	/* optional element of type trt:GetCompatibleVideoAnalyticsConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE___trt__GetCompatibleMetadataConfigurations (1866)
/* Operation wrapper: */
struct __trt__GetCompatibleMetadataConfigurations
{
public:
	_trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations;	/* optional element of type trt:GetCompatibleMetadataConfigurations */
};
#endif

#ifndef SOAP_TYPE___trt__SetVideoSourceConfiguration
#define SOAP_TYPE___trt__SetVideoSourceConfiguration (1870)
/* Operation wrapper: */
struct __trt__SetVideoSourceConfiguration
{
public:
	_trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration;	/* optional element of type trt:SetVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__SetVideoEncoderConfiguration
#define SOAP_TYPE___trt__SetVideoEncoderConfiguration (1874)
/* Operation wrapper: */
struct __trt__SetVideoEncoderConfiguration
{
public:
	_trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration;	/* optional element of type trt:SetVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__SetAudioSourceConfiguration
#define SOAP_TYPE___trt__SetAudioSourceConfiguration (1878)
/* Operation wrapper: */
struct __trt__SetAudioSourceConfiguration
{
public:
	_trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration;	/* optional element of type trt:SetAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__SetAudioEncoderConfiguration
#define SOAP_TYPE___trt__SetAudioEncoderConfiguration (1882)
/* Operation wrapper: */
struct __trt__SetAudioEncoderConfiguration
{
public:
	_trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration;	/* optional element of type trt:SetAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__SetVideoAnalyticsConfiguration (1886)
/* Operation wrapper: */
struct __trt__SetVideoAnalyticsConfiguration
{
public:
	_trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration;	/* optional element of type trt:SetVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__SetMetadataConfiguration
#define SOAP_TYPE___trt__SetMetadataConfiguration (1890)
/* Operation wrapper: */
struct __trt__SetMetadataConfiguration
{
public:
	_trt__SetMetadataConfiguration *trt__SetMetadataConfiguration;	/* optional element of type trt:SetMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___trt__GetVideoSourceConfigurationOptions (1894)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurationOptions
{
public:
	_trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions;	/* optional element of type trt:GetVideoSourceConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions (1898)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurationOptions
{
public:
	_trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions;	/* optional element of type trt:GetVideoEncoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___trt__GetAudioSourceConfigurationOptions (1902)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurationOptions
{
public:
	_trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions;	/* optional element of type trt:GetAudioSourceConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions (1906)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurationOptions
{
public:
	_trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions;	/* optional element of type trt:GetAudioEncoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___trt__GetMetadataConfigurationOptions
#define SOAP_TYPE___trt__GetMetadataConfigurationOptions (1910)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurationOptions
{
public:
	_trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions;	/* optional element of type trt:GetMetadataConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances (1914)
/* Operation wrapper: */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	_trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* optional element of type trt:GetGuaranteedNumberOfVideoEncoderInstances */
};
#endif

#ifndef SOAP_TYPE___trt__GetStreamUri
#define SOAP_TYPE___trt__GetStreamUri (1918)
/* Operation wrapper: */
struct __trt__GetStreamUri
{
public:
	_trt__GetStreamUri *trt__GetStreamUri;	/* optional element of type trt:GetStreamUri */
};
#endif

#ifndef SOAP_TYPE___trt__StartMulticastStreaming
#define SOAP_TYPE___trt__StartMulticastStreaming (1922)
/* Operation wrapper: */
struct __trt__StartMulticastStreaming
{
public:
	_trt__StartMulticastStreaming *trt__StartMulticastStreaming;	/* optional element of type trt:StartMulticastStreaming */
};
#endif

#ifndef SOAP_TYPE___trt__StopMulticastStreaming
#define SOAP_TYPE___trt__StopMulticastStreaming (1926)
/* Operation wrapper: */
struct __trt__StopMulticastStreaming
{
public:
	_trt__StopMulticastStreaming *trt__StopMulticastStreaming;	/* optional element of type trt:StopMulticastStreaming */
};
#endif

#ifndef SOAP_TYPE___trt__SetSynchronizationPoint
#define SOAP_TYPE___trt__SetSynchronizationPoint (1930)
/* Operation wrapper: */
struct __trt__SetSynchronizationPoint
{
public:
	_trt__SetSynchronizationPoint *trt__SetSynchronizationPoint;	/* optional element of type trt:SetSynchronizationPoint */
};
#endif

#ifndef SOAP_TYPE___trt__GetSnapshotUri
#define SOAP_TYPE___trt__GetSnapshotUri (1934)
/* Operation wrapper: */
struct __trt__GetSnapshotUri
{
public:
	_trt__GetSnapshotUri *trt__GetSnapshotUri;	/* optional element of type trt:GetSnapshotUri */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1935)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1937)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1938)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE__wsa__EndpointReference
#define SOAP_TYPE__wsa__EndpointReference (20)
typedef struct wsa__EndpointReferenceType _wsa__EndpointReference;
#endif

#ifndef SOAP_TYPE__wsa__MessageID
#define SOAP_TYPE__wsa__MessageID (21)
typedef char *_wsa__MessageID;
#endif

#ifndef SOAP_TYPE__wsa__RelatesTo
#define SOAP_TYPE__wsa__RelatesTo (22)
typedef struct wsa__Relationship _wsa__RelatesTo;
#endif

#ifndef SOAP_TYPE__wsa__To
#define SOAP_TYPE__wsa__To (23)
typedef char *_wsa__To;
#endif

#ifndef SOAP_TYPE__wsa__Action
#define SOAP_TYPE__wsa__Action (24)
typedef char *_wsa__Action;
#endif

#ifndef SOAP_TYPE__wsa__From
#define SOAP_TYPE__wsa__From (25)
typedef struct wsa__EndpointReferenceType _wsa__From;
#endif

#ifndef SOAP_TYPE__wsa__ReplyTo
#define SOAP_TYPE__wsa__ReplyTo (26)
typedef struct wsa__EndpointReferenceType _wsa__ReplyTo;
#endif

#ifndef SOAP_TYPE__wsa__FaultTo
#define SOAP_TYPE__wsa__FaultTo (27)
typedef struct wsa__EndpointReferenceType _wsa__FaultTo;
#endif

#ifndef SOAP_TYPE__wsa__ReplyAfter
#define SOAP_TYPE__wsa__ReplyAfter (29)
typedef unsigned int _wsa__ReplyAfter;
#endif

#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (43)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (44)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (49)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (50)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (51)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (52)
typedef char *_wsa5__MessageID;
#endif

#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (53)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (54)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (55)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (56)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (57)
typedef char *_wsa5__To;
#endif

#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (58)
typedef char *_wsa5__Action;
#endif

#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (60)
typedef ULONG64 _wsa5__RetryAfter;
#endif

#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (61)
typedef char *_wsa5__ProblemHeaderQName;
#endif

#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (62)
typedef char *_wsa5__ProblemIRI;
#endif

#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (63)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (126)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__IDREFS
#define SOAP_TYPE_xsd__IDREFS (128)
typedef std::string xsd__IDREFS;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (130)
typedef std::string xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (134)
typedef std::string xsd__anySimpleType;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (136)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (152)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (154)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (157)
typedef std::string xsd__token;
#endif

#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (160)
typedef std::string _xml__lang;
#endif

#ifndef SOAP_TYPE_ns1__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_ns1__AbsoluteOrRelativeTimeType (777)
typedef std::string ns1__AbsoluteOrRelativeTimeType;
#endif

#ifndef SOAP_TYPE_ns6__OpenRelationshipType
#define SOAP_TYPE_ns6__OpenRelationshipType (778)
typedef std::string ns6__OpenRelationshipType;
#endif

#ifndef SOAP_TYPE_ns6__QNameListType
#define SOAP_TYPE_ns6__QNameListType (779)
typedef std::string ns6__QNameListType;
#endif

#ifndef SOAP_TYPE_ns6__UriListType
#define SOAP_TYPE_ns6__UriListType (780)
typedef std::string ns6__UriListType;
#endif

#ifndef SOAP_TYPE_ns6__FaultCodeOpenType
#define SOAP_TYPE_ns6__FaultCodeOpenType (781)
typedef std::string ns6__FaultCodeOpenType;
#endif

#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (782)
typedef std::string tt__ReferenceToken;
#endif

#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (784)
typedef std::string tt__Name;
#endif

#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (804)
typedef int tt__IANA_IfTypes;
#endif

#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (812)
typedef std::string tt__IPv4Address;
#endif

#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (814)
typedef std::string tt__IPv6Address;
#endif

#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (816)
typedef std::string tt__HwAddress;
#endif

#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (820)
typedef std::string tt__DNSName;
#endif

#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (822)
typedef std::string tt__Domain;
#endif

#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (844)
typedef std::string tt__AuxiliaryData;
#endif

#ifndef SOAP_TYPE_tt__TopicNamespaceLocation
#define SOAP_TYPE_tt__TopicNamespaceLocation (864)
typedef std::string tt__TopicNamespaceLocation;
#endif

#ifndef SOAP_TYPE_ns3__FullTopicExpression
#define SOAP_TYPE_ns3__FullTopicExpression (872)
typedef std::string ns3__FullTopicExpression;
#endif

#ifndef SOAP_TYPE_ns3__ConcreteTopicExpression
#define SOAP_TYPE_ns3__ConcreteTopicExpression (874)
typedef std::string ns3__ConcreteTopicExpression;
#endif

#ifndef SOAP_TYPE_ns3__SimpleTopicExpression
#define SOAP_TYPE_ns3__SimpleTopicExpression (876)
typedef xsd__QName ns3__SimpleTopicExpression;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 __ns10__PullMessages(struct soap*, _tev__PullMessages *tev__PullMessages, _tev__PullMessagesResponse *tev__PullMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns10__SetSynchronizationPoint(struct soap*, _tev__SetSynchronizationPoint *tev__SetSynchronizationPoint, _tev__SetSynchronizationPointResponse *tev__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns11__CreatePullPointSubscription(struct soap*, _tev__CreatePullPointSubscription *tev__CreatePullPointSubscription, _tev__CreatePullPointSubscriptionResponse *tev__CreatePullPointSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns11__GetEventProperties(struct soap*, _tev__GetEventProperties *tev__GetEventProperties, _tev__GetEventPropertiesResponse *tev__GetEventPropertiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns12__Renew(struct soap*, _ns1__Renew *ns1__Renew, _ns1__RenewResponse *ns1__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns12__Unsubscribe(struct soap*, _ns1__Unsubscribe *ns1__Unsubscribe, _ns1__UnsubscribeResponse *ns1__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns13__Subscribe(struct soap*, _ns1__Subscribe *ns1__Subscribe, _ns1__SubscribeResponse *ns1__SubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns13__GetCurrentMessage(struct soap*, _ns1__GetCurrentMessage *ns1__GetCurrentMessage, _ns1__GetCurrentMessageResponse *ns1__GetCurrentMessageResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns14__Notify(struct soap*, _ns1__Notify *ns1__Notify);

SOAP_FMAC5 int SOAP_FMAC6 __ns15__GetMessages(struct soap*, _ns1__GetMessages *ns1__GetMessages, _ns1__GetMessagesResponse *ns1__GetMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns15__DestroyPullPoint(struct soap*, _ns1__DestroyPullPoint *ns1__DestroyPullPoint, _ns1__DestroyPullPointResponse *ns1__DestroyPullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns15__Notify(struct soap*, _ns1__Notify *ns1__Notify);

SOAP_FMAC5 int SOAP_FMAC6 __ns16__CreatePullPoint(struct soap*, _ns1__CreatePullPoint *ns1__CreatePullPoint, _ns1__CreatePullPointResponse *ns1__CreatePullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns17__Renew(struct soap*, _ns1__Renew *ns1__Renew, _ns1__RenewResponse *ns1__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns17__Unsubscribe(struct soap*, _ns1__Unsubscribe *ns1__Unsubscribe, _ns1__UnsubscribeResponse *ns1__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns17__PauseSubscription(struct soap*, _ns1__PauseSubscription *ns1__PauseSubscription, _ns1__PauseSubscriptionResponse *ns1__PauseSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns17__ResumeSubscription(struct soap*, _ns1__ResumeSubscription *ns1__ResumeSubscription, _ns1__ResumeSubscriptionResponse *ns1__ResumeSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns18__Hello(struct soap*, ns6__HelloType *dn__Hello, ns6__ResolveType *dn__HelloResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns18__Bye(struct soap*, ns6__ByeType *dn__Bye, ns6__ResolveType *dn__ByeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns19__Probe(struct soap*, ns6__ProbeType *dn__Probe, ns6__ProbeMatchesType *dn__ProbeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns8__GetSupportedRules(struct soap*, _tan__GetSupportedRules *tan__GetSupportedRules, _tan__GetSupportedRulesResponse *tan__GetSupportedRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns8__CreateRules(struct soap*, _tan__CreateRules *tan__CreateRules, _tan__CreateRulesResponse *tan__CreateRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns8__DeleteRules(struct soap*, _tan__DeleteRules *tan__DeleteRules, _tan__DeleteRulesResponse *tan__DeleteRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns8__GetRules(struct soap*, _tan__GetRules *tan__GetRules, _tan__GetRulesResponse *tan__GetRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns8__ModifyRules(struct soap*, _tan__ModifyRules *tan__ModifyRules, _tan__ModifyRulesResponse *tan__ModifyRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns9__GetSupportedAnalyticsModules(struct soap*, _tan__GetSupportedAnalyticsModules *tan__GetSupportedAnalyticsModules, _tan__GetSupportedAnalyticsModulesResponse *tan__GetSupportedAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns9__CreateAnalyticsModules(struct soap*, _tan__CreateAnalyticsModules *tan__CreateAnalyticsModules, _tan__CreateAnalyticsModulesResponse *tan__CreateAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns9__DeleteAnalyticsModules(struct soap*, _tan__DeleteAnalyticsModules *tan__DeleteAnalyticsModules, _tan__DeleteAnalyticsModulesResponse *tan__DeleteAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns9__GetAnalyticsModules(struct soap*, _tan__GetAnalyticsModules *tan__GetAnalyticsModules, _tan__GetAnalyticsModulesResponse *tan__GetAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns9__ModifyAnalyticsModules(struct soap*, _tan__ModifyAnalyticsModules *tan__ModifyAnalyticsModules, _tan__ModifyAnalyticsModulesResponse *tan__ModifyAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDeviceInformation(struct soap*, _tds__GetDeviceInformation *tds__GetDeviceInformation, _tds__GetDeviceInformationResponse *tds__GetDeviceInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemDateAndTime(struct soap*, _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime, _tds__SetSystemDateAndTimeResponse *tds__SetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemDateAndTime(struct soap*, _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime, _tds__GetSystemDateAndTimeResponse *tds__GetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemFactoryDefault(struct soap*, _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault, _tds__SetSystemFactoryDefaultResponse *tds__SetSystemFactoryDefaultResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__UpgradeSystemFirmware(struct soap*, _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware, _tds__UpgradeSystemFirmwareResponse *tds__UpgradeSystemFirmwareResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SystemReboot(struct soap*, _tds__SystemReboot *tds__SystemReboot, _tds__SystemRebootResponse *tds__SystemRebootResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__RestoreSystem(struct soap*, _tds__RestoreSystem *tds__RestoreSystem, _tds__RestoreSystemResponse *tds__RestoreSystemResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemBackup(struct soap*, _tds__GetSystemBackup *tds__GetSystemBackup, _tds__GetSystemBackupResponse *tds__GetSystemBackupResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemLog(struct soap*, _tds__GetSystemLog *tds__GetSystemLog, _tds__GetSystemLogResponse *tds__GetSystemLogResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemSupportInformation(struct soap*, _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation, _tds__GetSystemSupportInformationResponse *tds__GetSystemSupportInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetScopes(struct soap*, _tds__GetScopes *tds__GetScopes, _tds__GetScopesResponse *tds__GetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetScopes(struct soap*, _tds__SetScopes *tds__SetScopes, _tds__SetScopesResponse *tds__SetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__AddScopes(struct soap*, _tds__AddScopes *tds__AddScopes, _tds__AddScopesResponse *tds__AddScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveScopes(struct soap*, _tds__RemoveScopes *tds__RemoveScopes, _tds__RemoveScopesResponse *tds__RemoveScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDiscoveryMode(struct soap*, _tds__GetDiscoveryMode *tds__GetDiscoveryMode, _tds__GetDiscoveryModeResponse *tds__GetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDiscoveryMode(struct soap*, _tds__SetDiscoveryMode *tds__SetDiscoveryMode, _tds__SetDiscoveryModeResponse *tds__SetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRemoteDiscoveryMode(struct soap*, _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode, _tds__GetRemoteDiscoveryModeResponse *tds__GetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRemoteDiscoveryMode(struct soap*, _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode, _tds__SetRemoteDiscoveryModeResponse *tds__SetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDPAddresses(struct soap*, _tds__GetDPAddresses *tds__GetDPAddresses, _tds__GetDPAddressesResponse *tds__GetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetUsers(struct soap*, _tds__GetUsers *tds__GetUsers, _tds__GetUsersResponse *tds__GetUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateUsers(struct soap*, _tds__CreateUsers *tds__CreateUsers, _tds__CreateUsersResponse *tds__CreateUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteUsers(struct soap*, _tds__DeleteUsers *tds__DeleteUsers, _tds__DeleteUsersResponse *tds__DeleteUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetUser(struct soap*, _tds__SetUser *tds__SetUser, _tds__SetUserResponse *tds__SetUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetWsdlUrl(struct soap*, _tds__GetWsdlUrl *tds__GetWsdlUrl, _tds__GetWsdlUrlResponse *tds__GetWsdlUrlResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCapabilities(struct soap*, _tds__GetCapabilities *tds__GetCapabilities, _tds__GetCapabilitiesResponse *tds__GetCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDPAddresses(struct soap*, _tds__SetDPAddresses *tds__SetDPAddresses, _tds__SetDPAddressesResponse *tds__SetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetHostname(struct soap*, _tds__GetHostname *tds__GetHostname, _tds__GetHostnameResponse *tds__GetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetHostname(struct soap*, _tds__SetHostname *tds__SetHostname, _tds__SetHostnameResponse *tds__SetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDNS(struct soap*, _tds__GetDNS *tds__GetDNS, _tds__GetDNSResponse *tds__GetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDNS(struct soap*, _tds__SetDNS *tds__SetDNS, _tds__SetDNSResponse *tds__SetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNTP(struct soap*, _tds__GetNTP *tds__GetNTP, _tds__GetNTPResponse *tds__GetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNTP(struct soap*, _tds__SetNTP *tds__SetNTP, _tds__SetNTPResponse *tds__SetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDynamicDNS(struct soap*, _tds__GetDynamicDNS *tds__GetDynamicDNS, _tds__GetDynamicDNSResponse *tds__GetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDynamicDNS(struct soap*, _tds__SetDynamicDNS *tds__SetDynamicDNS, _tds__SetDynamicDNSResponse *tds__SetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkInterfaces(struct soap*, _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces, _tds__GetNetworkInterfacesResponse *tds__GetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkInterfaces(struct soap*, _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces, _tds__SetNetworkInterfacesResponse *tds__SetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkProtocols(struct soap*, _tds__GetNetworkProtocols *tds__GetNetworkProtocols, _tds__GetNetworkProtocolsResponse *tds__GetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkProtocols(struct soap*, _tds__SetNetworkProtocols *tds__SetNetworkProtocols, _tds__SetNetworkProtocolsResponse *tds__SetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkDefaultGateway(struct soap*, _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway, _tds__GetNetworkDefaultGatewayResponse *tds__GetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkDefaultGateway(struct soap*, _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway, _tds__SetNetworkDefaultGatewayResponse *tds__SetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetZeroConfiguration(struct soap*, _tds__GetZeroConfiguration *tds__GetZeroConfiguration, _tds__GetZeroConfigurationResponse *tds__GetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetZeroConfiguration(struct soap*, _tds__SetZeroConfiguration *tds__SetZeroConfiguration, _tds__SetZeroConfigurationResponse *tds__SetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetIPAddressFilter(struct soap*, _tds__GetIPAddressFilter *tds__GetIPAddressFilter, _tds__GetIPAddressFilterResponse *tds__GetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetIPAddressFilter(struct soap*, _tds__SetIPAddressFilter *tds__SetIPAddressFilter, _tds__SetIPAddressFilterResponse *tds__SetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__AddIPAddressFilter(struct soap*, _tds__AddIPAddressFilter *tds__AddIPAddressFilter, _tds__AddIPAddressFilterResponse *tds__AddIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveIPAddressFilter(struct soap*, _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter, _tds__RemoveIPAddressFilterResponse *tds__RemoveIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetAccessPolicy(struct soap*, _tds__GetAccessPolicy *tds__GetAccessPolicy, _tds__GetAccessPolicyResponse *tds__GetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetAccessPolicy(struct soap*, _tds__SetAccessPolicy *tds__SetAccessPolicy, _tds__SetAccessPolicyResponse *tds__SetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateCertificate(struct soap*, _tds__CreateCertificate *tds__CreateCertificate, _tds__CreateCertificateResponse *tds__CreateCertificateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificates(struct soap*, _tds__GetCertificates *tds__GetCertificates, _tds__GetCertificatesResponse *tds__GetCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificatesStatus(struct soap*, _tds__GetCertificatesStatus *tds__GetCertificatesStatus, _tds__GetCertificatesStatusResponse *tds__GetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetCertificatesStatus(struct soap*, _tds__SetCertificatesStatus *tds__SetCertificatesStatus, _tds__SetCertificatesStatusResponse *tds__SetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteCertificates(struct soap*, _tds__DeleteCertificates *tds__DeleteCertificates, _tds__DeleteCertificatesResponse *tds__DeleteCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetPkcs10Request(struct soap*, _tds__GetPkcs10Request *tds__GetPkcs10Request, _tds__GetPkcs10RequestResponse *tds__GetPkcs10RequestResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCertificates(struct soap*, _tds__LoadCertificates *tds__LoadCertificates, _tds__LoadCertificatesResponse *tds__LoadCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetClientCertificateMode(struct soap*, _tds__GetClientCertificateMode *tds__GetClientCertificateMode, _tds__GetClientCertificateModeResponse *tds__GetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetClientCertificateMode(struct soap*, _tds__SetClientCertificateMode *tds__SetClientCertificateMode, _tds__SetClientCertificateModeResponse *tds__SetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRelayOutputs(struct soap*, _tds__GetRelayOutputs *tds__GetRelayOutputs, _tds__GetRelayOutputsResponse *tds__GetRelayOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputSettings(struct soap*, _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings, _tds__SetRelayOutputSettingsResponse *tds__SetRelayOutputSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputState(struct soap*, _tds__SetRelayOutputState *tds__SetRelayOutputState, _tds__SetRelayOutputStateResponse *tds__SetRelayOutputStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetImagingSettings(struct soap*, _timg__GetImagingSettings *timg__GetImagingSettings, _timg__GetImagingSettingsResponse *timg__GetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__SetImagingSettings(struct soap*, _timg__SetImagingSettings *timg__SetImagingSettings, _timg__SetImagingSettingsResponse *timg__SetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetOptions(struct soap*, _timg__GetOptions *timg__GetOptions, _timg__GetOptionsResponse *timg__GetOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__Move(struct soap*, _timg__Move *timg__Move, _timg__MoveResponse *timg__MoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__Stop(struct soap*, _timg__Stop *timg__Stop, _timg__StopResponse *timg__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetStatus(struct soap*, _timg__GetStatus *timg__GetStatus, _timg__GetStatusResponse *timg__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetMoveOptions(struct soap*, _timg__GetMoveOptions *timg__GetMoveOptions, _timg__GetMoveOptionsResponse *timg__GetMoveOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfigurations(struct soap*, _tptz__GetConfigurations *tptz__GetConfigurations, _tptz__GetConfigurationsResponse *tptz__GetConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresets(struct soap*, _tptz__GetPresets *tptz__GetPresets, _tptz__GetPresetsResponse *tptz__GetPresetsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetPreset(struct soap*, _tptz__SetPreset *tptz__SetPreset, _tptz__SetPresetResponse *tptz__SetPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__RemovePreset(struct soap*, _tptz__RemovePreset *tptz__RemovePreset, _tptz__RemovePresetResponse *tptz__RemovePresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GotoPreset(struct soap*, _tptz__GotoPreset *tptz__GotoPreset, _tptz__GotoPresetResponse *tptz__GotoPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetStatus(struct soap*, _tptz__GetStatus *tptz__GetStatus, _tptz__GetStatusResponse *tptz__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfiguration(struct soap*, _tptz__GetConfiguration *tptz__GetConfiguration, _tptz__GetConfigurationResponse *tptz__GetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetNodes(struct soap*, _tptz__GetNodes *tptz__GetNodes, _tptz__GetNodesResponse *tptz__GetNodesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetNode(struct soap*, _tptz__GetNode *tptz__GetNode, _tptz__GetNodeResponse *tptz__GetNodeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetConfiguration(struct soap*, _tptz__SetConfiguration *tptz__SetConfiguration, _tptz__SetConfigurationResponse *tptz__SetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfigurationOptions(struct soap*, _tptz__GetConfigurationOptions *tptz__GetConfigurationOptions, _tptz__GetConfigurationOptionsResponse *tptz__GetConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GotoHomePosition(struct soap*, _tptz__GotoHomePosition *tptz__GotoHomePosition, _tptz__GotoHomePositionResponse *tptz__GotoHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetHomePosition(struct soap*, _tptz__SetHomePosition *tptz__SetHomePosition, _tptz__SetHomePositionResponse *tptz__SetHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__ContinuousMove(struct soap*, _tptz__ContinuousMove *tptz__ContinuousMove, _tptz__ContinuousMoveResponse *tptz__ContinuousMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__RelativeMove(struct soap*, _tptz__RelativeMove *tptz__RelativeMove, _tptz__RelativeMoveResponse *tptz__RelativeMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SendAuxiliaryCommand(struct soap*, _tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand, _tptz__SendAuxiliaryCommandResponse *tptz__SendAuxiliaryCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__AbsoluteMove(struct soap*, _tptz__AbsoluteMove *tptz__AbsoluteMove, _tptz__AbsoluteMoveResponse *tptz__AbsoluteMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__Stop(struct soap*, _tptz__Stop *tptz__Stop, _tptz__StopResponse *tptz__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSources(struct soap*, _trt__GetVideoSources *trt__GetVideoSources, _trt__GetVideoSourcesResponse *trt__GetVideoSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSources(struct soap*, _trt__GetAudioSources *trt__GetAudioSources, _trt__GetAudioSourcesResponse *trt__GetAudioSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__CreateProfile(struct soap*, _trt__CreateProfile *trt__CreateProfile, _trt__CreateProfileResponse *trt__CreateProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetProfile(struct soap*, _trt__GetProfile *trt__GetProfile, _trt__GetProfileResponse *trt__GetProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetProfiles(struct soap*, _trt__GetProfiles *trt__GetProfiles, _trt__GetProfilesResponse *trt__GetProfilesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoEncoderConfiguration(struct soap*, _trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration, _trt__AddVideoEncoderConfigurationResponse *trt__AddVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoSourceConfiguration(struct soap*, _trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration, _trt__AddVideoSourceConfigurationResponse *trt__AddVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioEncoderConfiguration(struct soap*, _trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration, _trt__AddAudioEncoderConfigurationResponse *trt__AddAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioSourceConfiguration(struct soap*, _trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration, _trt__AddAudioSourceConfigurationResponse *trt__AddAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddPTZConfiguration(struct soap*, _trt__AddPTZConfiguration *trt__AddPTZConfiguration, _trt__AddPTZConfigurationResponse *trt__AddPTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoAnalyticsConfiguration(struct soap*, _trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration, _trt__AddVideoAnalyticsConfigurationResponse *trt__AddVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddMetadataConfiguration(struct soap*, _trt__AddMetadataConfiguration *trt__AddMetadataConfiguration, _trt__AddMetadataConfigurationResponse *trt__AddMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoEncoderConfiguration(struct soap*, _trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration, _trt__RemoveVideoEncoderConfigurationResponse *trt__RemoveVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoSourceConfiguration(struct soap*, _trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration, _trt__RemoveVideoSourceConfigurationResponse *trt__RemoveVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioEncoderConfiguration(struct soap*, _trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration, _trt__RemoveAudioEncoderConfigurationResponse *trt__RemoveAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioSourceConfiguration(struct soap*, _trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration, _trt__RemoveAudioSourceConfigurationResponse *trt__RemoveAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemovePTZConfiguration(struct soap*, _trt__RemovePTZConfiguration *trt__RemovePTZConfiguration, _trt__RemovePTZConfigurationResponse *trt__RemovePTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoAnalyticsConfiguration(struct soap*, _trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration, _trt__RemoveVideoAnalyticsConfigurationResponse *trt__RemoveVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveMetadataConfiguration(struct soap*, _trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration, _trt__RemoveMetadataConfigurationResponse *trt__RemoveMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__DeleteProfile(struct soap*, _trt__DeleteProfile *trt__DeleteProfile, _trt__DeleteProfileResponse *trt__DeleteProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfigurations(struct soap*, _trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations, _trt__GetVideoSourceConfigurationsResponse *trt__GetVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfigurations(struct soap*, _trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations, _trt__GetVideoEncoderConfigurationsResponse *trt__GetVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfigurations(struct soap*, _trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations, _trt__GetAudioSourceConfigurationsResponse *trt__GetAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfigurations(struct soap*, _trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations, _trt__GetAudioEncoderConfigurationsResponse *trt__GetAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoAnalyticsConfigurations(struct soap*, _trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations, _trt__GetVideoAnalyticsConfigurationsResponse *trt__GetVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfigurations(struct soap*, _trt__GetMetadataConfigurations *trt__GetMetadataConfigurations, _trt__GetMetadataConfigurationsResponse *trt__GetMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfiguration(struct soap*, _trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration, _trt__GetVideoSourceConfigurationResponse *trt__GetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfiguration(struct soap*, _trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration, _trt__GetVideoEncoderConfigurationResponse *trt__GetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfiguration(struct soap*, _trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration, _trt__GetAudioSourceConfigurationResponse *trt__GetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfiguration(struct soap*, _trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration, _trt__GetAudioEncoderConfigurationResponse *trt__GetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoAnalyticsConfiguration(struct soap*, _trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration, _trt__GetVideoAnalyticsConfigurationResponse *trt__GetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfiguration(struct soap*, _trt__GetMetadataConfiguration *trt__GetMetadataConfiguration, _trt__GetMetadataConfigurationResponse *trt__GetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoEncoderConfigurations(struct soap*, _trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations, _trt__GetCompatibleVideoEncoderConfigurationsResponse *trt__GetCompatibleVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoSourceConfigurations(struct soap*, _trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations, _trt__GetCompatibleVideoSourceConfigurationsResponse *trt__GetCompatibleVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioEncoderConfigurations(struct soap*, _trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations, _trt__GetCompatibleAudioEncoderConfigurationsResponse *trt__GetCompatibleAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioSourceConfigurations(struct soap*, _trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations, _trt__GetCompatibleAudioSourceConfigurationsResponse *trt__GetCompatibleAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, _trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *trt__GetCompatibleVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleMetadataConfigurations(struct soap*, _trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations, _trt__GetCompatibleMetadataConfigurationsResponse *trt__GetCompatibleMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoSourceConfiguration(struct soap*, _trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration, _trt__SetVideoSourceConfigurationResponse *trt__SetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoEncoderConfiguration(struct soap*, _trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration, _trt__SetVideoEncoderConfigurationResponse *trt__SetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioSourceConfiguration(struct soap*, _trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration, _trt__SetAudioSourceConfigurationResponse *trt__SetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioEncoderConfiguration(struct soap*, _trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration, _trt__SetAudioEncoderConfigurationResponse *trt__SetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoAnalyticsConfiguration(struct soap*, _trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration, _trt__SetVideoAnalyticsConfigurationResponse *trt__SetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetMetadataConfiguration(struct soap*, _trt__SetMetadataConfiguration *trt__SetMetadataConfiguration, _trt__SetMetadataConfigurationResponse *trt__SetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfigurationOptions(struct soap*, _trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions, _trt__GetVideoSourceConfigurationOptionsResponse *trt__GetVideoSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfigurationOptions(struct soap*, _trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions, _trt__GetVideoEncoderConfigurationOptionsResponse *trt__GetVideoEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfigurationOptions(struct soap*, _trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions, _trt__GetAudioSourceConfigurationOptionsResponse *trt__GetAudioSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfigurationOptions(struct soap*, _trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions, _trt__GetAudioEncoderConfigurationOptionsResponse *trt__GetAudioEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfigurationOptions(struct soap*, _trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions, _trt__GetMetadataConfigurationOptionsResponse *trt__GetMetadataConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, _trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetStreamUri(struct soap*, _trt__GetStreamUri *trt__GetStreamUri, _trt__GetStreamUriResponse *trt__GetStreamUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__StartMulticastStreaming(struct soap*, _trt__StartMulticastStreaming *trt__StartMulticastStreaming, _trt__StartMulticastStreamingResponse *trt__StartMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__StopMulticastStreaming(struct soap*, _trt__StopMulticastStreaming *trt__StopMulticastStreaming, _trt__StopMulticastStreamingResponse *trt__StopMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetSynchronizationPoint(struct soap*, _trt__SetSynchronizationPoint *trt__SetSynchronizationPoint, _trt__SetSynchronizationPointResponse *trt__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetSnapshotUri(struct soap*, _trt__GetSnapshotUri *trt__GetSnapshotUri, _trt__GetSnapshotUriResponse *trt__GetSnapshotUriResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns10__PullMessages(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns10__SetSynchronizationPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns11__CreatePullPointSubscription(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns11__GetEventProperties(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns12__Renew(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns12__Unsubscribe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns13__Subscribe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns13__GetCurrentMessage(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns14__Notify(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns15__GetMessages(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns15__DestroyPullPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns15__Notify(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns16__CreatePullPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns17__Renew(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns17__Unsubscribe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns17__PauseSubscription(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns17__ResumeSubscription(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns18__Hello(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns18__Bye(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns19__Probe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns8__GetSupportedRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns8__CreateRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns8__DeleteRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns8__GetRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns8__ModifyRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns9__GetSupportedAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns9__CreateAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns9__DeleteAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns9__GetAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns9__ModifyAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDeviceInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetSystemDateAndTime(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemDateAndTime(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetSystemFactoryDefault(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__UpgradeSystemFirmware(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SystemReboot(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__RestoreSystem(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemBackup(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemSupportInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__AddScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__RemoveScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetRemoteDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetRemoteDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDPAddresses(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetUsers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__CreateUsers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__DeleteUsers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetWsdlUrl(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDPAddresses(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetHostname(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetHostname(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNTP(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNTP(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDynamicDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDynamicDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNetworkInterfaces(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNetworkInterfaces(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNetworkProtocols(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNetworkProtocols(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNetworkDefaultGateway(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNetworkDefaultGateway(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetZeroConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetZeroConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__AddIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__RemoveIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetAccessPolicy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetAccessPolicy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__CreateCertificate(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCertificatesStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetCertificatesStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__DeleteCertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetPkcs10Request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__LoadCertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetClientCertificateMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetClientCertificateMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetRelayOutputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetRelayOutputSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetRelayOutputState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetImagingSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__SetImagingSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__Move(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__Stop(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetMoveOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetPresets(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SetPreset(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__RemovePreset(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GotoPreset(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetNodes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetNode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SetConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GotoHomePosition(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SetHomePosition(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__ContinuousMove(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__RelativeMove(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SendAuxiliaryCommand(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__AbsoluteMove(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__Stop(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSources(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSources(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__CreateProfile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetProfile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetProfiles(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddPTZConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemovePTZConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__DeleteProfile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoAnalyticsConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetMetadataConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleVideoEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleVideoSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleAudioEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleAudioSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleMetadataConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSourceConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoEncoderConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSourceConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioEncoderConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetMetadataConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetStreamUri(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__StartMulticastStreaming(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__StopMulticastStreaming(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetSynchronizationPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetSnapshotUri(struct soap*);

/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns10__PullMessages(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__PullMessages *tev__PullMessages, _tev__PullMessagesResponse *tev__PullMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns10__SetSynchronizationPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__SetSynchronizationPoint *tev__SetSynchronizationPoint, _tev__SetSynchronizationPointResponse *tev__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns11__CreatePullPointSubscription(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__CreatePullPointSubscription *tev__CreatePullPointSubscription, _tev__CreatePullPointSubscriptionResponse *tev__CreatePullPointSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns11__GetEventProperties(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__GetEventProperties *tev__GetEventProperties, _tev__GetEventPropertiesResponse *tev__GetEventPropertiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns12__Renew(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Renew *ns1__Renew, _ns1__RenewResponse *ns1__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns12__Unsubscribe(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Unsubscribe *ns1__Unsubscribe, _ns1__UnsubscribeResponse *ns1__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns13__Subscribe(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Subscribe *ns1__Subscribe, _ns1__SubscribeResponse *ns1__SubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns13__GetCurrentMessage(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCurrentMessage *ns1__GetCurrentMessage, _ns1__GetCurrentMessageResponse *ns1__GetCurrentMessageResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns14__Notify(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Notify *ns1__Notify);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns14__Notify(struct soap *soap, struct __ns14__Notify *_param_1);


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns15__GetMessages(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetMessages *ns1__GetMessages, _ns1__GetMessagesResponse *ns1__GetMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns15__DestroyPullPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DestroyPullPoint *ns1__DestroyPullPoint, _ns1__DestroyPullPointResponse *ns1__DestroyPullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns15__Notify(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Notify *ns1__Notify);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns15__Notify(struct soap *soap, struct __ns15__Notify *_param_2);


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns16__CreatePullPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreatePullPoint *ns1__CreatePullPoint, _ns1__CreatePullPointResponse *ns1__CreatePullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns17__Renew(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Renew *ns1__Renew, _ns1__RenewResponse *ns1__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns17__Unsubscribe(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Unsubscribe *ns1__Unsubscribe, _ns1__UnsubscribeResponse *ns1__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns17__PauseSubscription(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__PauseSubscription *ns1__PauseSubscription, _ns1__PauseSubscriptionResponse *ns1__PauseSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns17__ResumeSubscription(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ResumeSubscription *ns1__ResumeSubscription, _ns1__ResumeSubscriptionResponse *ns1__ResumeSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns18__Hello(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns6__HelloType *dn__Hello, ns6__ResolveType *dn__HelloResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns18__Bye(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns6__ByeType *dn__Bye, ns6__ResolveType *dn__ByeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns19__Probe(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns6__ProbeType *dn__Probe, ns6__ProbeMatchesType *dn__ProbeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns8__GetSupportedRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetSupportedRules *tan__GetSupportedRules, _tan__GetSupportedRulesResponse *tan__GetSupportedRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns8__CreateRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__CreateRules *tan__CreateRules, _tan__CreateRulesResponse *tan__CreateRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns8__DeleteRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__DeleteRules *tan__DeleteRules, _tan__DeleteRulesResponse *tan__DeleteRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns8__GetRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetRules *tan__GetRules, _tan__GetRulesResponse *tan__GetRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns8__ModifyRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__ModifyRules *tan__ModifyRules, _tan__ModifyRulesResponse *tan__ModifyRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns9__GetSupportedAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetSupportedAnalyticsModules *tan__GetSupportedAnalyticsModules, _tan__GetSupportedAnalyticsModulesResponse *tan__GetSupportedAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns9__CreateAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__CreateAnalyticsModules *tan__CreateAnalyticsModules, _tan__CreateAnalyticsModulesResponse *tan__CreateAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns9__DeleteAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__DeleteAnalyticsModules *tan__DeleteAnalyticsModules, _tan__DeleteAnalyticsModulesResponse *tan__DeleteAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns9__GetAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetAnalyticsModules *tan__GetAnalyticsModules, _tan__GetAnalyticsModulesResponse *tan__GetAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns9__ModifyAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__ModifyAnalyticsModules *tan__ModifyAnalyticsModules, _tan__ModifyAnalyticsModulesResponse *tan__ModifyAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDeviceInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDeviceInformation *tds__GetDeviceInformation, _tds__GetDeviceInformationResponse *tds__GetDeviceInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetSystemDateAndTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime, _tds__SetSystemDateAndTimeResponse *tds__SetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemDateAndTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime, _tds__GetSystemDateAndTimeResponse *tds__GetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetSystemFactoryDefault(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault, _tds__SetSystemFactoryDefaultResponse *tds__SetSystemFactoryDefaultResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__UpgradeSystemFirmware(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware, _tds__UpgradeSystemFirmwareResponse *tds__UpgradeSystemFirmwareResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SystemReboot(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SystemReboot *tds__SystemReboot, _tds__SystemRebootResponse *tds__SystemRebootResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RestoreSystem(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RestoreSystem *tds__RestoreSystem, _tds__RestoreSystemResponse *tds__RestoreSystemResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemBackup(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemBackup *tds__GetSystemBackup, _tds__GetSystemBackupResponse *tds__GetSystemBackupResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemLog(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemLog *tds__GetSystemLog, _tds__GetSystemLogResponse *tds__GetSystemLogResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemSupportInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation, _tds__GetSystemSupportInformationResponse *tds__GetSystemSupportInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetScopes *tds__GetScopes, _tds__GetScopesResponse *tds__GetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetScopes *tds__SetScopes, _tds__SetScopesResponse *tds__SetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__AddScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__AddScopes *tds__AddScopes, _tds__AddScopesResponse *tds__AddScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RemoveScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RemoveScopes *tds__RemoveScopes, _tds__RemoveScopesResponse *tds__RemoveScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDiscoveryMode *tds__GetDiscoveryMode, _tds__GetDiscoveryModeResponse *tds__GetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDiscoveryMode *tds__SetDiscoveryMode, _tds__SetDiscoveryModeResponse *tds__SetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode, _tds__GetRemoteDiscoveryModeResponse *tds__GetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode, _tds__SetRemoteDiscoveryModeResponse *tds__SetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDPAddresses(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDPAddresses *tds__GetDPAddresses, _tds__GetDPAddressesResponse *tds__GetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetUsers *tds__GetUsers, _tds__GetUsersResponse *tds__GetUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateUsers *tds__CreateUsers, _tds__CreateUsersResponse *tds__CreateUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteUsers *tds__DeleteUsers, _tds__DeleteUsersResponse *tds__DeleteUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetUser *tds__SetUser, _tds__SetUserResponse *tds__SetUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetWsdlUrl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetWsdlUrl *tds__GetWsdlUrl, _tds__GetWsdlUrlResponse *tds__GetWsdlUrlResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCapabilities *tds__GetCapabilities, _tds__GetCapabilitiesResponse *tds__GetCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDPAddresses(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDPAddresses *tds__SetDPAddresses, _tds__SetDPAddressesResponse *tds__SetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetHostname(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetHostname *tds__GetHostname, _tds__GetHostnameResponse *tds__GetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetHostname(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetHostname *tds__SetHostname, _tds__SetHostnameResponse *tds__SetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDNS *tds__GetDNS, _tds__GetDNSResponse *tds__GetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDNS *tds__SetDNS, _tds__SetDNSResponse *tds__SetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNTP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNTP *tds__GetNTP, _tds__GetNTPResponse *tds__GetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNTP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNTP *tds__SetNTP, _tds__SetNTPResponse *tds__SetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDynamicDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDynamicDNS *tds__GetDynamicDNS, _tds__GetDynamicDNSResponse *tds__GetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDynamicDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDynamicDNS *tds__SetDynamicDNS, _tds__SetDynamicDNSResponse *tds__SetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkInterfaces(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces, _tds__GetNetworkInterfacesResponse *tds__GetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkInterfaces(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces, _tds__SetNetworkInterfacesResponse *tds__SetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkProtocols(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkProtocols *tds__GetNetworkProtocols, _tds__GetNetworkProtocolsResponse *tds__GetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkProtocols(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkProtocols *tds__SetNetworkProtocols, _tds__SetNetworkProtocolsResponse *tds__SetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkDefaultGateway(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway, _tds__GetNetworkDefaultGatewayResponse *tds__GetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkDefaultGateway(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway, _tds__SetNetworkDefaultGatewayResponse *tds__SetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetZeroConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetZeroConfiguration *tds__GetZeroConfiguration, _tds__GetZeroConfigurationResponse *tds__GetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetZeroConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetZeroConfiguration *tds__SetZeroConfiguration, _tds__SetZeroConfigurationResponse *tds__SetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetIPAddressFilter *tds__GetIPAddressFilter, _tds__GetIPAddressFilterResponse *tds__GetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetIPAddressFilter *tds__SetIPAddressFilter, _tds__SetIPAddressFilterResponse *tds__SetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__AddIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__AddIPAddressFilter *tds__AddIPAddressFilter, _tds__AddIPAddressFilterResponse *tds__AddIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RemoveIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter, _tds__RemoveIPAddressFilterResponse *tds__RemoveIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetAccessPolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetAccessPolicy *tds__GetAccessPolicy, _tds__GetAccessPolicyResponse *tds__GetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetAccessPolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetAccessPolicy *tds__SetAccessPolicy, _tds__SetAccessPolicyResponse *tds__SetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateCertificate(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateCertificate *tds__CreateCertificate, _tds__CreateCertificateResponse *tds__CreateCertificateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificates *tds__GetCertificates, _tds__GetCertificatesResponse *tds__GetCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificatesStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificatesStatus *tds__GetCertificatesStatus, _tds__GetCertificatesStatusResponse *tds__GetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetCertificatesStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetCertificatesStatus *tds__SetCertificatesStatus, _tds__SetCertificatesStatusResponse *tds__SetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteCertificates *tds__DeleteCertificates, _tds__DeleteCertificatesResponse *tds__DeleteCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetPkcs10Request(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetPkcs10Request *tds__GetPkcs10Request, _tds__GetPkcs10RequestResponse *tds__GetPkcs10RequestResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__LoadCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__LoadCertificates *tds__LoadCertificates, _tds__LoadCertificatesResponse *tds__LoadCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetClientCertificateMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetClientCertificateMode *tds__GetClientCertificateMode, _tds__GetClientCertificateModeResponse *tds__GetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetClientCertificateMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetClientCertificateMode *tds__SetClientCertificateMode, _tds__SetClientCertificateModeResponse *tds__SetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRelayOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRelayOutputs *tds__GetRelayOutputs, _tds__GetRelayOutputsResponse *tds__GetRelayOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRelayOutputSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings, _tds__SetRelayOutputSettingsResponse *tds__SetRelayOutputSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRelayOutputState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRelayOutputState *tds__SetRelayOutputState, _tds__SetRelayOutputStateResponse *tds__SetRelayOutputStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetImagingSettings *timg__GetImagingSettings, _timg__GetImagingSettingsResponse *timg__GetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__SetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__SetImagingSettings *timg__SetImagingSettings, _timg__SetImagingSettingsResponse *timg__SetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetOptions *timg__GetOptions, _timg__GetOptionsResponse *timg__GetOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__Move(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Move *timg__Move, _timg__MoveResponse *timg__MoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__Stop(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Stop *timg__Stop, _timg__StopResponse *timg__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetStatus *timg__GetStatus, _timg__GetStatusResponse *timg__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetMoveOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetMoveOptions *timg__GetMoveOptions, _timg__GetMoveOptionsResponse *timg__GetMoveOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetConfigurations *tptz__GetConfigurations, _tptz__GetConfigurationsResponse *tptz__GetConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetPresets(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetPresets *tptz__GetPresets, _tptz__GetPresetsResponse *tptz__GetPresetsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SetPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SetPreset *tptz__SetPreset, _tptz__SetPresetResponse *tptz__SetPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__RemovePreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__RemovePreset *tptz__RemovePreset, _tptz__RemovePresetResponse *tptz__RemovePresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GotoPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GotoPreset *tptz__GotoPreset, _tptz__GotoPresetResponse *tptz__GotoPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetStatus *tptz__GetStatus, _tptz__GetStatusResponse *tptz__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetConfiguration *tptz__GetConfiguration, _tptz__GetConfigurationResponse *tptz__GetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetNodes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetNodes *tptz__GetNodes, _tptz__GetNodesResponse *tptz__GetNodesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetNode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetNode *tptz__GetNode, _tptz__GetNodeResponse *tptz__GetNodeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SetConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SetConfiguration *tptz__SetConfiguration, _tptz__SetConfigurationResponse *tptz__SetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetConfigurationOptions *tptz__GetConfigurationOptions, _tptz__GetConfigurationOptionsResponse *tptz__GetConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GotoHomePosition(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GotoHomePosition *tptz__GotoHomePosition, _tptz__GotoHomePositionResponse *tptz__GotoHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SetHomePosition(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SetHomePosition *tptz__SetHomePosition, _tptz__SetHomePositionResponse *tptz__SetHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__ContinuousMove(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__ContinuousMove *tptz__ContinuousMove, _tptz__ContinuousMoveResponse *tptz__ContinuousMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__RelativeMove(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__RelativeMove *tptz__RelativeMove, _tptz__RelativeMoveResponse *tptz__RelativeMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SendAuxiliaryCommand(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand, _tptz__SendAuxiliaryCommandResponse *tptz__SendAuxiliaryCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__AbsoluteMove(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__AbsoluteMove *tptz__AbsoluteMove, _tptz__AbsoluteMoveResponse *tptz__AbsoluteMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__Stop(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__Stop *tptz__Stop, _tptz__StopResponse *tptz__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSources *trt__GetVideoSources, _trt__GetVideoSourcesResponse *trt__GetVideoSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSources *trt__GetAudioSources, _trt__GetAudioSourcesResponse *trt__GetAudioSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__CreateProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__CreateProfile *trt__CreateProfile, _trt__CreateProfileResponse *trt__CreateProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetProfile *trt__GetProfile, _trt__GetProfileResponse *trt__GetProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetProfiles(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetProfiles *trt__GetProfiles, _trt__GetProfilesResponse *trt__GetProfilesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration, _trt__AddVideoEncoderConfigurationResponse *trt__AddVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration, _trt__AddVideoSourceConfigurationResponse *trt__AddVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration, _trt__AddAudioEncoderConfigurationResponse *trt__AddAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration, _trt__AddAudioSourceConfigurationResponse *trt__AddAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddPTZConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddPTZConfiguration *trt__AddPTZConfiguration, _trt__AddPTZConfigurationResponse *trt__AddPTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration, _trt__AddVideoAnalyticsConfigurationResponse *trt__AddVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddMetadataConfiguration *trt__AddMetadataConfiguration, _trt__AddMetadataConfigurationResponse *trt__AddMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration, _trt__RemoveVideoEncoderConfigurationResponse *trt__RemoveVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration, _trt__RemoveVideoSourceConfigurationResponse *trt__RemoveVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration, _trt__RemoveAudioEncoderConfigurationResponse *trt__RemoveAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration, _trt__RemoveAudioSourceConfigurationResponse *trt__RemoveAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemovePTZConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemovePTZConfiguration *trt__RemovePTZConfiguration, _trt__RemovePTZConfigurationResponse *trt__RemovePTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration, _trt__RemoveVideoAnalyticsConfigurationResponse *trt__RemoveVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration, _trt__RemoveMetadataConfigurationResponse *trt__RemoveMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__DeleteProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__DeleteProfile *trt__DeleteProfile, _trt__DeleteProfileResponse *trt__DeleteProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations, _trt__GetVideoSourceConfigurationsResponse *trt__GetVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations, _trt__GetVideoEncoderConfigurationsResponse *trt__GetVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations, _trt__GetAudioSourceConfigurationsResponse *trt__GetAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations, _trt__GetAudioEncoderConfigurationsResponse *trt__GetAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations, _trt__GetVideoAnalyticsConfigurationsResponse *trt__GetVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfigurations *trt__GetMetadataConfigurations, _trt__GetMetadataConfigurationsResponse *trt__GetMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration, _trt__GetVideoSourceConfigurationResponse *trt__GetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration, _trt__GetVideoEncoderConfigurationResponse *trt__GetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration, _trt__GetAudioSourceConfigurationResponse *trt__GetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration, _trt__GetAudioEncoderConfigurationResponse *trt__GetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration, _trt__GetVideoAnalyticsConfigurationResponse *trt__GetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfiguration *trt__GetMetadataConfiguration, _trt__GetMetadataConfigurationResponse *trt__GetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations, _trt__GetCompatibleVideoEncoderConfigurationsResponse *trt__GetCompatibleVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations, _trt__GetCompatibleVideoSourceConfigurationsResponse *trt__GetCompatibleVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations, _trt__GetCompatibleAudioEncoderConfigurationsResponse *trt__GetCompatibleAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations, _trt__GetCompatibleAudioSourceConfigurationsResponse *trt__GetCompatibleAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *trt__GetCompatibleVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations, _trt__GetCompatibleMetadataConfigurationsResponse *trt__GetCompatibleMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration, _trt__SetVideoSourceConfigurationResponse *trt__SetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration, _trt__SetVideoEncoderConfigurationResponse *trt__SetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration, _trt__SetAudioSourceConfigurationResponse *trt__SetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration, _trt__SetAudioEncoderConfigurationResponse *trt__SetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration, _trt__SetVideoAnalyticsConfigurationResponse *trt__SetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetMetadataConfiguration *trt__SetMetadataConfiguration, _trt__SetMetadataConfigurationResponse *trt__SetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions, _trt__GetVideoSourceConfigurationOptionsResponse *trt__GetVideoSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions, _trt__GetVideoEncoderConfigurationOptionsResponse *trt__GetVideoEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions, _trt__GetAudioSourceConfigurationOptionsResponse *trt__GetAudioSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions, _trt__GetAudioEncoderConfigurationOptionsResponse *trt__GetAudioEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions, _trt__GetMetadataConfigurationOptionsResponse *trt__GetMetadataConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetStreamUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetStreamUri *trt__GetStreamUri, _trt__GetStreamUriResponse *trt__GetStreamUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__StartMulticastStreaming(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__StartMulticastStreaming *trt__StartMulticastStreaming, _trt__StartMulticastStreamingResponse *trt__StartMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__StopMulticastStreaming(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__StopMulticastStreaming *trt__StopMulticastStreaming, _trt__StopMulticastStreamingResponse *trt__StopMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetSynchronizationPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetSynchronizationPoint *trt__SetSynchronizationPoint, _trt__SetSynchronizationPointResponse *trt__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetSnapshotUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetSnapshotUri *trt__GetSnapshotUri, _trt__GetSnapshotUriResponse *trt__GetSnapshotUriResponse);

#endif

/* End of soapStub.h */
